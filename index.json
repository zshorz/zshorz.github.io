[{"categories":["program"],"content":"背景 在写代码过程中，有时候需要做一些批量 查询/操作，往往会涉及将一个很大的数组或切片进行分块。 比如我们有一个存着id的数组，要根据id请求某个接口查询信息，这个接口支持批量查询，但是每次查询的数量上限是100。最好的做法是每次从数组中取最多100个id，进行批量查询，直到遍历完数组。 这个操作不复杂，可以简单的用循环实现，但是每次遇到这种场景都需要写一次代码，有点写吐了。所以就想写一个函数，可以将[]T按需求拆分成[][]T。 但是go的泛型还没有来，所以只能用反射来搞了。 献祭我的周六饭后时光 ","date":"2021-07-17","objectID":"/slice-chunking-in-go/:1:0","tags":["go","reflect"],"title":"Go反射: 将切片按指定大小分块","uri":"/slice-chunking-in-go/"},{"categories":["program"],"content":"成果 传入[]T，T可以是任意类型，按指定大小分块，返回[][]T。 例子中将[0,1,2,3,4,5,6,7,8,9]划分成了[0,1,2]、[3,4,5]、[6,7,8]、[9] https://github.com/kirito41dd/xslice package main import ( \"fmt\" \"github.com/kirito41dd/xslice\" ) func main() { s := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} i := xslice.SplitToChunks(s, 3) ss := i.([][]int) fmt.Println(ss) // [[0 1 2] [3 4 5] [6 7 8] [9]] } ","date":"2021-07-17","objectID":"/slice-chunking-in-go/:2:0","tags":["go","reflect"],"title":"Go反射: 将切片按指定大小分块","uri":"/slice-chunking-in-go/"},{"categories":["program"],"content":"代码实现 反射一把梭，自然离不了可爱的interface{} 欢迎复制或引包github.com/kirito41dd/xslice使用，如果以后搬砖遇到其他场景，也会继续扩充。 还是期待go泛型早点到来（那时候我rust应该已经很6了吧 func SplitToChunks(slice interface{}, chunkSize int) interface{} { sliceType := reflect.TypeOf(slice) sliceVal := reflect.ValueOf(slice) length := sliceVal.Len() if sliceType.Kind() != reflect.Slice { panic(\"parameter must be []T\") } n := 0 if length%chunkSize \u003e 0 { n = 1 } SST := reflect.MakeSlice(reflect.SliceOf(sliceType), 0, length/chunkSize+n) st, ed := 0, 0 for st \u003c length { ed = st + chunkSize if ed \u003e length { ed = length } SST = reflect.Append(SST, sliceVal.Slice(st, ed)) st = ed } return SST.Interface() } ","date":"2021-07-17","objectID":"/slice-chunking-in-go/:3:0","tags":["go","reflect"],"title":"Go反射: 将切片按指定大小分块","uri":"/slice-chunking-in-go/"},{"categories":["default"],"content":"最近给IDE装了vim插件(ideaVim)，因为觉得写代码时候老是要去按上下左右，效率很低，更主要是low，不够装逼（ 但不建议独立使用vim，因为要大量练习才行，和IDE配合使用，可以把重点放在光标移动上，其余功能让IDE来负责。低成本装逼 ","date":"2021-07-14","objectID":"/zhuangbi-with-vim/:0:0","tags":["vim"],"title":"vim装逼要点","uri":"/zhuangbi-with-vim/"},{"categories":["default"],"content":"move h j k l - ⬅️ ⬇️ ⬆️ ➡️ w/e - 跳转到下一个词 开头/末尾（按符号或空白分词） 助记 word / end W/E - 同上（按空白分词） b/ge - 跳转到上一个词 开头/末尾（按符号或空白分词） B/gE - 同上（按空白分词） f\u003c?\u003e/t\u003c?\u003e - 跳转到光标位置后指定 字符上/字符前，不跨行 比如 12345，使用f4后变为 12345，使用t4则为 12345 助记 find / to，;可以重复执行 F\u003c?\u003e/T\u003c?\u003e - 跳转到光标位置前指定 字符上/字符前，不夸行 % - 当前行如果有括号，移动到它的另一半 gg/G - 跳转到文件 开头/结尾 \u003cn\u003egg/\u003cn\u003eG - 跳转到指定行号 0/\u0026 - 移动到 行开头/末尾 ^、_/g_ - 移动到 行开头/末尾 第一个非空白字符 \u003cCtrl+b\u003e/\u003cCtrl+f\u003e - 向 上/下 滚一个屏幕 助记 back front \u003cCtrl+u\u003e/\u003cCtrl+d\u003e - 向 上/下 滚半个屏幕 助记 up down zz/zt/zb - 令光标行处于屏幕 中间/顶部/底部 助记 zoom zoom/top/bottom \u003cCtrl+o\u003e/\u003cCtrl+i\u003e - 光标跳转到jump list的 上一个位置/下一个位置 jump list里只记录跳转历史，简单移动光标不会被记录 :jump可以查看所有位置 m\u003ca-zA-Z\u003e - 如ma，标记当前光标位置，并起名为a 小写的名字只在当前缓冲区可见，大写可以跨缓冲区 :marks查看所有标记位置，你也会看到其他非字母的标记 '\u003ca-zA-Z\u003e/ `\u003ca-zA-Z\u003e - 如'a回到a位置所在在行首/ `a回到a位置 一个是单引号，一个是反引号，''永远返回上一个位置 zo/zc - 打开折叠/关闭折叠 zO/zC - 打开折叠/关闭折叠，递归 zM/zR - 关闭/打开 所有折叠 gd、\u003cCtrl+]\u003e - 跳转到定义，\u003cCtrl+t\u003e返回(用的是tag stack) Crtl+t 与 Ctrl+o 区别 ","date":"2021-07-14","objectID":"/zhuangbi-with-vim/:1:0","tags":["vim"],"title":"vim装逼要点","uri":"/zhuangbi-with-vim/"},{"categories":["default"],"content":"编辑 dd/ \u003cn\u003edd - 删除当前行 / 删除n行 df\u003c?\u003e/dt\u003c?\u003e - 向后删除光标位置到指定字符 / 删除到指定字符前，不跨行 dF\u003c?\u003e/dT\u003c?\u003e - 反向，向前删除，同上 d$/d^ - 从光标删除到 行尾/行开头，用其他位置符也行 yy/\u003cn\u003eyy - 复制当前行/复制n行 p/P - 粘贴到当前 行后/行前，\u003cn\u003ep就是重复做n次 \"\u003creg\u003ey/\"\u003creg\u003ep - 复制到指定寄存器/从指定寄存器粘贴 命令模式:reg 可以看各个寄存器的内容 +寄存器通常与系统剪切板互通 di\"/da\" - 删除引号内的内容/连引号一起删，必须单行 助记 delete in \"\" / delete all \"\" 还有di(、di{等 x - 删除光标字符 r\u003c?\u003e - 用指定字符替换光标字符 ","date":"2021-07-14","objectID":"/zhuangbi-with-vim/:2:0","tags":["vim"],"title":"vim装逼要点","uri":"/zhuangbi-with-vim/"},{"categories":["default"],"content":"入场 三连入场，神清气爽。从normal模式进入编辑模式 i/a - 在当前光标字符 前/后 插入 I/A - 在当前行 开头第一非空白字符前插入/结尾最后一个非空白字符后插入 o/O - 当前行 下面/上面 起新行 s - 删除当前字符并从该位置插入 ","date":"2021-07-14","objectID":"/zhuangbi-with-vim/:3:0","tags":["vim"],"title":"vim装逼要点","uri":"/zhuangbi-with-vim/"},{"categories":["program"],"content":"学习笔记，对标cpp理解下rust所有权以及借用的概念，顺便提下比较特殊的切片(DST) ","date":"2021-07-10","objectID":"/rust-ownership-and-borrowing/:0:0","tags":["rust","ownership","DST"],"title":"Rust所有权与借用","uri":"/rust-ownership-and-borrowing/"},{"categories":["program"],"content":"所有权Ownership rust中每个值都有一个所有者变量，并且同一时间只有能一个所有者，当值的所有者变量超出作用域，值的内存会被释放。 下面的代码String的所有权从s1转移到了s2，发生了Move，此时再访问s1是非法的。参考 lets1=String::from(\"hello\");lets2=s1; 下面的代码i32的所有权没有从x转移到y，而是y复制了x，发生了Copy letx: i32 =1;lety=x; Move本质上也是浅拷贝：比如String内部实现是有一个指针指向了保存的字符串，所有权转移，其实只是拷贝了这个指针的值，并没有拷贝这个字符串。这时s1和s2的内存空间都保存着这个指针地址，由于所有权的存在，编译器保证了访问s1是非法的，所以s1虽然还指向字符串，但是什么都做不了，保证了安全。 关于内存释放：由于只有在所有者生命完结后，才会发生释放，所有权保证同一时间只有一个所有者，所以字符串所在地址并不会被释放两次double free。 这里我想对标cpp：cpp实现类似高效转移使用的是右值引用与移动构造函数。在s2的移动构造函数中把s1的指针偷过来，然后把s1的指针指向一个空字符串的地址或标记其无效。s1是作为右值引用传过来的，在语义上是将亡值，所以可以修改s1内部结构。但是，cpp没有所有权概念，编译器不会阻止你继续访问s1。这很安全（个屁 rust在什么情况下Move什么情况下Copy，取决于类型是否实现了CopyTrait。上面i32本来已经很小了，也没东西可以浅拷贝（就4个字节折腾啥），所以i32是拷贝语义。 rust基本类型几乎都实现了CopyTrait： pubtraitCopy: Clone {// Empty. 只是个Marker } 对于tuple、array，如果元素都实现了Copy，也会传拷贝。对于复杂类型，如果一个类型的某个部分实现了DropTrait，那么这个类型无法实现Copy；如果组成部分都实现了Copy，复杂类型也可以实现Copy。 所有权转移可以发生在赋值、传参、函数返回。 ","date":"2021-07-10","objectID":"/rust-ownership-and-borrowing/:1:0","tags":["rust","ownership","DST"],"title":"Rust所有权与借用","uri":"/rust-ownership-and-borrowing/"},{"categories":["program"],"content":"引用references\u0026借用borrowing 下面的代码中b并没有拿走所有权，而是通过\u0026取得了a的引用。 leta=String::from(\"123\");letb=\u0026a; b是对a的引用也可以描述为b借用了a，rust引用的底层可以对标为其他语言中的指针，只不过rust的引用带了生命周期和借用检查所以很安全。如cpp中的指针只是记录值了一个内存地址，与一个整型并没有啥差别，可以被保存被带到任何地方，容易发生内存泄漏。而rust编译器会保证引用的生命周期不会超过其指向的值的生命周期。 引用分为不可变引用immutable references与可变引用mutable references，获取可变引用使用let b = \u0026mut a，前提是a是可变的才能获取可变引用，可变引用与不可变引用的关系类似读写锁： 可以同时存在多个不可变引用(读锁) 可变引用与不可变引用不能同时存在(读、写锁互斥) 只能同时有一个可变引用(写锁) ","date":"2021-07-10","objectID":"/rust-ownership-and-borrowing/:2:0","tags":["rust","ownership","DST"],"title":"Rust所有权与借用","uri":"/rust-ownership-and-borrowing/"},{"categories":["program"],"content":"切片slice 切片很特殊，用来引用数组中的连续元素序列。 字符串切片string slices - \u0026str let s = String::from(\"hello world\"); let hello = \u0026s[0..5]; let s: \u0026str = \"xxx\"; let s2: \u0026str = \u0026s[..]; 字符串切片特殊点是范围只能取有效的utf8字符边界 数组切片 - \u0026[T] let a = [1, 2, 3, 4, 5]; let slice = \u0026a[1..3]; 切片用[start..end]来确定引用范围，区间左闭右开[start,end)。范围还可以简写为[..2]、[3..]、[..]，省略表示取边界。 切片是个胖指针，会保存目标集合的指针，与引用范围。 切片之所以特殊，需要说下rust的动态大小类型Dynamic Sized Type,DST，DST表示编译期无法获取大小的类型。 从数组说起，数组的类型表示为[T; N]，T是元素类型而N是元素个数，所以数组的大小编译期是可以确定的，数组不是DST。注意\u0026[i32; 3]是一个普通的数组引用，而\u0026[i32]才是一个数组切片。 切片是DST，准确来说[i32]才叫做切片，[T]这种类型表示由T组成的切片，这个切片的长度在编译期是不确定的（DST），编译器无法为一个不确定大小的类型分配空间，所以也无法声明DST类型的变量，只能用胖指针\u0026[T]来引用。 \u0026[T]的大小是固定的，里面有用于存储数据地址和长度的空间，这样就可以在运行时获取长度信息。比如要制造切片[1..n]，n的大小是编译期间无法得到的，所以只能在运行期间计算n的值，然后初始化胖指针完成引用。 字符串切片str也是DST，对应胖指针是\u0026str，可以把str理解为[T]的特殊形式，主要是用来表示utf8字符串。 除了切片，dyn Trait(Trait对象)也是DST，对应的胖指针是\u0026dyn Trait。（只要是DST类型，就无法声明对应类型变量 ","date":"2021-07-10","objectID":"/rust-ownership-and-borrowing/:2:1","tags":["rust","ownership","DST"],"title":"Rust所有权与借用","uri":"/rust-ownership-and-borrowing/"},{"categories":["program"],"content":"RCURead Copy Update这个词最近才听到，是在公司一位老哥的直播分享里听到的。那天在群里没事乱划，突然看到一个直播分享，原本就想进去嫖一眼，结果内容异常硬核，从头看到尾。 topic是用类似JITJust In Time的方式加速Go的json解析，这里顺便给他们打个广告，这个库开源了：https://github.com/bytedance/sonic 分享里提到了RCU这种技术，RCU原本是Linux内核中的一种同步机制，并且其针对的场景是读多写少。分享里他们遇到的场景是需要实现一个buffer，特性是： 读操作远多于写操作 希望读操作无锁、无等待 这样的场景非常适合使用RCU这种技术，RCU的基本实现是： 读使用原子操作读取数据指针，无锁、无等待 写/更新操作用互斥锁防护 不直接写/更新，而是先复制一份，对复制的数据进行写/更新 通过原子操作将数据指针指向刚修改过的副本 注：由于可能涉及资源释放，所以在有GC的语言上更容易实现 本质上就是牺牲写性能，提升读性能 代码也非常简单，只用互斥锁和一个原子变量就可以实现： type RCU struct { m sync.Mutex p unsafe.Pointer } func (r *RCU) Get(key K) V { return (*Map[K]V)(atomic.LoadPointer(\u0026r.p))[key] } func (r *RCU) Put(key K, val V) { r.m.Lock() defer r.m.Unlock() newm := new(Map[K]V) atomic.StorePointer(\u0026r.p, unsafe.Pointer(newm)) } 简单说一下，代码中Map、K、V都是虚拟的，可以根据需要更换（也不局限于KV）。 主要思想是通过原子操作，来更换指针指向的地址。 对于读，每次都会读出一个安全的数据地址，不会有其他线程修改这段数据，所以无需同步手段。 对于写，同时只能有一个写，否则存在丢失更新，所以加互斥锁防护。 由于写都是在拷贝上进行，所以不会影响读的性能 NICE！！！ ","date":"2021-06-28","objectID":"/read-copy-update/:0:0","tags":["RCU","sync"],"title":"Read Copy Update","uri":"/read-copy-update/"},{"categories":["default"],"content":"明德新民 止于至善 感觉校歌是真滴好听！ 嵩岳苍苍 河水泱泱， 中原文化悠且长， 济济多士 风雨一堂， 继往开来扬辉光， 四郊多垒 国仇难忘， 民主是式 科学允张， 猗欤吾校永无疆！ 猗欤吾校永无疆！ 从2017到2021，由于疫情的关系整整一年半没有呆在学校，就感觉四年过的非常快。大三下学期在被窝中完成课业，大四还没开学就顶着疫情去北京实习了。四年前的我还是个一无所知的少年，四年后蜕变成了一个一无所知的青年（ 学生的身份就此结束了，没有选择继续读研，原因有很多： 不会学习，对不感兴趣的课一点都听不进去 喜欢操代码，感觉可以直接工作（事实证明我确实可以 拿过一些奖项，但由于非专业课业成绩差点，还是离保研差了一步 考研是不可能考研的，很反感硕士考题。（看室友备考时来问我的题目，谭浩强年代的C，净考一些没有意义的玩意。 硕士了又怎样（ 希望以后不会对自己的选择后悔 大学四年也成长了很多，感谢我的两任女朋友(前任与现任) 照片🐎一下我sqdl，网络并非法外之地 最后，疾风亦有归途🐶 ","date":"2021-06-07","objectID":"/bi-ye-leee/:0:0","tags":[],"title":"毕业了！！！","uri":"/bi-ye-leee/"},{"categories":["program"],"content":"在linux系统中，通过bash中输入\u003cCtrl+C\u003e或者使用命令kill -9 $pid都可以杀死进程，但是它们有很大的不同。 先放结论：kill命令只会杀死目标进程，而bash快捷键则会杀死整个前台进程组！ ","date":"2021-05-07","objectID":"/different-from-ctrl-c-and-kill/:0:0","tags":["bash","signal","linux"],"title":"Ctrl+C与Kill杀死进程的区别","uri":"/different-from-ctrl-c-and-kill/"},{"categories":["program"],"content":"linux杀进程方式 不管使用那种方式，杀死进程都是通过发送信号（signal）来完成的，kill命令其实就是向目标pid进程发送信号： kill -9 - 发送SIGKILL kill -2 - 发送SIGINT kill -15 - 发送SIGTERM 完整列表如下： # kill -l HUP INT QUIT ILL TRAP ABRT EMT FPE KILL BUS SEGV SYS PIPE ALRM TERM URG STOP TSTP CONT CHLD TTIN TTOU IO XCPU XFSZ VTALRM PROF WINCH INFO USR1 USR2 bash快捷键发送信号方式如下： INT - \u003cCtrl+C\u003e KILL - \u003cCtrl+\\\u003e ","date":"2021-05-07","objectID":"/different-from-ctrl-c-and-kill/:1:0","tags":["bash","signal","linux"],"title":"Ctrl+C与Kill杀死进程的区别","uri":"/different-from-ctrl-c-and-kill/"},{"categories":["program"],"content":"前台进程组 会话是一个或多个进程组的集合，每登陆一个终端就相当于一个新会话，一个会话可以有一个前台进程组和多个后台进程组。 默认通过bash启动的程序，都会放在前台进程组，包括这个程序的子进程。 如果要放在后台进行组，可以使用\u0026指定 echo 123 \u0026 （另外，只有前台启动才会绑定标准输入输出。） 在bash中通过\u003cCtrl+C\u003e或\u003cCtrl+\\\u003e杀死进程，信号会被发送至前台进程组中的每一个进程。 而通过kill杀死程序，信号只会发送给目标pid进程。 ","date":"2021-05-07","objectID":"/different-from-ctrl-c-and-kill/:2:0","tags":["bash","signal","linux"],"title":"Ctrl+C与Kill杀死进程的区别","uri":"/different-from-ctrl-c-and-kill/"},{"categories":["program"],"content":"验证 程序1: package main import ( \"time\" \"os/exec\" ) func main(){ cmd := exec.Command(\"sleep\", \"100000\") cmd.Start() time.Sleep(time.Second * 99999) return } 上面的程序启动子进程运行sleep命令，然后睡眠。 测试结果： 用 kill -9、-2、-15 分别杀死主进程，sleep子进程存活。 用 \u003cCtrl+C\u003e、\u003cCtrl+\\\u003e分别杀死主进程，sleep子进程被杀。 程序2 package main import( \"time\" \"os/exec\" \"syscall\" ) func main(){ cmd := exec.Command(\"sleep\", \"100000\") // 将子进程放入新的进程组 cmd.SysProcAttr = \u0026syscall.SysProcAttr{Setpgid: true, Pgid: 0} cmd.Start() time.Sleep(time.Second * 99999) return } 上面的程序同程序1一样，区别是给子进程设置了单独的进程组（此时子进程就不在前台进程组中了）。 测试结果： 用 kill -9、-2、-15 分别杀死主进程，sleep子进程存活。 用 \u003cCtrl+C\u003e、\u003cCtrl+\\\u003e分别杀死主进程，sleep子进程存活！ ","date":"2021-05-07","objectID":"/different-from-ctrl-c-and-kill/:3:0","tags":["bash","signal","linux"],"title":"Ctrl+C与Kill杀死进程的区别","uri":"/different-from-ctrl-c-and-kill/"},{"categories":["program"],"content":"Go语言的函数参数传递，只有值传递，没有引用传递。Slice、Map 只是胖指针，在传参时同样是值传递。 除了函数传参，range Slice、range Map 也是按值拷贝，并不能取得容器里内容的引用。 Go里面有没有引用的概念呢？我的答案是有，而且只有一种情况体现了引用的概念：闭包变量按引用捕获。 分析下面代码：在线运行 或 playground package main import ( \"fmt\" ) func gen() (func() int, func() int) { a := 0 return func() int { a++ return a }, func() int { a++ return a } } func main() { f1, f2 := gen() fmt.Println(f1()) // 1 fmt.Println(f2()) // 2 } 闭包函数f1和f2都捕获了变量a，f1运行后影响了f2的结果，说明两个闭包函数都是捕获的a的引用。 实现上来讲，应该是函数值f1和f2都指向同一个闭包环境，因次f1对a的修改对f2也是可见的。 从结果上来看，两个闭包函数都有对同一个闭包环境里变量a的引用。 ","date":"2021-04-13","objectID":"/reference-variable-in-go/:0:0","tags":["go"],"title":"Go中的引用变量","uri":"/reference-variable-in-go/"},{"categories":["program"],"content":"记录下日常搬砖过程中的踩坑和学到的骚操作，随缘更新。 ","date":"2021-04-01","objectID":"/crud-boy/:0:0","tags":["crud","mysql"],"title":"crud boy","uri":"/crud-boy/"},{"categories":["program"],"content":"MySQL mysql中字符串类型索引查询时必须加引号，不然不会使用索引。原因是不支持函数索引，不加引号会使用了cast函数做隐式类型转换。(这里一般是int到string的cast 有时候写子查询嵌套非常多，可以使用with as优化可读性，装逼点这玩意叫公用表表达式common table expression,CTE with t1 as (select * from xxx) select * from t1; -- 必须紧跟着就使用,不用就销毁了 ","date":"2021-04-01","objectID":"/crud-boy/:1:0","tags":["crud","mysql"],"title":"crud boy","uri":"/crud-boy/"},{"categories":["program"],"content":"On Conflict 遇到的场景是去优化有大量的数据需要upsert的场景：数据不存在就插入，数据存在就更新。接手时的实现是每次都做两次网络io，先判断是否存在，然后做更新操作。为了节省大量的io时间，我开始寻求更好的解决方案。 刚开始的思路是找类似redis pipline的方式：构造一个pipline，往里面赛语句，然后exec，才会发生网络io，redis服务器会按顺序执行所有语句。这和在mysql里用拼接多条语句很类似，发现只能实现批量插入，因为upsert还有一个判断逻辑。 最终开始求助我司内部大佬：得出的结论是使用Conflict. https://gorm.io/docs/create.html#Upsert-On-Conflict -- MERGE INTO \"users\" USING *** WHEN NOT MATCHED THEN INSERT *** WHEN MATCHED THEN UPDATE SET \"name\"=\"excluded\".\"name\"; SQL \u003e Server -- INSERT INTO \"users\" *** ON CONFLICT (\"id\") DO UPDATE SET \"name\"=\"excluded\".\"name\", \"age\"=\"excluded\".\"age\"; PostgreSQL INSERT INTO `users` *** ON DUPLICATE KEY UPDATE `name`=VALUES(name),`age=VALUES(age); 原理是利用唯一键的冲突，在发生冲突时做更新操作。 利用冲突做大批量upsert操作 拼sql,尝试一次插入多列，定义冲突时更新的字段 表中必须存在唯一键(primary key 或 unique key)才能使用 INSERT INTO `users` (id, name) VALUES (1, \"jinzhu1\"), (2, \"jinzhu2\") ON DUPLICATE KEY UPDATE `name` = VALUES(name) 真・金柱大佬亲传( ","date":"2021-04-01","objectID":"/crud-boy/:1:1","tags":["crud","mysql"],"title":"crud boy","uri":"/crud-boy/"},{"categories":["program"],"content":"ES es创建mapping踩坑,text会把索引字段分词，搜索用match而不能用term，keyword不会进行分词 ","date":"2021-04-01","objectID":"/crud-boy/:2:0","tags":["crud","mysql"],"title":"crud boy","uri":"/crud-boy/"},{"categories":["program"],"content":"TotalHits != Hits es查询结果，searchResult.TotalHits()与len(searchResult.Hits.Hits)不一致，原因 下面的代码panic了，以为TotalHits \u003e 0就肯定Hits里有数据，结果数组长度是0，访问越界。 TotalHits是本次查询命中了多少记录，Hits里是实际返回的数据，由于分片的查询队列满了，所以没有查询到任何数据。 searchResult.Shards.Failures里有报错信息： rejected execution of org.elasticsearch.transport.TcpTransport$RequestHandler@xxx on EsThreadPoolExecutor [ search, queue capacity = 1000, org.elasticsearch.common.util.concurrent.EsThreadPoolExecutor@xxx [ Running, pool size = 13, active threads = 13, queued tasks = 1000, completed tasks = 919466345 ] ] ","date":"2021-04-01","objectID":"/crud-boy/:2:1","tags":["crud","mysql"],"title":"crud boy","uri":"/crud-boy/"},{"categories":["program"],"content":"Hive hive里也可以使用with as，注意区分和临时表的区别，临时表储存在磁盘的临时区中，只有数据库连接断开，或者drop掉才会消失 ","date":"2021-04-01","objectID":"/crud-boy/:3:0","tags":["crud","mysql"],"title":"crud boy","uri":"/crud-boy/"},{"categories":["program"],"content":"创建变量 在mysql创建和使用变量可以这样： set @id = 1; select * from xxx where id = @id; 在hive里可以这样： set date = 'xxx'; select * from xxx where date = ${hiveconf:date} ","date":"2021-04-01","objectID":"/crud-boy/:3:1","tags":["crud","mysql"],"title":"crud boy","uri":"/crud-boy/"},{"categories":["default"],"content":"RSA 算法原理 ","date":"2021-01-31","objectID":"/rsa/:0:0","tags":["RSA"],"title":"RSA算法原理","uri":"/rsa/"},{"categories":["default"],"content":"数论知识 质数 ​ 大于1的自然数中，只能被1和它本身的数整除，如 2、3、5、7 互质关系： ​ 如果两个正整数，除了1以外，没有其他公因子，我们就称这两个数是互质关系 1与任何数都互质 任意两个质数都互质 质数与小于它的每一个数，都构成互质关系。如5与1、2、3、4都构成互质关系 欧拉函数： ​ 任意给定正整数n，请问在小于等于n的正整数之中，有多少个与n构成互质关系？计算这个值的方法就叫做欧拉函数，以符号$\\phi(n)$表示 $\\phi(1)=1$ 如果n为质数，则 $\\phi(n)=n-1$ 如果n是两个互质的整数之积 $n=p_1\\times p_2$ 则 $\\phi(n)=\\phi(p_1)\\times \\phi(p_2)$ 欧拉定理： ​ 如果两个正整数a和n互质，则下面的公式成立： $$ a^{\\phi(n)} \\equiv 1 \\pmod n $$ 模反元素： ​ 如果两个正整数a和n互质，那么一定可以找到b，使得下面的公式成立： $$ ab\\equiv1\\pmod n $$ ​ 证明模反元素必然存在，把欧拉定理拆开，$a\\times a^{\\phi(n)-1} \\equiv 1 \\pmod n$, $a^{\\phi(n)-1} + kn$ 全都是模反元素 ","date":"2021-01-31","objectID":"/rsa/:1:0","tags":["RSA"],"title":"RSA算法原理","uri":"/rsa/"},{"categories":["default"],"content":"密钥生成步骤 随机选择两个不相等的质数p和q (越大越好) 计算p和q的乘积 $n=p\\times q$ 计算n的欧拉函数 $\\phi(n)=(p-1)(q-1)$ 随机选择一个整数e, $1\u003ce\u003c\\phi(n) 且 e与\\phi(n)互质$ 计算e对于$\\phi(n)$的模反元素d（知道e和$\\phi(n)$就等于知道了模反元素） 公布(n,e)为公钥、(n,d)为私钥 ","date":"2021-01-31","objectID":"/rsa/:2:0","tags":["RSA"],"title":"RSA算法原理","uri":"/rsa/"},{"categories":["default"],"content":"加密和解密 加密：公钥(n,e) 加密信息为m, m必须是整数，且m必须小于n 加密就是算出下面式子中的c: $$ m^e\\equiv c \\pmod n $$ 即密文 $c=m^e\\bmod n$ 解密： 私钥(n,d) 下面的等式一定成立: $$ c^d \\equiv m \\pmod n $$ 即明文 $m = c^d\\bmod n$ ","date":"2021-01-31","objectID":"/rsa/:3:0","tags":["RSA"],"title":"RSA算法原理","uri":"/rsa/"},{"categories":["default"],"content":"证明 $$ 为什么\\ \\ c^d \\equiv m \\pmod n \\ \\ \\ (1) \\\\ \\because m^e\\equiv c \\pmod n\\\\ \\therefore c = m^e-kn\\\\ c带入(1)得 \\ (m^e - kn)^d \\equiv m \\pmod n\\\\ 等同与\\ m^{ed}\\equiv m \\pmod n \\ \\ (2)\\\\ (比如(a+b)^2 = a^2 + 2ab + b2，只有a得最高项不带b) \\\\ \\because ed \\equiv 1 \\pmod{\\phi(n)}\\\\ \\therefore ed = h\\phi(n) +1 \\\\ 将ed带入(2)得 \\ m^{h\\phi(n)+1} \\equiv m \\pmod n \\ \\ \\ (3)\\\\ $$ 证明(1)就是证明（3）： 如果 m 和 n 互质 $$ 由欧拉定理得\\ m^{\\phi(n)}\\equiv 1 \\pmod n \\ \\\\ \\because m\\equiv m \\pmod n \\\\ 同余式相乘性质：若a≡b(mod\\ n)，c≡d(mod\\ n)，则ac≡bd(mod\\ n)。\\\\ (m^{\\phi(n)})^h\\times m \\equiv m \\times1^h \\pmod n \\\\ m^{h\\phi(n)+1} \\equiv m \\pmod n\\\\ 证明完成 $$ 如果 m 和 n 不互质 $$ \\because n = pq\\ (质因子)\\\\\\therefore 必然有\\ m = kp\\ 或\\ m=kq\\ (公因子只能是p或q)\\\\以\\ m=kp\\ 为例，kp与q必然互质,p为质数\\\\根据欧拉定理\\ (kp)^{q-1} \\equiv 1 \\pmod q \\ (自己多次乘上自己，再两边同时乘kp)\\\\进一步得到\\ [(kp)^{q-1}]^{h(p-1)} \\times kp \\equiv kp \\pmod q\\\\\\because ed = h\\phi(n) +1 \\\\化简\\ (kp)^{ed} \\equiv kp \\pmod q\\\\改写成\\ (kp)^{ed} = kp + tq\\\\这时t必然能被p整除,即\\ t=t'p\\ (因为(kp)^{ed}一定是p的整倍数)\\\\(kp)^{ed} = kp+t'pq\\\\\\because m=kp, n=pq\\\\\\therefore m^{ed}=m+t'n\\\\\\therefore m^{ed} \\equiv m \\pmod n\\\\证明完成 $$ ","date":"2021-01-31","objectID":"/rsa/:4:0","tags":["RSA"],"title":"RSA算法原理","uri":"/rsa/"},{"categories":["btc"],"content":"说明 推荐下我使用过的钱包，来给你提供建议。 ","date":"2021-01-05","objectID":"/btc-wallet/:1:0","tags":["btc"],"title":"比特币钱包推荐","uri":"/btc-wallet/"},{"categories":["btc"],"content":"Bitcoin Core 关键信息： 平台：Windows、Linux、MacOS 获取：https://bitcoin.org/zh_CN/download 源代码：https://github.com/bitcoin/bitcoin 全节点：是 核心钱包是全节点钱包，意味着你需要同步并存储所有区块数据。截止到2021年，区块数据约350GB，你至少需要保证500GB的存储空间以应对未来的数据增长。虽然全节点能够使区块链更安全，但不建议小白同步。因为如果你的全节点不能以服务的形式存在（通常需要一个公网IP），那么别人并不能主动和你建立链接，意义不大。提供全节点服务以保障区块链安全的使命请交给其他有情怀的专业人士。对于非专业人士（特指不是程序员）操作过于繁琐，不建议使用。 优点： 开源，意味着更安全，开发者不受任何人控制。 支持HD钱包: bip32「分层确定性(Hierarchical Deterministic)钱包」 有强大的命令行，不过需要大量学习 缺点： 新版本不支持生成1开头的地址（我平时不用的理由 要时常备份钱包文件（找零机制，外部导入私钥 这些都需要备份才行） 学习成本高 ","date":"2021-01-05","objectID":"/btc-wallet/:2:0","tags":["btc"],"title":"比特币钱包推荐","uri":"/btc-wallet/"},{"categories":["btc"],"content":"Electrum 关键信息： 平台：Windows、Linux、MacOS、Android（超难看） 获取：https://electrum.org 源代码：https://github.com/spesmilo/electrum 全节点：否 Electrum是一个轻节点钱包，你不用同步节点数据，而是由别人提供的服务器来帮你广播、查询交易。这些服务器不会存储你的私钥（也做不到）。你只需要连接一些服务器，就能够安全的完成交易。 优点： 使用方便 支持HD钱包，支持助记词（但不是bip39） 功能强大，兼容所有地址类型 缺点： 不支持导出bip39助记词，使用的是自定义版本，但可以导入bip39 只能使用桌面版本，移动端不支持（Android版本做的太垃圾了 除了上面，我觉得完美 ","date":"2021-01-05","objectID":"/btc-wallet/:3:0","tags":["btc"],"title":"比特币钱包推荐","uri":"/btc-wallet/"},{"categories":["btc"],"content":"Imtoken 关键信息： 平台：Android、iOS 获取：谷歌商店、App Store、https://token.im 部分源代码：https://github.com/consenlabs/token-core 全节点：否 Imtoken是一个主打移动端的轻节点钱包，并且支持多币种，能满足日常使用。 优点： HD钱包，支持导出bip39助记词 同时支持隔离见证地址和普通地址 对地址私钥控制方便，可以任意导出 缺点： 多币种钱包（我只需要btc 有官方的一些推送内容 夹私货，推销自己的平台币（无奈其他开源移动端功能不够，我目前使用这个 ","date":"2021-01-05","objectID":"/btc-wallet/:4:0","tags":["btc"],"title":"比特币钱包推荐","uri":"/btc-wallet/"},{"categories":["btc"],"content":"Bither 关键信息： 平台：Android、iOS、(桌面不推荐) 获取：谷歌商店、App Store、https://bither.net 源代码：https://github.com/bither 全节点：否(SVP) Bither是一个SVP钱包，需要同步节点数据，但无需存储全量数据。 优点： SVP钱包，同时支持冷热两种模式（第一次启动时断网，可以看到冷钱包选项） 完全开源，移动端最可信的钱包 钱包上生成的私钥随机性很强 缺点： 私钥导入不支持bip39，只能明文、加密后、或二维码 功能上不是很强（但我主力使用这个，imtoken上都是零头 只推荐有一定基础的玩家使用 ","date":"2021-01-05","objectID":"/btc-wallet/:5:0","tags":["btc"],"title":"比特币钱包推荐","uri":"/btc-wallet/"},{"categories":["btc"],"content":"其他 这个网站列出了可信度较高的钱包：https://bitcoin.org 桌面端基本用core钱包或Electrum就够了。 其他交易所推出的钱包我就不推荐了，夹私货太多。 ","date":"2021-01-05","objectID":"/btc-wallet/:6:0","tags":["btc"],"title":"比特币钱包推荐","uri":"/btc-wallet/"},{"categories":["btc"],"content":"推荐阅读 bip32、bip39、bip44 ","date":"2021-01-05","objectID":"/btc-wallet/:7:0","tags":["btc"],"title":"比特币钱包推荐","uri":"/btc-wallet/"},{"categories":["btc"],"content":"说明 为了给小白说清： 私钥 公钥 地址 钱包 交易所 咋获得比特币 简单粗暴，不讲原理，不讲原理，不讲原理 ","date":"2020-12-04","objectID":"/btc-start/:1:0","tags":["btc"],"title":"写给小白的比特币入门","uri":"/btc-start/"},{"categories":["btc"],"content":"定理(雾 说了不讲原理，就当这是定理 私钥 →公钥 → 地址 按箭头方向，知道前面的，就能计算出后面的，反过来不行 因此 私钥 最重要！ 他们长啥样： 私钥 - KwYC54hbaH6X5CrCfDK19oyJd2d1ivnSakbJxrW4ENbi2E2bJkbN 公钥 - 2f6e7sUQhP6z6mTMhh...(略)...16ME6Y18QSM 地址 - 16PXzomhwDovGRHaN6WGZXxk5BB1e78dn7 公钥很长不方便记忆，所以都用地址 ","date":"2020-12-04","objectID":"/btc-start/:2:0","tags":["btc"],"title":"写给小白的比特币入门","uri":"/btc-start/"},{"categories":["btc"],"content":"比特币是如何交易的 一个地址相当于一个账户，比特币通过地址互相转账 谁都可以向一个地址转账，但是要花地址里的钱，必须知道私钥 这就是为什么私钥最重要 比特币的区块链上记录的就是地址之间的转账记录 有转账记录，就能算出地址里有多少钱 ","date":"2020-12-04","objectID":"/btc-start/:3:0","tags":["btc"],"title":"写给小白的比特币入门","uri":"/btc-start/"},{"categories":["btc"],"content":"什么是钱包 一个地址就是一个账户，每个人名下都可能有很多账户 但是有一个地址就肯定有一个私钥 钱包就是帮你管理私钥的 钱包一般都有一下功能： 帮你计算你拥有多少钱（就是从区块链上计算地的地址里有多少比特币） 备份，如果你手机或电脑丢了，有备份就能找回你的私钥 交易，给别的地址转账 帮你自动生成私钥（也就是地址） 为什么每个人要有很多地址，而不是一个： 谁都可以从区块链上计算出某个地址的交易记录，如果你一直使用一个地址，你的隐私可能就暴漏了 一般是不能从地址推算出拥有这个地址的人是谁的，但如果你用的时间长了，比如从某个网址买东西用这个地址转账了，就能吧地址和你这个人联系起来，就知道你是谁了 由于地址可以凭空产生，谁都可以轻易生成(后面讲) 所以转账都用很多不同地址，不过这些事情钱包帮你做了，小白可能感觉不到 你可能担心钱包安全性，但他们大多是安全的，前提是知名钱包，官网上推荐的钱包一般都安全 https://bitcoin.org (也可以看我写的另一篇钱包推荐 ","date":"2020-12-04","objectID":"/btc-start/:4:0","tags":["btc"],"title":"写给小白的比特币入门","uri":"/btc-start/"},{"categories":["btc"],"content":"如何生成地址 谁都可以生成一个私钥，从而生成地址 私钥本质上是256个0和1组成的二进制串，然后编码成字符串 这256个0和1是随机的，所以你连续抛256次硬币，就能得到一个地址 这里随机非常重要，如果你只是凭喜好写出了256个0和1，那和你有相同习惯的人也可能写出来跟你一样的0和1,等于你的私钥被别人知道了。 没人会去抛硬币吧应该，大家都用软件生成私钥，这些软件都有自己的随机方法 这是一个安全的网站：www.bitaddress.org 根据你的鼠标位置取样，生成随机的私钥 冷钱包： 在离线的安全的环境下生成一个私钥，这个私钥只有你知道。 如果还能在离线环境签名交易，这个操作就是冷钱包的功能 只要你不联网，就没有泄漏的可能(流氓软件太多)，冷钱包就是一套离线解决方案 当然发布交易还是需要网络，可以把签名后的信息生成二维码，让联网设备读取、发布。 （用市面上常见的钱包已经很安全了 ","date":"2020-12-04","objectID":"/btc-start/:5:0","tags":["btc"],"title":"写给小白的比特币入门","uri":"/btc-start/"},{"categories":["btc"],"content":"交易所 如果你在币圈没有熟人，可以到交易所买比特币 交易所和股票那个交易所的职能差不多 你在上面买的比特币都被存在交易所里，可以提出来，但有手续费 交易所不会吧私钥给你，也就是说你只能通过交易所把比特币提出来，如果交易所跑路了，你币没了(概率极低) 知名交易所都很安全：我一般用火币 ，(火币打钱1KiritobkMPpaWBjTDHSoiP5icv8PEFNdR) 交易所注册邀请码：(使用邀请码双方都会获得奖励) 火币 - 邀请链接 - www.huobi.me/topic/invited/?invite_code=6a995 邀请码 - 6a995 ","date":"2020-12-04","objectID":"/btc-start/:6:0","tags":["btc"],"title":"写给小白的比特币入门","uri":"/btc-start/"},{"categories":["default"],"content":"这个博客是怎么来的 问就是白嫖github page，白嫖太爽了( 静态博客的生成器使用的是Hugo、主题使用的LoveIt、评论系统使用Disqus，LoveIt这个主题已经集成好了Disqus。 由于使用静态博客生成器，在每次改动后都需要重新运行一次生成命令，生成一大堆静态文件，再提交到gh-page，很麻烦。 为了让这个过程更加优雅，可以吧生成静态文件和部署这个过程放到CI里自动化完成。这里使用了github workflow的Action功能。 这样一来，只需要在本地编辑博客内容，然后push到github，就会自动触发CI流程，将生成的静态内容部署到XXX.github.io，也就是gh-page的仓库。 ","date":"2020-11-01","objectID":"/blog-with-gitpage-and-ci/:1:0","tags":["blog","github page","CI","hugo"],"title":"使用github page和CI(github action)创建博客","uri":"/blog-with-gitpage-and-ci/"},{"categories":["default"],"content":"准备工作 我一共新建了两个仓库： XXX.github.io， gh-page仓库,由CI负责提交 blog，存放博客文件 主要工作是都在blog这个仓库上进行，另一个仓库是自动化操作的。 blog存放了博客的主要骨架，还有一些脚本，方便在CI中做一些工作。 申请一个Github Application，如果你想使用Gitalk代替Disqus 申请一个Personal access tokens，CI流程中使用它来对XXX.github.io仓库进行提交，涉及到鉴权。 Github Application 和 Personal access tokens 都是需要保密的，不能直接写在配置文件里或这CI流程的脚本里。好在github的Workflow提供了在CI中访问仓库中配置的秘密环境变量的能力。 进入仓库-\u003eSettings-\u003eSecrets-\u003enew Secret，配置两个环境变量，如下： ","date":"2020-11-01","objectID":"/blog-with-gitpage-and-ci/:2:0","tags":["blog","github page","CI","hugo"],"title":"使用github page和CI(github action)创建博客","uri":"/blog-with-gitpage-and-ci/"},{"categories":["default"],"content":"杂项 使用了腾讯的对象存储来存图片，可有可无。 一个域名，可有可无。 阿里云的CDN，可有可无。 ","date":"2020-11-01","objectID":"/blog-with-gitpage-and-ci/:3:0","tags":["blog","github page","CI","hugo"],"title":"使用github page和CI(github action)创建博客","uri":"/blog-with-gitpage-and-ci/"},{"categories":["default"],"content":"blog搭建过程 首先看下我(本地)仓库的目录情况，github地址 . ├── .github │ └── workflows │ └── main.yml # github workflow 的action配置文件(CI脚本) ├── .gitmodules # git submodule 创建的，为了引入LoveIt ├── README.md ├── bin # 这个目录是脚本生成的，里面有hugo命令，不会被提交到仓库 ├── script │ └── get-hugo.sh # 本地 CI 都可以执行，用来获取hugo命令 └── site # 站点目录，存放hugo博客的骨架 ├── archetypes ├── config.toml ├── config.tomlconfig.toml ├── content # 存放博客内容的地方 ├── data ├── layouts ├── public # hugo生成的静态博客 ├── resources ├── static # static 目录在生产静态文件时，会被拷贝到public │ ├── .nojekyll # 两个文件最终都会出现在gh-page仓库的根目录 │ └── CNAME # 如过有域名需要这个 └── themes └── LoveIt # submodule方式引入，LoveIt主题 .gitignore忽略文件 bin/ public/ ","date":"2020-11-01","objectID":"/blog-with-gitpage-and-ci/:4:0","tags":["blog","github page","CI","hugo"],"title":"使用github page和CI(github action)创建博客","uri":"/blog-with-gitpage-and-ci/"},{"categories":["default"],"content":"骨架 初始化git仓库后，首先编写了一个脚本script/get-hugo.sh，这个脚本的功能是自动根据系统类型下载hugo,并解压到脚本所在位置的上级目录下的bin文件夹。脚本只支持mac或linux系统，CI也会用到这个脚本，windows用户可以手动安装。 # 此脚本安装hugo到脚本所在位置的../bin目录 CURDIR=$(cd $(dirname $0); pwd) cd $CURDIR echo \"执行目录 `pwd`\" # 判断环境是mac还是linux,决定hugo版本 if [ $(uname -s) = 'Darwin' ];then echo '当前环境为Darwin' HUGOURL='https://github.com/gohugoio/hugo/releases/download/v0.77.0/hugo_extended_0.77.0_macOS-64bit.tar.gz' else echo '当前环境为Linux' HUGOURL='https://github.com/gohugoio/hugo/releases/download/v0.77.0/hugo_extended_0.77.0_Linux-64bit.tar.gz' fi echo \"hugo 获取地址:$HUGOURL\" echo '开始下载' curl -sSL -o hugo.tar.gz $HUGOURL if [ $? -ne 0 ];then echo '下载失败' exit 1 fi # 解压文件 BINDIR=\"$CURDIR/../bin\" if [ ! -d \"$BINDIR\" ];then mkdir $CURDIR/../bin fi echo \"解压到 $BINDIR\" tar -xzf ./hugo.tar.gz -C $CURDIR/../bin rm ./hugo.tar.gz # 验证下解压安装成功 echo 'success' $BINDIR/hugo version 执行sh scrpit/get-hugo.sh，就可以使用hugo了，执行bin/hugo vesion打印hugo版本。 然后创建站点，执行： bin/hugo new site . 生成site目录。 tree ./site . ├── archetypes ├── config.toml # 配置文件 ├── content ├── data ├── layouts ├── static └── themes # 主题文件夹 下一步拉取主题，我使用的是LoveIt。 # 在site目录执行 git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt # 注意有了submodules后，再从别的地方拉取仓库记得 # git submodule init # git submodule update 参考LoveIt的文档，配置好config.toml文件 我的配置中需要说明的只有下面几行： # 评论系统设置 [params.page.comment] enable = true # Disqus 评论系统设置 [params.page.comment.disqus] enable = true # Disqus 的 shortname shortname = \"kirito-blog\" 这是Disqus的配置，很简单。 博客编写的部分请直接去看hugo的文档 博客有内容后，本地看效果使用下面命令： cd site # 本地预览（不会展示gitalk） ../bin/hugo server # 本地预览，但是使用生产环境(会展示gitalk，但不建议) ../bin/hugo server -e production hugo生成静态站点的方式是直接在site目录执行： ../bin/hugo 完成后将生成public文件夹，注意不要提交到仓库中。 下面把生成的静态站点，提交到gh-page仓库，就能展示博客了，当然也可以使用其他静态托管服务。 ","date":"2020-11-01","objectID":"/blog-with-gitpage-and-ci/:4:1","tags":["blog","github page","CI","hugo"],"title":"使用github page和CI(github action)创建博客","uri":"/blog-with-gitpage-and-ci/"},{"categories":["default"],"content":"配置CI部署 回到仓库根目录，创建Action文件： mkdir -p .github/workflows touch .github/workflows/main.yml CI配置参考文档 我的CI配置中需要说明的几行： - name:init blogrun:|git submodule init git submodule update sh script/get-hugo.sh cd site ../bin/hugo# 部署blog- name:deploy blogenv:GITHUB_REPO:github.com/zshorz/zshorz.github.iorun:|cd site/public git init \u0026\u0026 git add . git config user.name \"xxxx\" git config user.email \"xxxx@mail.com\" git commit -m \"GitHub Actions Auto Builder at $(date +'%Y-%m-%d %H:%M:%S')\" git push --force --quiet \"https://${{ secrets.ACCESS_TOKEN }}@$GITHUB_REPO\" master:master 还记得在仓库中配置了secret环境变量，而在CI中访问那些环境变量的方法就是${{secrets.NAME}} CI的脚本有两部分，首先初始化blog，然后将生成的静态网站，部署到xxx.github.io 我把脚本抽出来单独注释（注意这是在CI的docker自动执行的，不是本地环境） 第一部分 # 初始化submodule，拉取LoveIt主题 git submodule init git submodule update # 执行脚本安装hugo环境 sh script/get-hugo.sh cd site # 生成站点，输出到public目录 ../bin/hugo 第二部分 # 进入生成的静态站点目录 cd site/public # 初始化为git仓库 git init \u0026\u0026 git add . git config user.name \"xxxx\" git config user.email \"xxxx@qq.com\" # 本地提交 git commit -m \"GitHub Actions Auto Builder at $(date +'%Y-%m-%d %H:%M:%S')\" # 强制推送到远端仓库 git push --force --quiet \"https://${{ secrets.ACCESS_TOKEN }}@$GITHUB_REPO\" master:master 到此CI就配置好了。 ","date":"2020-11-01","objectID":"/blog-with-gitpage-and-ci/:4:2","tags":["blog","github page","CI","hugo"],"title":"使用github page和CI(github action)创建博客","uri":"/blog-with-gitpage-and-ci/"},{"categories":["default"],"content":"push仓库 直接将你的仓库push到远端，会自动触发CI，你可以在这里查看执行情况 待CI执行成功后，打开在浏览器中输入xxx.github.io查看博客站点，就是你现在看到的样子了。 ","date":"2020-11-01","objectID":"/blog-with-gitpage-and-ci/:4:3","tags":["blog","github page","CI","hugo"],"title":"使用github page和CI(github action)创建博客","uri":"/blog-with-gitpage-and-ci/"},{"categories":["default"],"content":"可选项目 ","date":"2020-11-01","objectID":"/blog-with-gitpage-and-ci/:5:0","tags":["blog","github page","CI","hugo"],"title":"使用github page和CI(github action)创建博客","uri":"/blog-with-gitpage-and-ci/"},{"categories":["default"],"content":"配置域名 比如域名是kirito41dd.cn，你想当你访问www.kirito41dd.cn的时候，就是你的博客站点。 添加文件site/static/CNAME，在里面写上www.kirito41dd.cn，push让CI再次构建 然后打开你的域名控制台，为www.kirito41dd.cn添加一个CNAME记录，记录值为xxx.github.io 稍后浏览器输入域名网址，你就又看到这个页面了 ","date":"2020-11-01","objectID":"/blog-with-gitpage-and-ci/:5:1","tags":["blog","github page","CI","hugo"],"title":"使用github page和CI(github action)创建博客","uri":"/blog-with-gitpage-and-ci/"},{"categories":["default"],"content":"CDN加速 我用的阿里云的cdn，不知道为啥还没收我钱( ","date":"2020-11-01","objectID":"/blog-with-gitpage-and-ci/:5:2","tags":["blog","github page","CI","hugo"],"title":"使用github page和CI(github action)创建博客","uri":"/blog-with-gitpage-and-ci/"},{"categories":["default"],"content":"最后 git push 享受下 CI 部署的丝滑( ","date":"2020-11-01","objectID":"/blog-with-gitpage-and-ci/:6:0","tags":["blog","github page","CI","hugo"],"title":"使用github page和CI(github action)创建博客","uri":"/blog-with-gitpage-and-ci/"},{"categories":null,"content":" 开个博客记录下自己的东西，随便写写 浏览本站部分内容（如评论）可能需要梯子 disqus免费版有广告，建议使用屏蔽插件 kirito，原名xxx，xx xx 人 会写cpp、go、易语言(忘光) 在学rust(第n次入门中，猜数字游戏的king) 现字节跳动后端搬砖工程师一枚（双身 ","date":"2020-11-01","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":" .friend.url { text-decoration: none !important; color: black; } .friend.logo { width: 56px !important; height: 56px !important; border-radius: 50%; border: 1px solid #ddd; padding: 2px; margin-top: 14px !important; margin-left: 14px !important; background-color: #fff; } .friend.block.whole { height: 92px; margin-top: 8px; margin-left: 4px; width: 31%; min-width: 250px; display: inline-flex !important; border-radius: 5px; background: rgba(14, 220, 220, 0.15); } .friend.block.left { width: 92px; min-width: 92px; float: left; } .friend.block.left { margin-right: 2px; } .friend.block.right { margin-top: 18px; margin-right: 18px; } .friend.name { overflow: hidden; font-weight: bolder; word-wrap:break-word; word-break: break-all; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 1; -webkit-box-orient: vertical; } .friend.info { margin-top: 3px; overflow: hidden; word-wrap:break-word; word-break: break-all; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; line-height: normal; font-size: 0.8rem; color: #7a7a7a; } Tony5t4rk ACM/ICPC亚决银牌大佬 orz 君吟 前端学习之道 kirito 我贴我自己 雨临Lewis的博客 不想当写手的码农不是好咸鱼_(xз」∠)_ Sanzo 白马会所一哥 Mug-9 Stay Hungry, Stay Foolish 交换友链🉑️评论如下信息 name=\"kirito\" url=\"https://www.kirito41dd.cn\" logo=\"https://blog-1256556944.file.myqcloud.com/kirito.jpg\" word=\"被带歪也不能怨我\" ","date":"2020-11-01","objectID":"/friends/:0:0","tags":null,"title":"友链墙","uri":"/friends/"},{"categories":["default"],"content":"简单记录下自己的2020春招 2021届双非网络工程，拿过几个水奖，成绩中上。目前拿到了字节跳动的实习offer，其余的进度都很悲观。写这些之前都处于极度自闭状态，好在字节跳动已经尘埃落定，重新拾起精神。 因为只有字节跳动走完了所有流程，所以就主要记录下字节跳动的面试经历。由于没有考研打算，很早就用学长的内推码投了暑期实习生的一个后端岗位，但简历一直是评估中，后来学长说让我试试投其他岗位，又投了一个后端开发。在简历评估中的这段时间，我除了字节和阿里以外没有投其他简历，投这俩是因为有学长内推。我是没想到简历评估了两个月。。。感觉实在不行了，开始海投，这时候已经4月下旬了。。。 ","date":"2020-05-30","objectID":"/2020-spring-recruits/:0:0","tags":[],"title":"2020春招记录","uri":"/2020-spring-recruits/"},{"categories":["default"],"content":"字节 字节跳动的面试体验还是不错的： 4.23日 一面·技术面·1小时 问了问简历里写的项目相关 网络相关，tcp，udp, tcp拥塞控制 对http的了解，还问了http头里面的字段，cookie和session区别什么的 进程间通讯 死锁 最长连续子序列，最长子序列(代码题 普通的dp 当时没说清是否连续，俩都写了，就改改转移方程就行了) 链表找环(代码题 要求空间复杂度为1，就是不让记录访问过的状态，当时不知道咋写，后来问同学，双指针) 二叉查找树(平衡树，红黑树，我忘记是不是在这里问的了，记不清了) 聊天 可以问面试官一个问题（我问了下一面面啥，白问） 4.23日 二面·技术面·1小时 问简历项目 问我以后的职业规划，问我为啥不考研(本来就没有计划考研，又因为保研没我啥事，除非天上掉下来个研究生，我考虑考虑 雾) 大数加法(代码题 还是挺简单的) 问我下楼梯问题(题还没描述完我就知道是递推了，当时我们acm学长宣讲例题就是这种。。。我反手给面试官推荐了这种Fibonacci类的递推怎么用矩阵快速幂来恶心别人，哈哈，聊的挺high，也没让我再写代码了) 计算机，网络相关题，记不清了，这场聊的比较轻松，没记住（后来我ld说这场她旁听了） linux命令问了几个，inode，硬链软链什么的 非对称加密的了解，https、ssl握手机制(网络安全课上刚学完这部分，甚至我们反转课堂我就负责的rsa这部分，反手一个超级加倍，哈哈，欧拉定理，永远滴神) 让我聊聊比赛场景(引起了我对我们三人赛场上被中学生虐飞的悲惨回忆) 说支持云入职(我说后面没有了？他说有。。。让我白高兴) 可以问面试官一个问题（我又问了下一面面啥，白问） 4.28日 三面·技术交叉面·1小时 基础题忘记了（当时面完让我等通知，我以为凉了，也没心情记） 求二叉树深度(代码题，直接dfs找最深没再问了) 打印集合子集(代码题，回溯遍历) 排序算法了解啥(说了常用排序算法，问我快速排序时间复杂度，最坏情况呢？大概知道要问啥，说了随机选取哨兵，避开恶意数据) malloc的一些问题，他写代码我来看 malloc free new delete 区别 什么是内存泄漏，如何防止(举了几个例子，还回答了share_ptr 又问会有什么问题？ 循环引用 weak_ptr配合 ) 可以问面试官一个问题（问了点工作细节相关） 4.28日 四面·技术面·1小时 用c写个字符串拼接(三面完让我等通知以为凉了，面完一会四面面试官就给我打电话问我人去哪了，来房间面试) 设计一个多线程下的异步日志打印 linux c内存空间布局 linux线程从创建到运行，进程，线程，协程区别（协程看过腾讯的libco，还特意扯了点它是如何汇编切换上下文，以及hook系统调用的） 问项目细节(中途延申，聊了聊比特币，linux2.6新加入的timerfd、eventfd、signalfd如何如何方便，socks5握手协议) 聊天，也是技术相关，没记住 时间忘了 hr面 给我介绍部门相关 闲聊，学校，经历，为什么选这个专业 acm收获 缺点 优点 入职时间 一面二面是连着面，三面四面也是连着面，期间一面完等二面面试官的时候，接到了阿里的面试电话，说在面试推到隔天了。 四面结束我ld就微信联系我了，聊了聊，五一假期放假，等的可煎熬，假期结束就收到实习offer了。 字节说完了，说说自闭的 ","date":"2020-05-30","objectID":"/2020-spring-recruits/:1:0","tags":[],"title":"2020春招记录","uri":"/2020-spring-recruits/"},{"categories":["default"],"content":"其他 阿里电话面试挂了，基础题都答上来了，从比特币聊到分布式一致性，只知道比特币是工作量证明和hash，其他方面不了解。还问了我为啥简历偏c++却投了java岗，数据库隔离级别，当时对脏读幻读什么的有概念，但是问我怎么实现的，这里没准备，答不上来(问问b树啥的不就行了吗，没想到还会有这个，后来问同学说好多面经有，后悔没多看看)，一通电话给人整自闭了。 腾讯投了，也笔试了，后续没动静 百度投了，没动静 网易雷火，笔试了，没动静 EA,笔试了，没动静，后来给我打电话了，但是我已经接了字节的offer了，面试就拒了 美团，通知笔试 西山居，笔试了，没动静 途游，笔试了，没动静 快手京东，投了，没动静 可能都太晚了，极度自闭。。。 5.29日 奇虎360 一面·技术面·1小时 c/c++区别，类，多态，继承，重载，重写，隐藏，const，mutable 重要成员函数（构造，拷贝，移动，析构） c++11新特性，lambda（如何实现)，auto，右值，move，forward tcp握手，挥手(详细状态，如timewait），拥塞控制 osi七层协议，ip,icmp等，掩码与子网划分 进程状态，进程间通信，线程，协程，进程间通讯，各种锁（把APUE里的都答上） 字节序，IO多路复用，网络API（问linux的c函数，就是看有没有用过） shared_prt如何实现 acm比赛回忆（感觉就是凑时长） 聊很开心，真就互相练手呗 ","date":"2020-05-30","objectID":"/2020-spring-recruits/:2:0","tags":[],"title":"2020春招记录","uri":"/2020-spring-recruits/"},{"categories":["algorithm"],"content":"大一还是大二学线性代数的时候，感觉这玩意怎么这么无聊，这破矩阵能干啥？老师讲课跟催眠一样。后来学习OpenGL的时候才感受到矩阵的魅力，原来3D世界的平移、旋转、缩放都可以用一个小小的四阶矩阵的运算来完成，AMAZING 啊！！！(比老师上课有意思多了) 矩阵快速幂也是打ACM期间学到的，思想上和整数的快速幂一样，操作替换成了矩阵运算而已。 没错，课堂上的时间都用来睡觉、刷手机了 ","date":"2019-03-25","objectID":"/matrix-fast-power/:0:0","tags":["algorithm","math"],"title":"矩阵快速幂","uri":"/matrix-fast-power/"},{"categories":["algorithm"],"content":"解决哪些问题 求解一些递推公式的第n项的时候，通过递推公式构造转移矩阵，并用矩阵快速幂可以快速得到第n项的值。特别对于n很大的时候不能循环迭代，可用矩阵快速幂解决。 比如斐波那契数列： $F_0=0,F_1=1,F_n=F_n-1+F_n-2,(n \\ge2,n \\in N^*)$ 0 1 1 2 3 5 8… 如果要求第n项，n比较小的话，可以直接循环迭代出来。 如果n比较大，第一亿个是多少，用循环就太慢了，矩阵快速幂更快更适合。 根据矩阵乘法性质，构造转移矩阵 $$ \\begin{bmatrix} 1\u00261\\\\ 1\u00260\\end{bmatrix} \\times\\begin{bmatrix} F_{n-1}\\\\ F_{n-2} \\end{bmatrix} = \\begin{bmatrix} F_{n}\\\\ F_{n-1} \\end{bmatrix} $$ 那么 $$ \\begin{bmatrix} 1\u00261\\\\ 1\u00260\\end{bmatrix}^{n-1} \\times\\begin{bmatrix} F_{1}\\\\ F_{0} \\end{bmatrix} = \\begin{bmatrix} F_{n}\\\\ F_{n-1} \\end{bmatrix} $$ 这样问题就变成了求转移矩阵的幂。这个转移矩阵一定构造成方阵。 ","date":"2019-03-25","objectID":"/matrix-fast-power/:1:0","tags":["algorithm","math"],"title":"矩阵快速幂","uri":"/matrix-fast-power/"},{"categories":["algorithm"],"content":"矩阵快速幂 #include \u003cstdio.h\u003e#include \u003cstring.h\u003e#define MATRIX_SIZE 2 const int mod = 1e9+7; struct Matrix //构造一个方阵 { int data[MATRIX_SIZE][MATRIX_SIZE]; Matrix(){ memset(data, 0, sizeof(data)); for(int i=0; i\u003cMATRIX_SIZE; i++){ data[i][i]=1; // 初始化为单位矩阵 } } Matrix operator + (Matrix o)const{ //(a+b)%mod Matrix re; for(int i=0; i\u003cMATRIX_SIZE; i++){ for(int j=0; j\u003cMATRIX_SIZE; j++){ re.data[i][j] = (this-\u003edata[i][j] + o.data[i][j]) % mod; } } return re; } Matrix operator * (Matrix o)const{ //(a*b)%mod Matrix re; for(int i=0; i\u003cMATRIX_SIZE; i++){ for(int j=0; j\u003cMATRIX_SIZE; j++){ re.data[i][j] = 0; for(int k=0; k\u003cMATRIX_SIZE; k++) re.data[i][j] = (re.data[i][j] + ((this-\u003edata[i][k] * o.data[k][j]) % mod)) % mod; } } return re; } Matrix operator ^ (int n)const{ // (a^n)%mod Matrix re,base; base = *this; while(n){ if(n\u00261) re = re * base; n\u003e\u003e=1; base = base * base; } return re; } Matrix Psum(int n)const{ //(a+a^2+a^3.....+a^n)%mod Matrix a,ans,pre; int m; a = *this; if(n==1) return a; m = n/2; pre = a.Psum(m); // a^[1,n/2] 相加 ans = pre + (pre * (a^m)); // ans = [1,n/2] + a^(n/2)*[1,n/2] if(n\u00261) ans = ans + (a^n); //n为奇数时候a^n会漏掉，补上 return ans; } void out(){ for(int i=0; i\u003cMATRIX_SIZE; i++){ for(int j=0; j\u003cMATRIX_SIZE; j++){ printf(\"%d \",data[i][j]); }printf(\"\\n\"); } } }; int main(){ Matrix ma,swa; ma.data[0][0]=1; ma.data[0][1]=1; ma.data[1][0]=1; ma.data[1][1]=0; int n; ma.out(); while(scanf(\"%d\" , \u0026n) , n\u003e=1){ swa = ma^(n-1); //swa.out(); printf(\"is %d\\n\", swa.data[0][0]*1 + swa.data[0][1]*0 ); } return 0; } ","date":"2019-03-25","objectID":"/matrix-fast-power/:2:0","tags":["algorithm","math"],"title":"矩阵快速幂","uri":"/matrix-fast-power/"},{"categories":["algorithm"],"content":"构造矩阵例题 hdu6470 Farmer John有n头奶牛. 某天奶牛想要数一数有多少头奶牛,以一种特殊的方式: 第一头奶牛为1号,第二头奶牛为2号,第三头奶牛之后,假如当前奶牛是第n头,那么他的编号就是2倍的第n-2头奶牛的编号加上第n-1头奶牛的编号再加上自己当前的n的三次方为自己的编号. 现在Farmer John想知道,第n头奶牛的编号是多少,估计答案会很大,你只要输出答案对于123456789取模. 根据题意可以得到递推公式： $$ F_n=\\begin{cases} 1\u0026 n=1\\\\ 2\u0026 n=2\\\\ 2\\times F_{n-2} + F_{n-1}+n^3\u0026 n\\ge3 \\end{cases} $$ 由于$n^3$的存在，这个递推公式并不是线性的，所以要想办法把$n^3$展开： $$ n^3=(n-1+1)^3=C^0_3(n-1)^3+C^1_3(n-1)^2+C^2_3(n-1)^1+C^3_3(n-1)^0 \\\\=1\\times(n-1)^3+3\\times (n-1)^2+3\\times(n-1)^1+1\\times(n-1)^0 $$ 那么转移矩阵$M$为： $$ \\begin{bmatrix} 0\u00261\u00260\u00260\u00260\u00260\\\\ 2\u00261\u0026C_3^0\u0026C_3^1\u0026C_3^2\u0026C_3^3\\\\ 0\u00260\u0026C_3^0\u0026C_3^1\u0026C_3^2\u0026C_3^3\\\\ 0\u00260\u00260\u0026C_2^0\u0026C_2^1\u0026C_2^2\\\\ 0\u00260\u00260\u00260\u0026C_1^0 \u0026C_1^1\\\\ 0\u00260\u00260\u00260\u00260\u00261 \\end{bmatrix}\\times \\begin{bmatrix} F_{n-2}\\\\F_{n-1}\\\\(n-1)^3\\\\(n-1)^2\\\\(n-1)^1\\\\(n-1)^0 \\end{bmatrix} = \\begin{bmatrix} F_{n-1}\\\\F_{n}\\\\(n)^3\\\\(n)^2\\\\(n)^1\\\\(n)^0 \\end{bmatrix} $$ 取$n=3$： $$ \\begin{bmatrix} F_{n-2}\\\\F_{n-1}\\\\(n-1)^3\\\\(n-1)^2\\\\(n-1)^1\\\\(n-1)^0 \\end{bmatrix}=\\begin{bmatrix} F_{1}\\\\F_{2 }\\\\2^3\\\\ 2^2\\\\ 2^1\\\\ 2^0 \\end{bmatrix} $$ 所以： $$ F_n = M^{n-2 } \\times \\begin{bmatrix} F_{1}\\\\F_{2 }\\\\2^3\\\\ 2^2\\\\ 2^1\\\\ 2^0 \\end{bmatrix},n \\ge 2 $$ AC代码： #include \u003cstdio.h\u003e#include \u003cstring.h\u003e#include \u003ciostream\u003e#define MATRIX_SIZE 6 using namespace std; const int mod = 123456789; struct Matrix //构造一个方阵 { long long data[MATRIX_SIZE][MATRIX_SIZE]; Matrix(){ memset(data, 0, sizeof(data)); for(int i=0; i\u003cMATRIX_SIZE; i++){ data[i][i]=1; // 初始化为单位矩阵 } } Matrix operator * (Matrix o)const{ //(a*b)%mod Matrix re; for(int i=0; i\u003cMATRIX_SIZE; i++){ for(int j=0; j\u003cMATRIX_SIZE; j++){ re.data[i][j] = 0; for(int k=0; k\u003cMATRIX_SIZE; k++) re.data[i][j] = (re.data[i][j] + ((this-\u003edata[i][k] * o.data[k][j]) % mod)) % mod; } } return re; } Matrix operator ^ (long long n)const{ // (a^n)%mod Matrix re,base; base = *this; while(n){ if(n\u00261) re = re * base; n\u003e\u003e=1; base = base * base; } return re; } }; Matrix ma,swa; int main(){ int mm[6][6]={ {0,1,0,0,0,0}, {2,1,1,3,3,1}, {0,0,1,3,3,1}, {0,0,0,1,2,1}, {0,0,0,0,1,1}, {0,0,0,0,0,1} }; for(int i=0;i\u003c6;i++) for(int j=0;j\u003c6;j++) ma.data[i][j]=mm[i][j]; long long t,a; cin\u003e\u003et; while(t--){ cin\u003e\u003ea; swa = ma^(a-2); long long ac; ac= swa.data[1][0]*1; ac+=swa.data[1][1]*2; ac+=swa.data[1][2]*8; ac+=swa.data[1][3]*4; ac+=swa.data[1][4]*2; ac+=swa.data[1][5]*1; cout\u003c\u003cac%mod\u003c\u003cendl; } return 0; } ","date":"2019-03-25","objectID":"/matrix-fast-power/:3:0","tags":["algorithm","math"],"title":"矩阵快速幂","uri":"/matrix-fast-power/"},{"categories":["algorithm"],"content":"附赠！ 这个方程怎么用矩阵计算，可以试着练练手。 $$ f(x)= \\begin{cases} 1\u0026 x=0 \\\\ 1\u0026 x=1 \\\\ 9\\times f(x-1) + 9\\times f(x-2) + 6\u0026 x1 \\end{cases} $$ ","date":"2019-03-25","objectID":"/matrix-fast-power/:4:0","tags":["algorithm","math"],"title":"矩阵快速幂","uri":"/matrix-fast-power/"},{"categories":["program"],"content":"此文为个人笔记，大学时候的总结难免有错，不代表本人目前水平[手动doge] (by 2021) 本来这总结已经被我从网络上删除了，看在可能是本文迄今为止唯一读者老田园的份上重新发布，方便老人查阅。 MySQL操作手册 MySQL命令不区分大小写 空格符复制有时会出现格式错误，删掉空格再自己打一个 `(反引号)是转义字符，当你自定义名字和关键字冲突可以 `name` 括起来 ","date":"2019-03-19","objectID":"/mysql-operation-manual/:0:0","tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/"},{"categories":["program"],"content":"1 MySQL安装 ","date":"2019-03-19","objectID":"/mysql-operation-manual/:1:0","tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/"},{"categories":["program"],"content":"1.1 linux安装 Ubuntu下用apt，Centos用yum sudo apt‐get install mysql‐server sudo apt‐get install mysql‐client sudo apt‐get install libmysqlclient‐dev 配置文件目录 /etc/mysql/mysql.conf.d/mysqld.cnf ","date":"2019-03-19","objectID":"/mysql-operation-manual/:1:1","tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/"},{"categories":["program"],"content":"1.2 密码修改 kirito@host:~$ mysqladmin ‐u用户名 ‐p旧密码 password 新密码 kirito@host:~$ mysqladmin ‐uroot ‐p111111 password 123456 如果修改不了，sudo mysql -uroot，进入数据库 mysql\u003e update mysql.user set authentication_string=PASSWORD('newPwd'), plugin='mysql_native_password' where user='root'; mysql\u003e flush privileges; ","date":"2019-03-19","objectID":"/mysql-operation-manual/:1:2","tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/"},{"categories":["program"],"content":"1.3 MySQL登陆 kirito@host:~$ mysql ‐h数据库服务器安装的主机 ‐P数据库端口 ‐u账户 ‐p密码 kirito@host:~$ mysql ‐h127.0.0.1 ‐P3306 ‐uroot ‐p123456 ","date":"2019-03-19","objectID":"/mysql-operation-manual/:1:3","tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/"},{"categories":["program"],"content":"2 数据库基础 ","date":"2019-03-19","objectID":"/mysql-operation-manual/:2:0","tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/"},{"categories":["program"],"content":"2.1 库操作 # 查看数据库服务器存在哪些数据库 SHOW DATABASES; # 使用指定的数据库 USE database_name; # 查看指定的数据库中有哪些数据表 SHOW TABLES; # 创建指定名称的数据库 CREATE DATABASE database_name; # 删除数据库 DROP DATABASE database_name; ","date":"2019-03-19","objectID":"/mysql-operation-manual/:2:1","tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/"},{"categories":["program"],"content":"2.2 表操作 创建一个表 CREATE TABLE 表名( 列名1 列的类型 [属性约束], 列名2 列的类型 [属性约束], .... 列名N 列的类型 [属性约束] ); # 如果名字和命令名冲突，此时使用反引号(`)括起来 查看表结构 DESC name; 查看表的详细定义 SHOW CREATE TABLE name; 删除表 DROP TABLE name; 往表中插入一行数据 # 为所有表单项赋值，插入 CREATE TABLE test(id INT,_date DATE); INSERT INTO test VALUES(1,'2008‐12‐2'); # 选择赋值 CREATE TABLE test4(id INT,_datetime DATETIME); INSERT INTO test4(id, _datetime) VALUES(1, '1990‐02‐10'); /* DATE可以通过CURDATE()来赋值当前的日期， TIME可以通过CURTIME()来赋值当前的时间， DATETIME与TIMESTAMP都可以通过函数NOW()来赋值当前的时间日期。 */ 修改已有表字符集 ALTER TABLE 表名 CONVERT TO CHARACTER SET utf8; # or gbk # 若想仅修改某一列的字符集 使用列操作添加约束属性 CHARACTER SET name 修改表名 ALTER TABLE 表名 RENAME TO 新表名; ","date":"2019-03-19","objectID":"/mysql-operation-manual/:2:2","tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/"},{"categories":["program"],"content":"2.3 列操作 列（字段） 给表添加列 ALTER TABLE 表名 ADD 列名 列的类型 [属性约束]; ALTER TABLE 表名 ADD 列名 列的类型 [属性约束] FIRST; /*放在第一位*/ ALTER TABLE 表名 ADD 列名 列的类型 AFTER 列名; /*放在某字段后面*/ 修改已有列数据类型，约束 ALTER TABLE 表名 MODIFY 列名 列的类型 [属性约束]; 删除列 ALTER TABLE 表名 DROP 列名; 修改列名，和类型 ALTER TABLE 表名 CHANGE 列名 新_列名 列的类型 [属性约束]; # 列名不一定要新的， ","date":"2019-03-19","objectID":"/mysql-operation-manual/:2:3","tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/"},{"categories":["program"],"content":"2.4 列.属性约束 MySOL关键字 含义 NULL 数据列可包含NULL值 ，默认不填即为NULL。 NOT NULL 数据列不允许包含NULL值 ，在操作数据库时如果输入该字段的数据为NULL ，就会报错。 DEFAULT 默认值，DATE，TIME不能使用函数默认值。DATETIME与TIMESTAMP可以使用NOW()函数默认值。 PRIMARY KEY 主键 ，您可以使用多列来定义主键，列间以逗号分隔。主键不管有没NOT NULL修饰，都不能为NULL，主键值不能重复。主键可以由多个字段组成。例如：PRIMARY KEY (id, name) AUTO_INCREMENT 定义列为自增的属性，数值会自动加1, 默认初始值为0。一个表只能有一个自增字段，并且该字段必须是主键或者索引。 UNSIGNED 无符号 CHARACTER SET name 指定一个字符集 2.4.1 列默认值 DEFAULT 在未指定默认值的情况下，系统提供default null这样的约束。只有列中提供了default，在插入时，才可以省略。 # 设置/删除 DEFAULT ALTER TABLE 表名 ALTER 列名 SET DEFAULT 默认值; ALTER TABLE 表名 ALTER 列名 DROP DEFAULT; 2.4.2 非空约束 NOT NULL NULL存在的意义在于标志。 NULL类型特征:所有的类型的值都可以是null，包括int、float等数据类型,空字符串是不等于null，0也不等于null。 非空约束用于确保当前列的值不为空值，非空约束只能出现在表对象的列上。 # 已有，设置 ALTER TABLE 表名 MODIFY 列名 INT NOT NULL DEFAULT 0; # 创建表 mysql\u003e CREATE TABLE stu2 ( id INT DEFAULT NULL, sex CHAR(2) NOT NULL ) # 效果 不能默认初始化 mysql\u003e INSERT INTO stu2 VALUES(); ERROR 1364 (HY000): Field 'sex' doesn't have a default value 2.4.3 唯一约束 UNIQUE KEY 唯一约束是指定table的列或列组合不能重复，保证数据的唯一性。虽然唯一约束不允许出现重复的值，但是可以有多个null，同一个表可以有多个唯一约束，多个列组合的约束。 在创建唯一约束的时候，如果不给唯一约束名称，就默认和列名相同。 MySQL会给唯一约束的列上默认创建一个唯一索引. mysql\u003e CREATE TABLE stu3(id INT UNIQUE, sex CHAR(2)); mysql\u003e CREATE TABLE stu3(id INT, sex CHAR(2), UNIQUE(id)); # 第二种写法 # 效果 插入重复值报错 mysql\u003e INSERT INTO stu3 VALUES(1,'f'); Query OK, 1 row affected (0.00 sec) mysql\u003e INSERT INTO stu3 VALUES(1,'f'); ERROR 1062 (23000): Duplicate entry '1' for key 'id' 2.4.4 主键约束 PRIMARY KEY 每个表最多只允许一个主键，建立主键约束可以在列级别创建，也可以在表级别上创建。 MySQL的主键名总是PRIMARY KEY， 当创建主键约束时，系统默认会在所在的列或列组合上建立对应的唯一索引。 #已有表，修改，删除 ALTER TABLE table_name ADD primary key(column_name); /*必须是不存在重复值的列*/ ALTER TABLE table_name DROP primary key; # 创建时设置 mysql\u003e CREATE TABLE stu4(id INT PRIMARY KEY, sex CHAR(2)); mysql\u003e CREATE TABLE stu4(id INT, sex CHAR(2), PRIMARY KEY(id)); # 第二种写法 # 效果 只能有一个列为主键，且没有重复 mysql\u003e INSERT INTO stu4(id,sex) VALUES(1,'f'); Query OK, 1 row affected (0.00 sec) mysql\u003e INSERT INTO stu4(id,sex) VALUES(1,'f'); ERROR 1062 (23000): Duplicate entry '1' for key 'PRIMARY' 2.4.5 自增约束 AUTO_INCREMENT MySQL的中AUTO_INCREMENT类型的属性用于为一个表中记录自动生成ID功能。一个表只能有一个自增字段，并且该字段必须是主键或者索引。 ALTER TABLE 表名 CHANGE id id INT AUTO_INCREMENT; #必须先是索引 ALTER TABLE 表名 AUTO_INCREMENT=number; # 设置初始值 # 创建时 mysql\u003e CREATE TABLE stu5(id INT AUTO_INCREMENT,sex CHAR(2)); # 错误，必须是索引  ERROR 1075 (42000): Incorrect table definition; there can be only one auto column and it must be defined as a key mysql\u003e CREATE TABLE stu5(id INT PRIMARY KEY AUTO_INCREMENT ,sex CHAR(2)); # 正确方式  mysql\u003e CREATE TABLE stu6(id INT UNIQUE KEY AUTO_INCREMENT ,sex CHAR(2)); # 正确方式  # 效果 不提供初始值，自动递增分配， 提供重复的则报错 ","date":"2019-03-19","objectID":"/mysql-operation-manual/:2:4","tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/"},{"categories":["program"],"content":"2.4 行操作 行增 INSERT INTO 表名( 字段1, 字段2,... 字段N ) VALUES( value1, value2,... valueN ); # 字段（field）和值（value）都可以省略 行删 DELETE FROM \u003c表名\u003e [WHERE \u003c删除条件\u003e] # 栗子 delete from class where _id=9; delete from class; # 不跟条件表示删除整个表内容（不是整个表，框架还在），等价于 truncate table \u003c表名\u003e 行改 UPDATE \u003c表名\u003e SET \u003c列名=更新值\u003e [WHERE \u003c更新条件\u003e] # 栗子 update class SET score=100 WHERE name=\"郑同学\"; ","date":"2019-03-19","objectID":"/mysql-operation-manual/:2:5","tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/"},{"categories":["program"],"content":"3 行查询 ","date":"2019-03-19","objectID":"/mysql-operation-manual/:3:0","tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/"},{"categories":["program"],"content":"3.1 全列查询/投影查询 SELECT column_name0,column_name1... FROM table_name0,table_name1... [WHERE clause] [LIMIT N] [OFFSET M ] # 查询表phonelist所有字段信息 SELECT * FROM phonelist; # 只查询名字（name）为小张的所有字段信息 SELECT * FROM phonelist WHERE name=\"小张\"; ","date":"2019-03-19","objectID":"/mysql-operation-manual/:3:1","tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/"},{"categories":["program"],"content":"3.2 消除重复 distinct 可用于一列，也可用于多列，使用后如果目标字段有重复的内容，只打印一个 SELECT DISTINCT column_name0,column_name1... FROM table_name0,table_name1... [WHERE clause] [LIMIT N] [OFFSET M ] # 不出现重复打印班级里的同学名字 SELECT DISTINCT name FROM class; ","date":"2019-03-19","objectID":"/mysql-operation-manual/:3:2","tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/"},{"categories":["program"],"content":"3.3 算术操作符 对NUMBER型数据可以使用算数操作符创建表达式（+ - * /） 对DATE型数据可以使用算数操作符创建表达式（+ -） # 吧所有同学学号乘以10再打印 SELECT id*10 FROM class; ","date":"2019-03-19","objectID":"/mysql-operation-manual/:3:3","tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/"},{"categories":["program"],"content":"3.4 空值判断 IS NULL/IS NOT NULL 空值是指不可用、未分配的值,也就是没有值。 空值不等于零或空格 任意类型都可以支持空值，也就是说任何类型的字段都可以允许空值作为值的存在 空字符串和字符串为null的区别 包括空值的任何算术表达式都等于空，使用IFNULL(expr1,expr2)来处理, expr1为NULL就用expr2替代。 # 查询班级所有name字段不为空的所有信息 SELECT * FROM class WHERE name IS NOT NULL; # 计算 学分 = 成绩/10，成绩为NULL的按0分算 SELECT IFNULL(score,0)/10 FROM class; ","date":"2019-03-19","objectID":"/mysql-operation-manual/:3:4","tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/"},{"categories":["program"],"content":"3.5 比较运算符 比较运算符 表达式 用法 等于，不等于，大于，小于 =,!=,\u003c\u003e,\u003c,\u003c=,\u003e,\u003e= WHERE num\u003e=0 AND num\u003c=10 在两值之间（闭区间） BETWEEN … AND … WHRER num BETWEEN 0 AND 10 不在两值之间 NOT BETEWEEN … 同上，BETWEEN 前加 NOT 匹配在集合中的值 IN（list） WHERE name IN(‘abc’,‘efg’,‘h’) 匹配不在集合中的值 NOT IN（list） 同上 模糊匹配 LIKE WHRER name LIKE ‘%abc’ OR name LIKE ‘abc_’ LIKE运算符必须使用通配符才有意义： 匹配单个字符_匹配任意多个字符% ","date":"2019-03-19","objectID":"/mysql-operation-manual/:3:5","tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/"},{"categories":["program"],"content":"3.6 逻辑运算符 逻辑运算符 意义 AND 如果组合的条件都是true,返回true. OR 如果组合的条件 之一是true,返回true. NOT 如果下面的条件是false,返回true. ","date":"2019-03-19","objectID":"/mysql-operation-manual/:3:6","tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/"},{"categories":["program"],"content":"3.7 结果排序 使用ORDER BY 子句将记录排序，ORDER BY 子句出现在SELECT语句的最后，ORDER BY 可以使用别名。ASC: 升序。DESC: 降序。缺省:升序。 # 查询所有信息，按id降序排序 SELECT * FROM phonelist ORDER BY id DESC; ","date":"2019-03-19","objectID":"/mysql-operation-manual/:3:7","tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/"},{"categories":["program"],"content":"4 进阶 ","date":"2019-03-19","objectID":"/mysql-operation-manual/:4:0","tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/"},{"categories":["program"],"content":"4.1 索引 4.1.1 索引介绍 索引分单列索引和组合索引。 单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。 组合索引，即一个索引包含多个列。 创建索引时，你需要确保该索引是应用在SQL查询语句的条件(一般作为 WHERE 子句的条件)。 索引提高查询速度，降低更新表的速度。空间换时间 4.1.2 索引操作 查看索引 SHOW INDEX FROM 表名; 创建索引 自动创建的索引，当在表上定义一个PRIMARY KEY时，自动创建一个对应的唯一索引。当在表上定义一个外键时，自动创建一个普通索引； 手动创建的索引，用户可以创建索引以加速查询，在一列或者多列上创建索引。如果多列在一起，就叫做复合索引；在很多情况下，复合索引比单个索引更好。 CREATE INDEX index_name ON 表名(列名); # index_name 自定义 CREATE UNIQUE INDEX index_name ON 表名(列名); # unique 表示唯一索引 ALTER TABLE 表名 ADD INDEX index_name(列名); # 列名有多个就是组合索引 CREATE TABLE `news`( `id` int(11) NOT NULL AUTO_INCREMENT, `title` varchar(255) NOT NULL, `content` varchar(255) NULL, `time` varchar(20) NULL DEFAULT NULL, PRIMARY KEY (`id`), INDEX index_name (title(255)) )# 创建表同时建立索引，PRIMARY KEY 其实也是索引 删除索引 ALTER TABLE 表名 DROP INDEX index_name; 检查语句是否使用索引 并不是所有情况下都会使用索引，只有当MySQL认为索引足够能够提升查询性能时才会使用； EXPLAIN select * from table_name where clause; ","date":"2019-03-19","objectID":"/mysql-operation-manual/:4:1","tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/"},{"categories":["program"],"content":"4.2 分页查询 分页查询：一般情况下，客户端通过传递 pageNo（页码）、pageSize（每页条数）两个参数去分页查询数据库中的数据，在数据量较小（元组百/千级）时使用 MySQL自带的 limit 来解决这个问题： # 从第n行开始，打印m条数据，行数从0开始，可以不加offset，默认从0开始 SELECT * FROM 表名 LIMIT m OFFSET n; # 另一种写法，从第n行开始打印m条 select * from 表名 limit n,m; ","date":"2019-03-19","objectID":"/mysql-operation-manual/:4:2","tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/"},{"categories":["program"],"content":"4.3 函数 select func();可以查看函数效果； 4.3.1 字符函数 函数 功能 LOWER/UPPER 大小写转换 CONCAT 字符连接 CHAR_LENGTH/LENGTH 求字符串长度 LPAD/RPAD 左/右 填充 LTRIM/RTRIM/TRIM 去除 全部/左边/右边 空格 REPLACE 替换 SUBSTRING 获取子串 SELECT LOWER(\"ABC\"); # abc SELECT UPPER(\"abc\"); # ABC SELECT CONCAT(\"china\",\"is\",UPPER(\"greate\"));# china is GREATE SELECT CHAR_LENGTH(\"abc\"); # 3 SELECT LENGTH(\"china\"); # 5 SELECT RPAD(\"abc\",6,\"xyz\"); # abcxyz SELECT LPAD(\"abc\",6,\"X\"); # XXXabc SELECT TRIM(\" abc \"); SELECT REPLACE(\"abc\",\"b\",\"BB\"); # aBBc SELECT SUBSTRING(\"abcchina\",3); # cchina SELECT SUBSTRING(\"abcchina\",3,4); # cchi SELECT SUBSTRING(\"abcchina\",‐3); # ina 4.3.2 数学函数 函数 功能 ABS 求绝对值 MOD 求模 FLOOR/CEIL 向下/向上取整 ROUND 四舍五入 TRUNCATE 按位数截断 SELECT ABS(‐100); # 100 SELECT MOD(100,3); # 1 #一下都是对浮点型数字进行操作 SELECT FLOOR(1.23); # 1 SELECT CEIL(1.23); # 2 SELECT ROUND(3.145); # 3 SELECT ROUND(3.145,2); # 3.15 保留俩位小数 SELECT TRUNCATE(3.14,1); # 3.1 截取小数点后1位 4.3.3 日期函数 函数 功能 NOW 当前时间 2017-08-06 22:33:39 YEAR 年 MONTH 月 DAY 日 HOUR 时 MINUTE 分 SECOND 秒 CURRENT_DATE 年-月-日 CURRENT_TIME 时：分：秒 LAST_DAY 所在月份的最后一天 DATE_ADD/DATE_SUB 增减 DATEDIFF 日期差 SELECT NOW(); # 2019-02-13 12:51:39 SELECT YEAR(NOW()); # 2019 SELECT MONTH(NOW()); # 2 SELECT DAY(NOW()); # 13 # HOUT MINUTE SECOND 用法同上 SELECT CURRENT_DATE(); # 2019-02-13 简写CURDATE() SELECT CURRENT_TIME(); # 12:56:20 简写CURTIME() SELECT LAST_DAY(NOW()); # 2019-02-28 SELECT LAST_DAY(str_to_date('2019-12-01 00:00:00','%Y-%m-%d %H:%i:%s')); # 2019-12-31 SELECT DATE_ADD(NOW(),INTERVAL 2 DAY); # 2019-02-15 13:02:01 SELECT DATE_SUB(NOW(),INTERVAL 3 HOUR); SELECT DATEDIFF(LAST_DAY(NOW()),NOW()); # 15 4.3.4 转换函数 函数 功能 FORMAT 数字到字符串的转化 DATE_FORMAT 时间到字符串 STR_TO_DATE 字符串到时间 SELECT FORMAT(235235.346326,2); # 小数点保留2位 235,235.35 SELECT DATE_FORMAT(NOW(),'%b %d %Y %h:%i %p'); # Feb 13 2019 01:16 PM SELECT DATE_FORMAT(NOW(),'%m-%d-%Y'); # 02-13-2019 SELECT STR_TO_DATE('2019-12-01 00:00:00','%Y-%m-%d %H:%i:%s'); # 2019-12-01 00:00:00 4.3.5 聚合函数 函数 功能 COUNT() 返回指定列中（满足条件的）非NULL值的个数 AVG() 返回指定列（满足条件的）的平均值 SUM() 返回指定列（满足条件的）的所有值之和 MAX() 返回指定列（满足条件的）的最大值 MIN() 返回指定列（满足条件的）的最小值 # 计算班级 50分以上同学的分数最大差 SELECT MAX(score)‐MIN(score) FROM class WHERE; ","date":"2019-03-19","objectID":"/mysql-operation-manual/:4:3","tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/"},{"categories":["program"],"content":"4.4 分组查询 4.4.1 GROUP BY 在对数据表中数据进行统计时，可能需要按照一定的类别分别进行统计， 如score字段中，值相同的行被视作一类（分组） 单独使用GROUP BY关键字，查询的是每个分组中的一条记录，意义不大。 一般情况下，GROUP BY都和聚合函数一起使用 # 统计60分以上，各个分数的人数 SELECT COUNT(*),score FROM class WHERE score\u003e60 GROUP BY score; 4.4.2 HAVING HAVING关键字和 WHERE 关键字的作用相同，都是用于设置条件表达式，对查询结果进行过滤。 两者的区别，HAVING关键字后，可以跟聚合函数，而WHERE关键字不能，通常情况下，HAVING关键字，都是和GROUP BY一起使用，用于对分组后的结果进行过滤 ## 统计60分以上，各个分数的人数, 并且只筛选相同分数的人数小于10人的分组 SELECT COUNT(*),score FROM class WHERE score\u003e60 GROUP BY score HAVING count(*)\u003c10; ","date":"2019-03-19","objectID":"/mysql-operation-manual/:4:4","tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/"},{"categories":["program"],"content":"4.5 多表查询 补充 可以给表起别名 # 这里给表 phonelist 起了别名 p，多表操作别名很方便 SELECT p.name FROM phonelist p where p.id=2; 多表查询,如果没有连接条件,则会产生笛卡尔积，实际运行环境下，应避免使用全笛卡尔集。 笛卡儿积，即如果有两个表，拿第一个表的一条数据跟第二个表每条数据都关联，这样的数据没有意义 在WHERE加入有效的连接条件（等值连接）。注意连接 n张表，至少需要 n-1个连接条件。 这个博客讲的很清楚 SELECT a.t1 b.msg FROM a,b WHERE a.id=b.id; #这里id就是连接条件，id相同才会被关联 ","date":"2019-03-19","objectID":"/mysql-operation-manual/:4:5","tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/"},{"categories":["program"],"content":"4.6 主键和外键 主键约束(PRIMARY KEY): 约束在当前表中,指定列的值非空且唯一。 外键约束(FOREIGN KEY): A表中的外键列的值必须引用于于B表中的某主键列。 ALTER TABLE `A` ADD FOREIGN KEY(`myid`) REFERENCES `B`(`id`); 如果建立外键后，要删除B中数据的时候，需要先删除A中相关的数据。 可以看作表A是B的附属，没有B，A就没有意义了； ","date":"2019-03-19","objectID":"/mysql-operation-manual/:4:6","tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/"},{"categories":["program"],"content":"4.7 子查询 子查询指的就是在一个查询之中嵌套了其他的若干查询。 在使用select语句查询数据时,有时候会遇到这样的情况，在where查询条件中的限制条件不是一个确定的值，而是一个来自于另一个查询的结果。 子查询一般出现在FROM和WHERE子句中。 4.7.1 子查询返回单行单列 单行单列子查询：只包含一个字段的查询，返回的查询结果也只包含一行数据, 看做是一个值. 使用在WHERE之后。 # 查询分数高于班级平均分的同学的姓名 SELECT name FROM class WHERE score\u003e(SELECT AVG(score) FROM class); 4.7.2 子查询返回多行单列 多行单列子查询：只包含了一个字段，但返回的查询结果可能多行或者零行，看做是多个值，使用在WHERE之后。 关键字 含义 IN 与列表中的任意一个值相等 ANY 与子查询返回的任意一个值比较 ALL 与子查询返回的每一个值比较 # 查询工资等于部门经理的员工信息. SELECT * FROM emp WHERE sal IN (SELECT sal FROM emp WHERE JOB='manager'); SELECT * FROM emp WHERE sal \u003e ANY (SELECT sal FROM emp WHERE JOB='manager'); SELECT * FROM emp WHERE sal \u003e ALL (SELECT sal FROM emp WHERE JOB='manager'); 4.7.3 子查询返回多行多列 多行多列子查询：包含多个字段的返回，查询结构可能是单行或者多行，看做是临时表，使用在FROM之后，临时表需要有别名。 # tmp是临时表别名 SELECT tmp.* FROM (SELECT deptno,AVG(sal) avg_sal FROM emp GROUP BY deptno) tmp WHERE tmp.avg_sal \u003e 2000; ","date":"2019-03-19","objectID":"/mysql-operation-manual/:4:7","tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/"},{"categories":["program"],"content":"4.8 备份与回复 备份 kirito@host:~$ mysqldump ‐u账户 ‐p密码 数据库名称\u003e文件存储地址 # 栗子 kirito@host:~$ mysqldump ‐uroot ‐p123456 testDB\u003e /home/kirito/testDB_bak.sql 恢复 kirito@host:~$ mysql ‐u账户 ‐p密码 数据库名称\u003c 文件存储地址 （数据库要已存在） # 栗子 kirito@host:~$ mysql ‐uroot ‐p123456 testDB\u003c /home/kirito/_bak.sql # 也可以进入数据库导入 CREATE DATABASE testdb; USE testdb; SOURCE /home/kirito/_bak.sql; ","date":"2019-03-19","objectID":"/mysql-operation-manual/:4:8","tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/"},{"categories":["program"],"content":"4.9 SQL语句执行顺序 书写顺序 SELECT [DISTINCT] [聚合函数] FROM WHERE GROUP BY HAVING ORDER BY 执行顺序 FROM WHERE GROUP BY #从这里开始可以使用别名 聚合函数 HAVING SELECT DISTINCT ORDER BY ","date":"2019-03-19","objectID":"/mysql-operation-manual/:4:9","tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/"},{"categories":["program"],"content":"5 事务处理(transaction) 在数据库中，所谓事务是指一组逻辑操作单元，使数据从一种状态变换到另一种状态。为确保数据库中数据的一致性，数据的操纵应当是离散的成组的逻辑单元:当它全部完成时，数据的一致性可以保持，而当这个单元中的一部分操作失败，整个事务应全部视为错误，所有从起始点以后的操作应全部回退到开始状态。 事务的操作:先定义开始一个事务，然后对数据作修改操作，这时如果提交(COMMIT)，这些修改就永久地保存下来，如果回退(ROLLBACK)，数据库管理系统将放弃您所作的所有修改而回到开始事务时的状态。 ","date":"2019-03-19","objectID":"/mysql-operation-manual/:5:0","tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/"},{"categories":["program"],"content":"5.1 事务的ACID属性 原子性（Atomicity）原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 一致性（Consistency）事务必须使数据库从一个一致性状态变换到另外一个一致性状态。(数据不被破坏). 隔离性（Isolation）事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰,每一个事务都存在一个事务空间,彼此不干扰。 持久性（Durability）持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响. ","date":"2019-03-19","objectID":"/mysql-operation-manual/:5:1","tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/"},{"categories":["program"],"content":"5.2 事务语句 BEGIN # 开启一个事务 COMMIT # 提交事务 ROLLBACK # 回滚事务 # 栗子 BEGIN; SELECT * FROM class WHERE id=1; UPDATE class SET score=100 WHERE id=1; COMMIT; ","date":"2019-03-19","objectID":"/mysql-operation-manual/:5:2","tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/"},{"categories":["program"],"content":"5.3 事务并发问题 数据库的事务并发问题: 存在五种问题:脏读，不可重复读，幻读，第一类丢失更新，第二类丢失更新。 详细见附录 ","date":"2019-03-19","objectID":"/mysql-operation-manual/:5:3","tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/"},{"categories":["program"],"content":"5.4 锁机制 mysql中使用repeatable read模式，只存在第二类丢失更新，通过加锁的方式可以避免。 for update # 加锁 锁释放发生在回滚和提交。 # lock in share mode # 共享锁 /* for update仅适用于InnoDB，且必须在事务块(BEGIN/COMMIT)中才能生效。在进行事务操作时，通过“for update”语句，MySQL会对查询结果集中每行数据都添加排他锁，其他线程对该记录的更新与删除操作都会阻塞。排他锁包含行锁、表锁。 */ # 栗子 BEGIN; SELECT * FROM class WHERE id=1 FOR UPDATE; # 加锁 UPDATE class SET score=100 WHERE id=1; COMMIT; # 释放 ","date":"2019-03-19","objectID":"/mysql-operation-manual/:5:4","tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/"},{"categories":["program"],"content":"附录 ","date":"2019-03-19","objectID":"/mysql-operation-manual/:6:0","tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/"},{"categories":["program"],"content":"A 数据类型 A.1 数值类型 MySQL支持所有标准SQL数值数据类型。 这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。 关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。 BIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。 作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。下面的表显示了需要的每个整数类型的存储和范围。 类型 大小 范围（有符号） 范围（无符号） 用途 TINYINT 1 字节 (-128，127) (0，255) 小整数值 SMALLINT 2 字节 (-32 768，32 767) (0，65 535) 大整数值 MEDIUMINT 3 字节 (-8 388 608，8 388 607) (0，16 777 215) 大整数值 INT或INTEGER 4 字节 (-2 147 483 648，2 147 483 647) (0，4 294 967 295) 大整数值 BIGINT 8 字节 (-9,223,372,036,854,775,808，9 223 372 036 854 775 807) (0，18 446 744 073 709 551 615) 极大整数值 FLOAT 4 字节 (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) 0，(1.175 494 351 E-38，3.402 823 466 E+38) 单精度 浮点数值 DOUBLE 8 字节 (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 双精度 浮点数值 DECIMAL 对DECIMAL(M,D) ，如果M\u003eD，为M+2否则为D+2 依赖于M和D的值 依赖于M和D的值 小数值 A.2 日期和时间类型 表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。 每个时间类型有一个有效值范围和一个\"零\"值，当指定不合法的MySQL不能表示的值时使用\"零\"值。 TIMESTAMP类型有专有的自动更新特性，将在后面描述。 类型 大小 (字节) 范围 格式 用途 DATE 3 1000-01-01/9999-12-31 YYYY-MM-DD 日期值 TIME 3 ‘-838:59:59’/‘838:59:59’ HH:MM:SS 时间值或持续时间 YEAR 1 1901/2155 YYYY 年份值 DATETIME 8 1000-01-01 00:00:00/9999-12-31 23:59:59 YYYY-MM-DD HH:MM:SS 混合日期和时间值 TIMESTAMP 4 1970-01-01 00:00:00/2038 结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 凌晨 03:14:07 YYYYMMDD HHMMSS 混合日期和时间值，时间戳 A.3 字符串类型 字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。 类型 大小 用途 CHAR 0-255字节 定长字符串 VARCHAR 0-65535 字节 变长字符串 TINYBLOB 0-255字节 不超过 255 个字符的二进制字符串 TINYTEXT 0-255字节 短文本字符串 BLOB 0-65 535字节 二进制形式的长文本数据 TEXT 0-65 535字节 长文本数据 MEDIUMBLOB 0-16 777 215字节 二进制形式的中等长度文本数据 MEDIUMTEXT 0-16 777 215字节 中等长度文本数据 LONGBLOB 0-4 294 967 295字节 二进制形式的极大文本数据 LONGTEXT 0-4 294 967 295字节 极大文本数据 CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。 BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。 BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。 有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。 ALTER TABLE table_name DRO P INDEX index_name; ","date":"2019-03-19","objectID":"/mysql-operation-manual/:6:1","tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/"},{"categories":["program"],"content":"B 并发问题 B.1 脏读（dirty read A事物读取B事物尚未提交更改的数据，并在这个数据的基础上操作。如果B事物恰巧回滚，那么A事物读取到的事物是根本不被承认的。如下列： 时间 事物A 事物B T1 开始事物 T2 开始事物 T3 查询余额1000元 T4 取出500元，余额改为500元 T5 查询余额500元（脏读） T6 撤销事物余额1000元 T7 汇入100元，余额改为600元 T8 提交事物 在这个场景中B希望取出500元，而后又撤销了动作，而A往相同账户转入100元，就因为A读取到了B未提交更改数据，造成账户白白丢失500元。（注：在oracal数据库中，不会发生脏读的情况） B.2 不可重复读（unrepeatable read） 不可重复读是指：A事物读取到B事物已提交的更改数据。假设A在取款事物过程中，B往账户转入100元，A两次读取到的余额不一致。 时间 事物A 事物B T1 开始事物 T2 开始事物 T3 查询账户余额为1000元 T4 查询账户余额位1000元 T5 取出100元，修改余额为900元 T6 提交事物 T7 查询账户余额900元（和T4查询不一致） 同一事务中两次查询账户余额不一致 B.3 幻读（phantom read） A事物读取B事物提交的新增数据，这时A事物将出现幻读 时间 事物A 事物B T1 开始事物 T2 开始事物 T3 统计账户总存款为10000元 T4 新增一个存款账户，并转入100元 T5 提交事物 T6 再次统计存款为10100元（幻读） 如果新增数据刚好满足查询条件，这个数据就会进入事物的视野，因而产生两次统计结果不一致的情况 注：幻读和不可重复读的区别在于前者读取到的是已提交的新增数据，后者读取到的是已提交的更新数据（或者删除的数据）。为了避免这两种情况，采取的策略是不同的，防止读到更改操作，只需要对操作数据添加行级锁，阻止操作中的数据发生变化；而防止读到新增数据，则往往添加表级锁–将整张表锁定，防止新增数据（Oracal通过多版本数据的方式实现） B.4 第一类丢失更新 A事物撤销时，覆盖掉 B事物已提交的更新数据。 时间 事物A 事物B T1 开始事物 T2 开始事物 T3 查询账户为1000元 T4 查询账户为1000元 T5 转入100元，修改余额为1100元 T6 提交事物 T7 取出100元，修改余额为900元 T8 撤销事物（或提交事物） T9 余额回复为1000元（丢失更新） A事物在撤销时，将B事物转入的100元抹去了 B.5 第二类丢失更新 A事物覆盖B事物已提交的数据，造成B事物所有的操作丢失 时间 事物A 事物B T1 开始事物 T2 开始事物 T3 查询账户为1000元 T4 查询账户为1000元 T5 取出100元，修改余额为900元 T6 提交事物 T7 转入100元 T8 提交事物 T9 修改余额为1100元（丢失更新） B.6 隔离级别 为了解决上述的问题，提出了隔离级别的概念，不同的隔离级别可以处理的并发问题是不一样的。使用不同的隔离级别就可以阻止自己所期望的并发问题。 隔离级别 脏读 不可重复度 幻读 第一类丢失更新 第二类丢失更新 READ UNCOMMITED √ √ √ × √ READ COMMITTED × √ √ √ √ REPREATABLE READ × × √ √ √ SERIALIZABLE × × × × × √ 表示可能出现的情况， × 号表示不会出现 SQL92推荐使用REPREATABLE READ，用户可自定义 ","date":"2019-03-19","objectID":"/mysql-operation-manual/:6:2","tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/"},{"categories":["program"],"content":"C 使用libmysqlclient库 g++ a.cpp -lmysqlclient -o a.out //a.cpp 简单示例 #include \u003cstdio.h\u003e#include \u003cmysql/mysql.h\u003e MYSQL mysql,*sock; //连接要用到 int main(){ const char * host = \"127.0.0.1\"; //主机名 const char * user = \"root\"; const char * passwd = \"123456\"; const char * db = \"zsh\"; //数据库名字 unsigned int port = 3306; //不改动默认就是这个 const char * unix_socket = NULL; unsigned long client_flag = 0; //一般0 const char * i_query = \"select * from phonelist\"; //查询语句 int ret; MYSQL_RES * result; MYSQL_ROW row; mysql_init(\u0026mysql); //必须 if((sock = mysql_real_connect(\u0026mysql,host,user,passwd,db,port,unix_socket,client_flag)) == NULL){ ret = mysql_errno(\u0026mysql); printf(\"connect error,errno %d\\n\",ret); //fprintf(stderr,\"%s\\n\",mysql_error(\u0026mysql)); exit(1); }else{ fprintf(stderr,\"connect success\\n\"); } mysql_query(\u0026mysql,\"set names utf8\");//在连接后使用，中文显示正常 /* 这一句等于 SET character_set_client = utf8; SET character_set_results = utf8; SET character_set_connection = utf8; */ if(mysql_query(\u0026mysql,i_query) != 0){ fprintf(stderr,\"query error\\n\"); exit(1); }else{ if((result = mysql_store_result(\u0026mysql)) == NULL){ fprintf(stderr,\"save result error\\n\"); exit(1); }else{ int field_num = mysql_field_count(\u0026mysql); //获得列数 MYSQL_FIELD * fields = mysql_fetch_fields(result); //列名 for(int i=0; i\u003cfield_num; i++){ printf(\"%s \\t\",fields[i].name); }putchar('\\n'); while((row = mysql_fetch_row(result)) != NULL){ for(int i=0; i\u003cfield_num; i++){ printf(\"%s \\t\",row[i]); }putchar('\\n'); } } } mysql_free_result(result); mysql_close(sock); exit(EXIT_SUCCESS); } ","date":"2019-03-19","objectID":"/mysql-operation-manual/:6:3","tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/"},{"categories":["algorithm"],"content":"回文串是指是正着读和反着读都一样的字符串，比如abcba。 最长回文子串是指在一个字符串中能找到的最长回文串，如这个字符串最长回文字串是最后6个字符：abacacbaaaab 用马拉车算法求一个串中的最长回文子串： 首先将字符串长度处理成奇数，如\"abbc\"处理成\"$a#b#b#c#\"。 然后从左到右边遍历求出以每个字符为中心的回文半径Mp, 其中最大的那个回文半径就对应着最长的回文子串。 ","date":"2019-01-17","objectID":"/manacher/:0:0","tags":["algorithm"],"title":"最长回文子串-马拉车","uri":"/manacher/"},{"categories":["algorithm"],"content":"Manacher 算法实现如下： 图中id表示如果以这个下标为中心，回文半径最远可以到达的位置是mx（这表示区间(id,mx]与[mx\",id)是对称的, id位置就是对称轴）。 马拉车的思想是利用左边已经求出的回文半径，帮助计算右边的回文半径。如果我们要求下标i的回文半径，那么： 2*id-i 指的就是是下标i关于id的对称位置i\",(i肯定在id的右边,因为是从左往右遍历处理) 计算回文半径Mp[i]: 如果mx\u003ei(图1,2)，即id处的回文半径能够覆盖当前位置，那么i关于id的对称位置i\"一定也在以id为中心的回文串中。 i\"位于id左边，所以i\"的结果前面已经算出来了，直接得出i\"的回文半径就是Mp[i\"] = Mp[2*id-i]。 （图里左边的红色部分就是回文半径为Mp[i\"]的回文串，右边是对称的部分） 这时候计算i的回文半径还分两种情况: mx-i \u003e Mp[2*id-i] mx-i \u003c Mp[2*id-i] 分别对应图1、2。Mp[i]的值选取两者中较小的那一个。 因为图中只有同时被红色和绿色覆盖的，才关于i对称，其他的未知。 如果，mx \u003c= i(图3)，那么i的回文半径只能通过一次次比较求得。 细节见代码，返回值是最长回文串长度。 namespace Manacher{ const int MAXN = 100;//字符串最大长度 char Ma[MAXN*2];//处理后的字符串 int Mp[MAXN*2];//每个位置的回文半径,max(Mp[i])-1就是最长回文长度 int Manacher(const char s[], int len){ int l = 0, ret = 0; Ma[l++] = '$'; Ma[l++] = '#'; for(int i = 0; i\u003clen; i++){ Ma[l++] = s[i]; Ma[l++] = '#'; } Ma[l] = 0; int mx = 0, id = 0; //从id处回文半径可以达到mx处 for(int i = 0; i \u003c l; i++){ Mp[i] = mx \u003e i ? min(Mp[2*id-i], mx - i) : 1; while(Ma[i + Mp[i]] == Ma[i - Mp[i]]) Mp[i]++; ret = max(Mp[i]-1,ret); if(i + Mp[i] \u003e mx){ mx = i + Mp[i]; id = i; } } return ret; } } ","date":"2019-01-17","objectID":"/manacher/:1:0","tags":["algorithm"],"title":"最长回文子串-马拉车","uri":"/manacher/"},{"categories":["algorithm"],"content":"例题 POJ3974 裸题 ","date":"2019-01-17","objectID":"/manacher/:2:0","tags":["algorithm"],"title":"最长回文子串-马拉车","uri":"/manacher/"},{"categories":["algorithm"],"content":"哈尔滨理工大学软件与微电子学院第八届程序设计竞赛同步赛（高年级） 小乐乐搭积木 链接：https://ac.nowcoder.com/acm/contest/301/B 来源：牛客网 ","date":"2018-12-06","objectID":"/contour-dp/:0:0","tags":["algorithm","dp"],"title":"轮廓线dp","uri":"/contour-dp/"},{"categories":["algorithm"],"content":"题目描述 小乐乐想要给自己搭建一个积木城堡。 积木城堡我们假设为n*m的平面矩形。 小乐乐现在手里有 1*2，2*1两种地砖。 小乐乐想知道自己有多少种组合方案。 ","date":"2018-12-06","objectID":"/contour-dp/:1:0","tags":["algorithm","dp"],"title":"轮廓线dp","uri":"/contour-dp/"},{"categories":["algorithm"],"content":"输入描述: 第一行输入整数 n,m。(1\u003c=n,m\u003c=10) ","date":"2018-12-06","objectID":"/contour-dp/:2:0","tags":["algorithm","dp"],"title":"轮廓线dp","uri":"/contour-dp/"},{"categories":["algorithm"],"content":"输出描述: 输出组合方案数。 ","date":"2018-12-06","objectID":"/contour-dp/:3:0","tags":["algorithm","dp"],"title":"轮廓线dp","uri":"/contour-dp/"},{"categories":["algorithm"],"content":"示例 输入 2 3 输出 3 ","date":"2018-12-06","objectID":"/contour-dp/:4:0","tags":["algorithm","dp"],"title":"轮廓线dp","uri":"/contour-dp/"},{"categories":["algorithm"],"content":"ac代码 #include \u003ciostream\u003e#include \u003cstring.h\u003eusing namespace std; int n,m; int dp[2][(1\u003c\u003c11)],cur,mask; //mask 掩码 void update(int a,int b){ dp[cur][b] += dp[cur^1][a]; //更新状态方案数 } int main(){ cin\u003e\u003en\u003e\u003em; mask = (1\u003c\u003cm)-1; //设置掩码 memset(dp,0,sizeof(dp)); cur = 0; //滚动数组 dp[cur][(1\u003c\u003cm)-1] = 1; //初始化 for(int i = 0;i \u003c n;i++){ for(int j = 0;j \u003c m;j++){//当前处理位置(i,j) cur ^= 1; memset(dp[cur],0,sizeof(dp[cur])); for(int k = 0;k \u003c (1\u003c\u003cm);k++){//枚举当前状态 //当前和上都放 上有空位就不能往左，也不能不放 if(i \u0026\u0026 !(k\u0026(1\u003c\u003c(m-1))))//不是第一行，且正上方为空 { update(k,((k\u003c\u003c1)^1)\u0026mask);//新状态尾部置1 }else { //当前和左放 if(j \u0026\u0026 (!(k\u00261)))//不是第一列并且左边为空 update(k,((k\u003c\u003c1)^3)\u0026mask);//新状态尾两个11 //不放 update(k,(k\u003c\u003c1)\u0026mask); //掩码是只取低m位作为状态 } } } } cout\u003c\u003cdp[cur][(1\u003c\u003cm)-1]\u003c\u003cendl; return 0; } ","date":"2018-12-06","objectID":"/contour-dp/:5:0","tags":["algorithm","dp"],"title":"轮廓线dp","uri":"/contour-dp/"},{"categories":["algorithm"],"content":"思路 轮廓线dp，状压 在这道题中，假设我们有一个 5*5 的格子要填充(如图)，黑色部分不是格子的一部分，只是作为虚拟出来的\"顶\"。 图1中蓝色部分表示已经填充好的部分；黄色部分是状态压缩表示的状态，已经填充为1，没有为0；红色表示当前处理的位置。 图2中我们用状态01111表示当前的\"轮廓\"。这个状态的\"头\"总是在\"当前\"的上面，这个状态的\"尾\"大部分时候在\"当前\"的左边(图4的情况不是)。 图3中，我们\"当前\"的处理方式只能是填充\"当前\"和\"头\"(竖着放)，因为如果我们不这样，上方的空位就无法被填充，会被忽略过去。 图4中，“当前\"的左边没有格子，而且上方是0，不可能往左放，只能往上放(竖着放)。处理过之后就变成下面的新状态了。 图5中，有两种选择，往左放或者不放。 特别的，如何初始化？ 处理第一行的时候，假设上面还有一层，并且都填充了(就是图中黑色部分)，这样就可以像其他位置一样处理。 怎么记录方案数？ 每一个状态都是由另一个状态得到的，状态1 —\u003e状态2 ; 状态3 —\u003e 状态2; 可能很多状态都能到状态2，那么状态2的方案数就是： 状态1方案数 + 状态2方案数 + … 设dp[cur][state]表示cur(当前)位置为state状态的方案数。last为上一个位置。 设 k 表示处理当前位置前的状态(轮廓)，new为处理当前位置后的状态(轮廓) 转移方程有 dp[cur][new] += dp[last][k]; 我先去上课 。。。。 具体实现可以看代码。 需要注意的几点： 初始化是当上面有一行不存在的，已经填充好的一行 dp[cur][(1\u003c\u003cm)-1] = 1 cur ^= 1 是滚动数组的操作，因为当前位置状态只和它之前位置状态有关 任何时候，上方有空位就不能选择左或者不填。 ","date":"2018-12-06","objectID":"/contour-dp/:6:0","tags":["algorithm","dp"],"title":"轮廓线dp","uri":"/contour-dp/"},{"categories":["program"],"content":"记录cpp中大部分的知识点，个人理解有限，不一定都正确。 ","date":"2017-12-23","objectID":"/cpp-note/:0:0","tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/"},{"categories":["program"],"content":"2.2 cout控制输出长度/格式： cout\u003c\u003csetw(8)\u003c\u003ca\u003c\u003cendl; //setw()在头文件\u003ciomanip\u003e中，只能右对齐，等价%8d cout\u003c\u003csetiosflags(ios::left)\u003c\u003csetw(8)\u003c\u003ca\u003c\u003cendl;//这样为左对齐 cout\u003c\u003csetw(8)\u003c\u003csetprecision(2)\u003c\u003csetiosflags(ios::fixed)\u003c\u003cb\u003c\u003cendl;//b是一个浮点数，等价于%8.2f cout\u003c\u003csetfill('x')\u003c\u003cset(8)\u003c\u003ca\u003c\u003cendl;//将空白用x填充 cout\u003c\u003chex\u003c\u003ca\u003c\u003cendl;//等价于printf(\"%x\\n\",a);十六进制 cout\u003c\u003coct\u003c\u003ca\u003c\u003cendl;//等价于printf(\"%o\\n\",a);八进制 cout\u003c\u003ca\u003c\u003cendl;//等价于printf(\"%d\\n\",a);十进制 ","date":"2017-12-23","objectID":"/cpp-note/:1:0","tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/"},{"categories":["program"],"content":"2.3 函数重载（静多态） 匹配原则 严格匹配 隐式转换（小到大可以，大到小不可以）寻求匹配，找到则匹配 返回值不构成重载 extern \"C\"{} //将括号内按c的方式编译，不与其他同名函数重载。c库每一个头文件都有 //--------------------------------------------------------- #ifdef __cplusplus//如果是c++编译器 extern \"c\"{ #endif // __cplusplus // 内容 #ifdef __cplusplus } #endif //表示不使用c++的重载特性 //---------------------------------------------------------- ","date":"2017-12-23","objectID":"/cpp-note/:2:0","tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/"},{"categories":["program"],"content":"2.4 运算符重载Operator Overload //运算符其实就是函数 struct zuobiao //坐标 { int x;int y; }; zuobiao operator + (zuobiao a,zuobiao b) { zuobiao c; c.x=a.x+b.x; c.y=a.y+b.y; return c; } ","date":"2017-12-23","objectID":"/cpp-note/:3:0","tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/"},{"categories":["program"],"content":"2.5 默认参数Default Parameters 参数只能从右往左默认，中间不能跳跃 ","date":"2017-12-23","objectID":"/cpp-note/:4:0","tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/"},{"categories":["program"],"content":"2.6 引用Raference \u0026前为类型名时为引用，其他均为取地址 变量名，本身是一段内存的引用，即别名（alias）。此处引入的引用是为已有变量起一个别名，声明如下 int a; int \u0026ra=a; //1. 引用是一种声明关系，必须初始化，引用不开辟空间 //2. 此种声明关系一经声明 不可变更 int \u0026rr=ra; //3. 可以对引用，再次引用。多次引用的结果，多个引用指向同一个变量 //引用的本质是对指针的包装，指针可以有引用，但不应该有引用的指针 //const int\u0026ra=a; 能用const就用；use const whatever possible //思考：引用的本质是什么？ int \u0026 ra = a； int * const p = \u0026a; 引用的本质是不可以修改指向的指针； ","date":"2017-12-23","objectID":"/cpp-note/:5:0","tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/"},{"categories":["program"],"content":"2.7 new/delete(申请动态内存) int *p = new int(200); //开一个int类型单变量并初始化为200 int *ps = new string(\"hellwo world\");//开一个string类型单变量并初始化为 hellow world int *p1 = new int[5]{0};//开一个int数组 每一项初始化为0； int **pp = new int*[5];//指针数组，存放的指针 int (*p)[4] = new int[3][4] {{0}};//p是一个指针 它指向包含4个int元素的一维数组 p为首地址 记不住怎么写编译器可以给你提示 //也可以new一个结构体 但初始化应用 {} 因为可能有有多个值 /*应用程序在内存中分为 代码区、 全局(静态)数据存储区、 栈区、 堆区。 通过new出来的内存在堆区。 局部变量，函数参数等存在栈区 */ int *p = new int ; delete p; int *p=new int[5]; delete []p; int (*p)[4][3]=new int[5][4][3]; delete []p; //异常处理 new很少出错 一般别用 int *p = new(std::nothrow) int ; if(p == nullptr){return -1}//NULL 好像变成nullptr了c++11 ","date":"2017-12-23","objectID":"/cpp-note/:6:0","tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/"},{"categories":["program"],"content":"2.8 内联函数 inline int sqr(int i) { return i*i; }//inline 是给编译器的一种建议，编译器来决定是否inline，但你不说编译器一定不inline 66666 //适用环境 函数体很小 且 频繁使用 ","date":"2017-12-23","objectID":"/cpp-note/:7:0","tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/"},{"categories":["program"],"content":"2.9 cast强制类型转换 int a=5; float b=6.5; static_cast //对于隐式类型可以转化的，可用这个 b=static_cast\u003cfloat\u003e(a); //作者不想让你强转，所以搞这么麻烦 哈啊哈 void *p;int *q; p=q;//可以 q=p;//不可以 q=static_cast\u003cint*\u003e(p);OK dynamic_cast reinterpret_cast //对于无隐式类型的转化，static_cast无效，例如将int赋值给int*指针 reinterpert重新解释 const_cast //脱常 只能用于指针和引用 void fun1(int \u0026 v) { cout\u003c\u003cv\u003c\u003cendl; } int main() { const int a; fun1(a); //这是传不进去的 fun1(const_cast\u003cint \u0026\u003e(a));//这样就传进去了 不要妄图用这个方法修改const 其行为是未定义的且没有意义 return 0; } ","date":"2017-12-23","objectID":"/cpp-note/:8:0","tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/"},{"categories":["program"],"content":"2.10 const #define N 200 //宏，在预处理阶段发生了替换 const int n = 200; //在编译阶段发生了替换 //所以const永远不会发生改变 ","date":"2017-12-23","objectID":"/cpp-note/:9:0","tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/"},{"categories":["program"],"content":"2.11 命名空间Namespace int v=55; main() { int v=5; cout\u003c\u003cv\u003c\u003cendl;//打印局部变量 cout\u003c\u003c::v\u003c\u003cendl;//打印全局变量 }//全局命名空间其实是一个没有名字的命名空间，也可以用::作用域运算符访问。 namespace //是对全局命名空间的再次划分 namespace name//协同开发 可以在不同文件中定义同名空间，将自动合并 { int x; void func() { printf(\"haha\"); } struct xy { int x;int y; }; //可以写很多，包括再写一个命名空间 } ","date":"2017-12-23","objectID":"/cpp-note/:10:0","tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/"},{"categories":["program"],"content":"2.12 字符串类型string //位于命名空间std；它是一个类不是关键字 //用cin输入时有空格会结束，但输出时字符串里可以有空格 string str=\"china\"，s2=\"0\"; cout\u003c\u003cstr.size()\u003c\u003cenld; //获得长度 char buf[100]; strcpy(buf,str.c_str());//strcpy位于string.h str.c_str()对象函数返回一个c语言类型的字符串，以兼容c cout\u003c\u003cbuf\u003c\u003cendl; str.swap(s2);//用对象方法交换 int n=str.find('a',0);//查找a，返回下标，第二个参数为从0开始，找不到返回-1 int n=str.find(\"in\",0);//查找字串,有返回首下标，没有返回-( //删空格 string ss=\" sdfsdfs \"; ss.erase(0,ss.find_first_not_of(' '));//从0删到第一个不是空格，参数一从什么地方删，参数二删几个 ss.erase(ss.find_last_not_of(' ')+1);//从最后一个不是空格删到最后 ","date":"2017-12-23","objectID":"/cpp-note/:11:0","tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/"},{"categories":["program"],"content":"3.1 封装Encapsulation //c语言的封装风格，数据放在一起打包为struck，然后吧数据以引用或指针的方式传递给行为。 struct date { int year; int month; int day; }; void init(date \u0026 d) { cin\u003e\u003ed.year; cin\u003e\u003ed.month; cin\u003e\u003ed.day; } //c++认为c封装不彻底，1数据和行为分离，2没有权限控制。 //权限控制 private protected public class date2 { private: int year; int month; int day; public: viod print() { cout\u003c\u003cyear\u003c\u003cendl; } }; //类名也是一种特别的名称空间 ","date":"2017-12-23","objectID":"/cpp-note/:12:0","tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/"},{"categories":["program"],"content":"3.2 类的构造器constructor //constructor 构造器 //1.与类名相同，无返回值，生成对象时自动调用，用于初始化 //2.可以有参数，可以重载，默认参数 class sss { public: sss() { cout\u003c\u003c\"我是构造器\"\u003c\u003cendl; } sss(int i) { cout\u003c\u003ci; } }; sss s(100);//使用构造器的重载， 创建对象时加参数 ","date":"2017-12-23","objectID":"/cpp-note/:13:0","tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/"},{"categories":["program"],"content":"3.2.2 类的析构器destructor //1.~类名（）无参无反，对象销毁时的内存处理工作 class sss { public: ~ksss() { cout\u003c\u003c\"我是析构器\"\u003c\u003cendl; } }; ","date":"2017-12-23","objectID":"/cpp-note/:14:0","tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/"},{"categories":["program"],"content":"4.1 自实现string //代码in坚果云 class A { public: A(int i=0;int j=0;int k=0)//参数列表，效率高，在函数声明之后，实现体之前，：开头 :x(i),y(j),z(k)//初始化顺序，跟变量的声明顺序有关，初始化列表中的顺序无关，即xyz顺序可变 { } private: int x,y,z; }; //拷贝构造器 //由已存在的对象，创建新对象，也就是所新对象不是由构造器来构造，而是由 //拷贝构造器来完成，拷贝构造器的格式是固定的 class A { A(const A \u0026 another)//\u0026是引用 }; //若不提供，系统提供默认，自定义是系统不再提供默认 //系统提供的默认是一种等位拷贝，浅浅的拷贝，会导致内存重析构。doble free //含有堆空间时要自实现拷贝 //友元 同类对象无私处，异类对象有友元 //运算符重载 //赋值运算符重载 string s4=s3;//本质不是赋值，而是拷贝构造，在声明时候=号表示初始化 //this指针 //系统创建对象时，默认生成当前对象的this指针。 //对对象来说，传引用效率很高，不然调用拷贝构造效率低。 //栈上的对象可以返回，但不能返回栈上的引用（除非实例不会销毁，比如对象方法返回自己，结束后对象还在，引用有效） A \u0026 func(){//这是错的，func执行完b会销毁，但这个回传的引用仍指向这个地址 A b; return b; } ","date":"2017-12-23","objectID":"/cpp-note/:15:0","tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/"},{"categories":["program"],"content":"5.1 const static 修饰类 static 在c中，修饰全部变量表示吧作用于限制在本文件内 修饰局部变量表示吧变量生命周期提升为全局 c++中在类内部，用来实现族类对象间的数据共享。 c++中，修饰类成员时，表示这个成员变量属于整个类，而不是某个对象（既属于类，也属于对象，但终归于类） static int a;//声明写在类内 int A::a=0;//初始化写在内外 修饰成员函数时，也属于整个类；因为他属于类，没有this指针（this只有对象实例有） //不能访问数据成员及成员，没有this static string getstr(); const static int h=0; //static const 修饰数据成员，必须在类内初始化；就地初始化 const 修饰数据成员，初始化位置只能在 参数列表里；（新版本虽然可以直接等于号初始化，但别被惯傻了） 修饰成员函数（注意不是修饰返回类型），位置放在声明之后，实现体之前，大概也没有别的地方可以放了（haha） const函数承诺不会修改数据成员，也只能调用其他const函数。 还可以构成重载（wtf？） 修饰类对象，从对象层面不修改成员，只能调用const成员函数，构成重载就是配饰有无const的对象的情况 即const对象只能调用const成员函数，非const对象优先调用非const成员函数（若无则调用const成员函数） ","date":"2017-12-23","objectID":"/cpp-note/:16:0","tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/"},{"categories":["program"],"content":"5.2 指向类成员的指针 //都指向非静态成员 \"成员类型 类名::* 指针名 = \u0026类名::成员名\" class stuu { void print(); private: int a; }; //指向数据成员 //在定义时必须和类关联，使用时必须和对象关联 int stuu::* pa=\u0026stuu::a; stuu dx; cout\u003c\u003cdx.*pa\u003c\u003cendl; //(内部实现，实际上时记录了偏移量) //指向函数成员 // void (stuu::*pf)()=\u0026stuu::print; (dx.*pf)(); tip://在类中想用常量时 enum{cnt=4};//因为用const必须参数列表初始化，static const 太浪费 ","date":"2017-12-23","objectID":"/cpp-note/:17:0","tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/"},{"categories":["program"],"content":"5.3 友元 友元可以是友元函数，友元类，异类才有友元（同类无私处） 友元是单方面的，你拿我当朋友不等于我也拿你当朋友(涩会涩会) 访问时必须通过 class A { friend void dis(A \u0026 t); friend class B; }; // 该函数可以访问A的私有成员 void dis(A \u0026 t);//访问时必须通过对象访问，因为他不是成员函数 // 该类可以访问A的私有成员 class B{void dis(A \u0026 t);}; ","date":"2017-12-23","objectID":"/cpp-note/:18:0","tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/"},{"categories":["program"],"content":"5.4 单双目运算符重载 //不能重载的运算符 . .* :: ?: sizeof //sizeof是运算符，不是函数 //除了=号外，基类中被重载的操作符都将被派生类继承 //“赋值运算符重载函数”不是不能被派生类继承，而是被派生类的默认“赋值运算符重载函数”给shadow了 //通常情况下，双目运算符重载为成员需要一个参数，重载为友元要两个参数，做成员时this也是参数 //重载-（负号）时用const修饰成员函数，-c=t就不会过编译了，这才是对的，注意-(-c)所以只能用const修饰成员函数而不是返回值。 // Clock operator++(Clock\u0026 c) //前置单目运算符 ++c Clock operator++(Clock\u0026 c,int) //后置单目运算符 c++ //day 6.2 //流输入输出运算符重载 istream \u0026 operator\u003e\u003e(istream\u0026,自定义类\u0026); ostream \u0026 operator\u003c\u003c(istream\u0026,const 自定义类\u0026); ","date":"2017-12-23","objectID":"/cpp-note/:19:0","tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/"},{"categories":["program"],"content":"5.5 类型转化 使用 类型转化构造器 //实现 其他类型 到 本类型 的转化 class 本类型 { 本类型(const 其他类型 \u0026 Ta) //这是一个构造器 [ //实现转化 //this-\u003edata = Ta.data ; ] }; 本类型 = 其他类型; //隐式转化可用 先调用类型转化，在调用赋值运算符重载 //我们把只有一个参数的构造器成为类型转化构造器 explicit //加在转化构造器前表示只能使用 显式转化 本类型 = static_cast\u003c本类型\u003e(其他类型); 使用 类型转换操作符函数 class 源类 { //无参无返回 operator 目标类型(void) { //根据需要进行转化 //目类标型.data = this-\u003edata; return 目标类型(this-\u003edata2,this.data2);//特殊，里面有返回, //实际也可以这么写 目标类型 swa; swa.data1 = this-\u003edata1; return swa; } }; ","date":"2017-12-23","objectID":"/cpp-note/:20:0","tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/"},{"categories":["program"],"content":"5.6 运算符重载提高篇 函数操作符()重载 – 仿函数 //把类对象当作函数名使用，主要应与于STL和模板 class 类名 { 返回值类型 operator() (参数类型) { } }; //lambda 本质就是仿函数 operator bool();//对象可以对void * 重载,if(A)情况，会调用bool(); operator void *();//对象可以对void * 重载，if(A)情况，没有bool()会调用void*(),然后void*被强转成bool; 重载 new delete new[] delete[] //定制化时使用，给特定类定制 void * operator new(size_t) void operator delete(void *) void * operator new[](size_t) void operator delete[](void *) //注：operator new 中 size_t 参数是编译器自动计算传递的 其实是 unsigned int //了解一下就行↓ #include \u003cmemory\u003eclass A{int a;}; auto_ptr\u003cA\u003e ptr(new A); //auto_ptr 类模板 auto_ptr\u003cA\u003e模板类 ptr-\u003ea=1; //一个对象的行为想指针，重载了 -\u003e () * //new被ptr托管后，不需要再关心delete的问题 ","date":"2017-12-23","objectID":"/cpp-note/:21:0","tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/"},{"categories":["program"],"content":"6.1 继承与派生Inherit\u0026Derive c++ 通过继承关系实现了代码的可重用性。 class 派生类名:继承方式 基类名 { }; //一个派生类可以有多个基类 //继承方式 public protected private /* 父类 公有继承 保护继承 私有继承 成员属性↘ public public protected private protected protected protected private private 不可访问 不可访问 不可访问（inaccessable） */ protected 对于外界访问属性来说等同于 private，但在派生类中可见 几点说明: * 可见不可见都全盘接收，除了构造器与析构器，基类可能会造成派生类的成员冗余，是需要设计的 * 派生类有了自己的个性，才有意义 派生类的构造器 类名(参数总列表) :父类名(父类构造器列表),自己的成员 { //在参数列表里调用父类构造器，然后再初始化自己的成员 //在父类中如果有标配，重载或默认，把无参的情况包含进来，子类可以不显式的调用父类构造器，隐式调用 } //初始化顺序，父类，其他类对象成员，本类的初始化 派生类的拷贝构造器 //子类未实现拷贝时，会调用父类构造器 //子类一旦实现拷贝构造，则必须显式的调用父类拷贝构造器 son(const son \u0026 another) :father(another) { // ↑↑↑赋值兼容（子类对象(引用或指针)可以赋给父类对象） this-\u003edata=another.data; } 派生类赋值重载 //子类中未实现赋值重载时，会调用父类的赋值重载 //子类一旦实现赋值重载，不会自动调用父类赋值重载 son\u0026 operator=(son\u0026 another) { //赋值兼容 father::operator=(another);//重载是会被子类继承的，所以可以调用。与构造器不同 this-\u003edata=another.data; } 重名问题 子类中会把父类中重名的成员shadow掉，只需要名字相同即可 尽量不要重名，否则，调用时加上命名空间 overload 重载 发生在同一作用域，函数名相同，参数列表不同（个数，类型，顺序） shadow 发生在父子类当中，只要函数名相同即可 派生类的友元函数 父类的友元函数，子类也可以调用 传参时子类赋值给了父类，赋值兼容 派生类的析构器 析构顺序：子类，成员，基类 与构造相反 多继承 你有n个爹（逃） 三角问题，多个父类中相同的成员，用到要加父类作用域 给调用者带来很大的不便 办法，提取相同成员到一个公共类M中，然后让被提取的类，分别继承这个公共类M（三角变成了四角） 但是子类还是无法访问这个成员，因为两个基类都继承了M，这个成员还是有两份 最终办法 虚继承 虚继承 virtual(加在继承方式前面) //上面的 M 就叫做 虚基类 //虚继承的意义：在多继承中，保存各个父类的多份同名成员，虽然有时是必要的，可以在不同数据成员中存放不同数据，但在大多数情况下 //是我们不希望出现的，因为保留多份数据成员的拷贝，不仅占用较多的存储空间，还增加了访问困难 //虚基类和虚继承，实现了在多继承中只保留一份共同（同名）成员。 //虚基类，需要抽象和设计，虚继承，是一种继承的扩展 //初始化问题，多继承的类中一定要调用虚基类的构造器，父类可以用默认 class A{ A(int i){} }; class B:virtual public A{ B(int n):A(n){} }; class C:virtual public A{ C(int n):A(n){} }; class D:public B,public C{ D(int n):A(n),B(n),C(n){}//结果有A()控制，其他配角 }; ","date":"2017-12-23","objectID":"/cpp-note/:22:0","tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/"},{"categories":["program"],"content":"7.1 多态PolyMorphism 男人不止一面（逃），几个相似但不完全相同的对象，收到同一个消息后，执行不同的操作 c++中所谓的多态是指，由继承而产生的相关的不同的类，其对象对同一消息会做出不同的响应 增加程序的灵活性，可以减轻系统升级，维护，调试的工作量和复杂度 赋值兼容（多态实现的前提） 赋值兼容规则 是指在需要基类对象的任何地方都可以使用 公有派生类(其他不行) 的对象来替代，赋值兼容是一种默认行为，不需要任何的显式步骤 派生类的对象可以赋值给基类对象 派生类的对象可以初始化基类的引用 派生类的对象的地址可以赋给指向基类的指针 只能使用基类原有的成员 多态形成的条件 静多态: 函数重载，也是一种多态现象，通过命名倾轧在编译阶段决定，故称静多态 动多态: 在运行阶段决定 条件是 父类中有虚函数 子类override(覆写)父类中的虚函数 用已被子类对象赋值的父类指针或引用（对象不行），调用共用接口（发生虚函数调用） 虚函数 class A { public: virtual void func();//只需在声明时加； }; //父类时有虚函数时，子类覆写override虚函数时（同名同参同返回），可以不加virtual，但建议加上 //将子类对象赋值给父类引用或指针时，用这个父类指针或引用访问的虚函数为子类的虚函数（如果有的话） //子类中虚函数的访问权限可以不和父类一致 //覆写范围是很大的，如果不覆写默认从父类继承 纯虚函数 class A { virtual void func()=0;//格式，没有实现体 }; //含有纯虚函数的类，称为抽象基类（java中叫interface），不可以实例化（A a; 不可以） //作用就是给族类提供接口用的,抽象基类不能实例化，但可以用指针和引用指向一个子类，实现多态 //抽象基类存在的意义就是被继承 //如果派生类中没有对该函数override，则这个函数在派生类中仍为纯虚函数，派生类仍为纯虚基类 含有虚函数的析构: 虚析构，就是为了delete基类指针时将子类对象析构完全 含有虚函数的类，析构函数也应该声明为虚函数 在delete父类指针的时候，会调用子类的析构函数，实现完整析构 当一个类中有虚函数的时候，请将析构器声明为vritual 若干限制 静态成员函数不能是虚函数，静态成员函数不受对象的捆绑，只有类的信息 内联函数，普通函数，不能是虚函数 构造函数不能是虚函数 析构函数通常声明为虚函数 设计模式 – 依赖倒置原则 //定义，高层模块不应该依赖底层模块，二者都应该依赖抽象 //抽象不应该依赖细节，细节应该依赖抽象 //核心：面向接口编程 ","date":"2017-12-23","objectID":"/cpp-note/:23:0","tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/"},{"categories":["program"],"content":"8.1 多态的实现原理 虚函数表 virtual table 类实例化时，内存最前面先放一个指向v-table的指针，然后是数据成员 v-table中，先放父类虚函数，再放子类虚函数 如果子类override了父类虚函数，则替换虚函数表相应位置的函数指针 多态实现的前题，一定是生成完了v-table之后，所以在父类构造器调用虚函数实现不了多态 ","date":"2017-12-23","objectID":"/cpp-note/:24:0","tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/"},{"categories":["program"],"content":"8.2 运行时类型信息RTTI run time type identificaition。运行时信息，来自于多态，所以一下运算符只用于基于多态的继承体系中 typeid运算符 //使用这个运算符 要包含头文件\u003ctypeinfo\u003e //返回包含数据信息的type_info对象引用 //type_info重载了==,!=来比较是否相等，函数name()返回类型名称 //type_info的拷贝赋值为私有，不可操作，只用来做调试 B b; cout\u003c\u003ctypeid(b).name()\u003c\u003cendl;//输出b信息 A * a=\u0026b; cout\u003c\u003ctypeid(*a).name()\u003c\u003cendl;//输出b信息 //可以帮你辨别一个指针到底指向谁，在多态中 ","date":"2017-12-23","objectID":"/cpp-note/:25:0","tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/"},{"categories":["program"],"content":"8.3 typecast static_cast\u003c\u003e() 在一个方向上可以做隐式转换，在另一个方向方向可以做静态转换 发生在编译阶段，不保证后续使用的正确性 用于父子类不安全 reinterpret_cast\u003c\u003e() 既不在编译期也不再运行期进行检查，安全性完全由程序员决定 dynamic_cast\u003c\u003e() 运行时的类型转换方法，检查指针所指类型，然后判断是否与要转换的类型有一种“is a”的关系 如果是，返回对象地址，不是返回null 只用于含有虚函数的父子类中 ","date":"2017-12-23","objectID":"/cpp-note/:26:0","tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/"},{"categories":["program"],"content":"9 c++模板 template //泛型（Generic Programming）：多种数据类型上皆可操作的含义 //语法格式 template\u003ctypename/class 类型参数表\u003e 返回类型 函数模板名(函数参数表) { 函数模板实现体 } template\u003ctypename T,typename T2....\u003e void swapp(T a,T b) { a^=b;b^=a;a^=b; } template\u003ctypename T\u003e class stackk{ stackk(); }; template\u003ctypename T\u003e stackk::stackk\u003cT\u003e() {} //定义实现分开时，都要顶着帽子，（写类时，函数在外部实现也要戴帽子，并且函数名后加\u003cT\u003e） //模板适用于参数个数相同，函数体相同的情况 //参数个数如果不同，不要使用模板 ","date":"2017-12-23","objectID":"/cpp-note/:27:0","tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/"},{"categories":["program"],"content":"10 C++ 流类综述 流类对象都重载了 \u003c\u003c 和 \u003e\u003e 输入输出IO流 IO对象的构造器和赋值重载是private，不能拷贝或赋值，使用时只能传引用或指针 IO对象是由缓冲区的，缓冲区写满或遇到endl才写入,(cin背后是键盘，cout背后是屏幕) endl,flush,unitbuf 都可以刷缓冲 标准输出 cout cerr clog //cout.unsetf(ios::dec); //cout.setf(ios::hex); //\u003ciomanip\u003e 流算子头文件,上面并不好用 //cout\u003c\u003ched\u003c\u003ca\u003c\u003cendl; 标准输入 cin //istream 成员函数 cin.get();//读一个字符返回，包括空格回车tab空字符 cin.get(buf,1024,'\\n'); cin.getline(buf,1024,'默认回车'); istream\u0026 ignore(streamsize n=1,int delim=EOF);//跳过n个或遇到delim为止，delim也被跳过 int peek();//窥视 当前指针不改动，返回内容（int 型），自己转char istream\u0026 putback(char c);//回推指针，并在此位置替换为c 文件IO流 ifstream ifile(\"1.txt\");//只能从文件读入 默认模式 ios::in if(!ifile)cout\u003c\u003c\"打开失败\"; ofstream ofile(\"2.txt\");//只能写到文件 默认模式 ios::out|ios::trunc //没有这个文件自动创建 fstream iofile(\"3.txt\");//默认模式 ios::in|ios::out|ios::app iofile.close();//刷缓冲区 ios::in ios::out //不会自动创建文件 ios::trunc //覆盖原来 会自动创建文件 ios::app //追加 会自动创建文件 ios::binary //二进制方式 ios::cur //文件当前位置 ios::end //文件末尾 f.seekg(50,ios::cur);//seekget 从当前位置向后50 f.seekp(-50,ios::end);//seekput 从文件尾向前50 //标识 f.eof();//达到文件尾，返回true f.bad();//读写过程出错，返回true f.fail();//除了和bad()一样，格式错误（例如想要读整数，得到字母），遇到eof都返回true f.good();//上面任何返回true，则返回false f.clear();//将所有标记位置位正常，不是清空流 cin.sync();//清空流 //遍历读，一个个读 char c; while(f.get(c),!f.eof()){ f2.put(c);//写入另一个文件 } //一行一行读 char buf[1024]; while(f.getline(buf,1024,'\\n'),!f.eof()){ f2\u003c\u003cbuf\u003c\u003cendl;//用get不会跳过\\n,用getline \\n被跳过，还要补； } //byte流读 ostream \u0026 write(const char * buffer,int len); istream \u0026 read(const char * buffer,int len); struct stu{ char name[100]; char sex; int age; }; stu s[5]= { {\"as\",'y',12}, {\"gg\",'x',1}, {\"rr\",'y',3}, {\"ww\",'x',100}, {\"qq\",'x',107} }; fstream f(\"asd.binary\",ios::in|ios::out|ios::trunc|ios::binary); //f.write(s,sizeof(s)); for(int i=0;i\u003c5;i++) { f.write((char *)\u0026s[i],sizeof(stu)); } f.seekg(0,ios::beg); stu tmp; while(f.read((char*)\u0026tmp,sizeof(stu)),!f.eof()){ cout\u003c\u003ctmp.name\u003c\u003cendl;; } ","date":"2017-12-23","objectID":"/cpp-note/:28:0","tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/"},{"categories":["program"],"content":"11 异常（EXCEPTION） //在可能出错的地方使用try-catch结构 void func(int x){ if(x\u003c0) throw -1;//在try下面调用的函数中可以抛出异常，终止程序往下执行 //程序立即转到上面捕获异常的地方 //异常传递是一个拷贝，如果自定义类型，注意拷贝构造， } try{ func(3); }catch(int e)//如果下方扔出的异常不是int型，将接不到，程序调用另一个函数，终止整个程序 {//可以自己写异常信息类型，这样能得到更多信息 cout\u003c\u003c\"catch a exception \"\u003c\u003ce\u003c\u003cendl; }//catch执行完毕，继续执行后面的语句，如果没有匹配，系统调用terminate终止程序 //可以有多个catch catch(...){ //如果上面都没有接到，这个来接，有这个的时候，系统就不会调用terminate } //如果有多层try-catch结构，底层抛出一个异常，上层没有人接的话，继续传给上上层 //如果直到尽头都没有人接，系统才调用terminate //为了加强程序的可读性，可以在函数声明中列出可能抛出的所有异常类型 //例如： void func() throw(int ,A ,B ,double);//括号没内容表示不抛出异常 //栈自旋 throw抛出异常时，会在离开栈空间时销毁栈，不执行后面的代码，但看作函数执行完毕，退出销毁 //这也是为什么throw不传引用的原因 ===========================华丽的分割线=================================== 全剧终。。。 至此你看完了大部分c++ 没错，是看！！！ ","date":"2017-12-23","objectID":"/cpp-note/:29:0","tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/"},{"categories":["program"],"content":"*注：图片来自贺利坚老师C语言及程序设计初步教程的课件中 教程地址：http://edu.csdn.net/course/detail/271 ","date":"2016-06-19","objectID":"/c-data-type/:0:0","tags":["c"],"title":"C数值数据类型","uri":"/c-data-type/"}]