<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>program - 分类 - kirito&#39;s blog</title>
        <link>https://www.kirito41dd.cn/categories/program/</link>
        <description>program - 分类 - kirito&#39;s blog</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sat, 17 Jul 2021 18:13:04 &#43;0800</lastBuildDate><atom:link href="https://www.kirito41dd.cn/categories/program/" rel="self" type="application/rss+xml" /><item>
    <title>Go反射: 将切片按指定大小分块</title>
    <link>https://www.kirito41dd.cn/slice-chunking-in-go/</link>
    <pubDate>Sat, 17 Jul 2021 18:13:04 &#43;0800</pubDate>
    <author>kirito</author>
    <guid>https://www.kirito41dd.cn/slice-chunking-in-go/</guid>
    <description><![CDATA[<h2 id="背景">背景</h2>
<p>在写代码过程中，有时候需要做一些批量 查询/操作，往往会涉及将一个很大的数组或切片进行分块。</p>
<p>比如我们有一个存着id的数组，要根据id请求某个接口查询信息，这个接口支持批量查询，但是每次查询的数量上限是100。最好的做法是每次从数组中取最多100个id，进行批量查询，直到遍历完数组。</p>
<p>这个操作不复杂，可以简单的用循环实现，但是每次遇到这种场景都需要写一次代码，有点写吐了。所以就想写一个函数，可以将<code>[]T</code>按需求拆分成<code>[][]T</code>。</p>
<p>但是go的泛型还没有来，所以只能用反射来搞了。</p>
<p><del>献祭我的周六饭后时光</del></p>
<h2 id="成果">成果</h2>
<p>传入<code>[]T</code>，<code>T</code>可以是任意类型，按指定大小分块，返回<code>[][]T</code>。</p>
<p>例子中将<code>[0,1,2,3,4,5,6,7,8,9]</code>划分成了<code>[0,1,2]</code>、<code>[3,4,5]</code>、<code>[6,7,8]</code>、<code>[9]</code></p>
<p><a href="https://github.com/kirito41dd/xslice" target="_blank" rel="noopener noreffer">https://github.com/kirito41dd/xslice</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;github.com/kirito41dd/xslice&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">s</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">}</span>
	<span class="nx">i</span> <span class="o">:=</span> <span class="nx">xslice</span><span class="p">.</span><span class="nf">SplitToChunks</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
	<span class="nx">ss</span> <span class="o">:=</span> <span class="nx">i</span><span class="p">.([][]</span><span class="kt">int</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">ss</span><span class="p">)</span> <span class="c1">// [[0 1 2] [3 4 5] [6 7 8] [9]]
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="代码实现">代码实现</h2>
<p>反射一把梭，自然离不了可爱的<code>interface{}</code></p>
<p>欢迎复制或引包<code>github.com/kirito41dd/xslice</code>使用，如果以后搬砖遇到其他场景，也会继续扩充。</p>
<p>还是期待go泛型早点到来（<del>那时候我rust应该已经很6了吧</del></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">SplitToChunks</span><span class="p">(</span><span class="nx">slice</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">chunkSize</span> <span class="kt">int</span><span class="p">)</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
	<span class="nx">sliceType</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">(</span><span class="nx">slice</span><span class="p">)</span>
	<span class="nx">sliceVal</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">slice</span><span class="p">)</span>
	<span class="nx">length</span> <span class="o">:=</span> <span class="nx">sliceVal</span><span class="p">.</span><span class="nf">Len</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">sliceType</span><span class="p">.</span><span class="nf">Kind</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Slice</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;parameter must be []T&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">if</span> <span class="nx">length</span><span class="o">%</span><span class="nx">chunkSize</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">n</span> <span class="p">=</span> <span class="mi">1</span>
	<span class="p">}</span>
	<span class="nx">SST</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">MakeSlice</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nf">SliceOf</span><span class="p">(</span><span class="nx">sliceType</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">length</span><span class="o">/</span><span class="nx">chunkSize</span><span class="o">+</span><span class="nx">n</span><span class="p">)</span>
	<span class="nx">st</span><span class="p">,</span> <span class="nx">ed</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">st</span> <span class="p">&lt;</span> <span class="nx">length</span> <span class="p">{</span>
		<span class="nx">ed</span> <span class="p">=</span> <span class="nx">st</span> <span class="o">+</span> <span class="nx">chunkSize</span>
		<span class="k">if</span> <span class="nx">ed</span> <span class="p">&gt;</span> <span class="nx">length</span> <span class="p">{</span>
			<span class="nx">ed</span> <span class="p">=</span> <span class="nx">length</span>
		<span class="p">}</span>
		<span class="nx">SST</span> <span class="p">=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">Append</span><span class="p">(</span><span class="nx">SST</span><span class="p">,</span> <span class="nx">sliceVal</span><span class="p">.</span><span class="nf">Slice</span><span class="p">(</span><span class="nx">st</span><span class="p">,</span> <span class="nx">ed</span><span class="p">))</span>
		<span class="nx">st</span> <span class="p">=</span> <span class="nx">ed</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">SST</span><span class="p">.</span><span class="nf">Interface</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div>]]></description>
</item><item>
    <title>Rust所有权与借用</title>
    <link>https://www.kirito41dd.cn/rust-ownership-and-borrowing/</link>
    <pubDate>Sat, 10 Jul 2021 18:50:44 &#43;0800</pubDate>
    <author>kirito</author>
    <guid>https://www.kirito41dd.cn/rust-ownership-and-borrowing/</guid>
    <description><![CDATA[<p>学习笔记，对标cpp理解下rust所有权以及借用的概念，顺便提下比较特殊的切片(DST)</p>
<h2 id="所有权ownership"><strong><ruby>所有权<rt>Ownership</rt></ruby></strong></h2>
<p>rust中每个值都有一个所有者变量，并且同一时间只有能一个所有者，当值的所有者变量超出作用域，值的内存会被释放。</p>
<p>下面的代码<code>String</code>的所有权从<code>s1</code>转移到了<code>s2</code>，发生了<strong>Move</strong>，此时再访问<code>s1</code>是非法的。<a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#ways-variables-and-data-interact-move" target="_blank" rel="noopener noreffer">参考</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">s2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s1</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>下面的代码<code>i32</code>的所有权<strong>没有</strong>从<code>x</code>转移到<code>y</code>，而是<code>y</code>复制了<code>x</code>，发生了<strong>Copy</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">x</span>: <span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>Move本质上也是浅拷贝：比如<code>String</code>内部实现是有一个指针指向了保存的字符串，所有权转移，其实只是拷贝了这个指针的值，并没有拷贝这个字符串。这时<code>s1</code>和<code>s2</code>的内存空间都保存着这个指针地址，由于所有权的存在，编译器保证了访问<code>s1</code>是非法的，所以<code>s1</code>虽然还指向字符串，但是什么都做不了，保证了安全。</p>
<p>关于内存释放：由于只有在所有者生命完结后，才会发生释放，所有权保证同一时间只有一个所有者，所以字符串所在地址并不会被<strong><ruby>释放两次<rt>double free</rt></ruby></strong>。</p>
<p>这里我想对标cpp：cpp实现类似高效转移使用的是右值引用与移动构造函数。在<code>s2</code>的移动构造函数中把<code>s1</code>的指针偷过来，然后把<code>s1</code>的指针指向一个空字符串的地址或标记其无效。<code>s1</code>是作为右值引用传过来的，在语义上是将亡值，所以可以修改<code>s1</code>内部结构。但是，cpp没有所有权概念，编译器不会阻止你继续访问<code>s1</code>。<del>这很安全（个屁</del></p>
<p>rust在什么情况下Move什么情况下Copy，取决于类型是否实现了<code>Copy</code>Trait。上面<code>i32</code>本来已经很小了，也没东西可以浅拷贝（就4个字节折腾啥），所以<code>i32</code>是拷贝语义。</p>
<p>rust基本类型几乎都实现了<code>Copy</code>Trait：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="nb">Copy</span>: <span class="nb">Clone</span> <span class="p">{</span><span class="w">
</span><span class="w"></span><span class="c1">// Empty. 只是个Marker
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>对于tuple、array，如果元素都实现了<code>Copy</code>，也会传拷贝。对于复杂类型，如果一个类型的某个部分实现了<code>Drop</code>Trait，那么这个类型无法实现<code>Copy</code>；如果组成部分都实现了<code>Copy</code>，复杂类型也可以实现<code>Copy</code>。</p>
<p>所有权转移可以发生在赋值、传参、函数返回。</p>
<h2 id="引用references借用borrowing"><strong><ruby>引用<rt>references</rt></ruby></strong>&amp;<strong><ruby>借用<rt>borrowing</rt></ruby></strong></h2>
<p>下面的代码中<code>b</code>并没有拿走所有权，而是通过<code>&amp;</code>取得了<code>a</code>的引用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;123&#34;</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>b</code>是对<code>a</code>的引用也可以描述为<code>b</code>借用了<code>a</code>，rust引用的底层可以对标为其他语言中的指针，只不过rust的引用带了生命周期和借用检查所以很安全。如cpp中的指针只是记录值了一个内存地址，与一个整型并没有啥差别，可以被保存被带到任何地方，容易发生内存泄漏。而rust编译器会保证引用的生命周期不会超过其指向的值的生命周期。</p>
<p>引用分为<strong><ruby>不可变引用<rt>immutable references</rt></ruby></strong>与<strong><ruby>可变引用<rt>mutable references</rt></ruby></strong>，获取可变引用使用<code>let b = &amp;mut a</code>，前提是<code>a</code>是可变的才能获取可变引用，可变引用与不可变引用的关系类似读写锁：</p>
<ol>
<li>可以同时存在多个不可变引用(读锁)</li>
<li>可变引用与不可变引用不能同时存在(读、写锁互斥)</li>
<li>只能同时有一个可变引用(写锁)</li>
</ol>
<h3 id="切片slice"><strong><ruby>切片<rt>slice</rt></ruby></strong></h3>
<p>切片很特殊，用来引用数组中的连续元素序列。</p>
<ol>
<li><strong><ruby>字符串切片<rt>string slices</rt></ruby></strong> - <code>&amp;str</code>
<ul>
<li><code>let s = String::from(&quot;hello world&quot;); let hello = &amp;s[0..5];</code></li>
<li><code>let s: &amp;str = &quot;xxx&quot;; let s2: &amp;str = &amp;s[..];</code></li>
<li>字符串切片特殊点是范围只能取有效的utf8字符边界</li>
</ul>
</li>
<li>数组切片 - <code>&amp;[T]</code>
<ul>
<li><code>let a = [1, 2, 3, 4, 5];  let slice = &amp;a[1..3];</code></li>
</ul>
</li>
</ol>
<p>切片用[start..end]来确定引用范围，区间左闭右开<code>[start,end)</code>。范围还可以简写为<code>[..2]</code>、<code>[3..]</code>、<code>[..]</code>，省略表示取边界。</p>
<p>切片是个胖指针，会保存目标集合的指针，与引用范围。</p>
<p>切片之所以特殊，需要说下rust的<strong><ruby>动态大小类型<rt>Dynamic Sized Type,DST</rt></ruby></strong>，DST表示编译期无法获取大小的类型。</p>
<p>从数组说起，数组的类型表示为<code>[T; N]</code>，<code>T</code>是元素类型而<code>N</code>是元素个数，所以数组的大小编译期是可以确定的，数组不是DST。注意<code>&amp;[i32; 3]</code>是一个普通的数组引用，而<code>&amp;[i32]</code>才是一个数组切片。</p>
<p><strong>切片是DST</strong>，准确来说<code>[i32]</code>才叫做切片，<code>[T]</code>这种类型表示由<code>T</code>组成的切片，这个切片的长度在编译期是不确定的（DST），编译器无法为一个不确定大小的类型分配空间，所以也无法声明DST类型的变量，只能用胖指针<code>&amp;[T]</code>来引用。</p>
<p><code>&amp;[T]</code>的大小是固定的，里面有用于存储数据地址和长度的空间，这样就可以在运行时获取长度信息。比如要制造切片<code>[1..n]</code>，n的大小是编译期间无法得到的，所以只能在运行期间计算n的值，然后初始化胖指针完成引用。</p>
<p>字符串切片<code>str</code>也是DST，对应胖指针是<code>&amp;str</code>，可以把<code>str</code>理解为<code>[T]</code>的特殊形式，主要是用来表示utf8字符串。</p>
<p>除了切片，<code>dyn Trait</code>(Trait对象)也是DST，对应的胖指针是<code>&amp;dyn Trait</code>。（只要是DST类型，就无法声明对应类型变量</p>
]]></description>
</item><item>
    <title>Read Copy Update</title>
    <link>https://www.kirito41dd.cn/read-copy-update/</link>
    <pubDate>Mon, 28 Jun 2021 21:05:43 &#43;0800</pubDate>
    <author>kirito</author>
    <guid>https://www.kirito41dd.cn/read-copy-update/</guid>
    <description><![CDATA[<p><strong><ruby>RCU<rt>Read Copy Update</rt></ruby></strong>这个词最近才听到，是在公司一位老哥的直播分享里听到的。那天在群里没事乱划，突然看到一个直播分享，原本就想进去嫖一眼，结果内容异常硬核，从头看到尾。</p>
<p>topic是用类似<strong><ruby>JIT<rt>Just In Time</rt></ruby></strong>的方式加速Go的json解析，这里顺便给他们打个广告，这个库开源了：<a href="https://github.com/bytedance/sonic" target="_blank" rel="noopener noreffer">https://github.com/bytedance/sonic</a></p>
<p>分享里提到了RCU这种技术，RCU原本是Linux内核中的一种同步机制，并且其针对的场景是读多写少。分享里他们遇到的场景是需要实现一个buffer，特性是：</p>
<ol>
<li>读操作<strong>远多</strong>于写操作</li>
<li>希望读操作无锁、无等待</li>
</ol>
<p>这样的场景非常适合使用RCU这种技术，RCU的基本实现是：</p>
<ol>
<li>
<p>读使用原子操作读取数据指针，无锁、无等待</p>
</li>
<li>
<p>写/更新操作用互斥锁防护</p>
</li>
<li>
<p>不直接写/更新，而是先复制一份，对复制的数据进行写/更新</p>
</li>
<li>
<p>通过原子操作将数据指针指向刚修改过的副本</p>
<p><small>注：由于可能涉及资源释放，所以在有GC的语言上更容易实现</small></p>
</li>
</ol>
<p>本质上就是牺牲写性能，提升读性能</p>
<p>代码也非常简单，只用互斥锁和一个原子变量就可以实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">RCU</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">m</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
    <span class="nx">p</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">RCU</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">key</span> <span class="nx">K</span><span class="p">)</span> <span class="nx">V</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="nx">Map</span><span class="p">[</span><span class="nx">K</span><span class="p">]</span><span class="nx">V</span><span class="p">)(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">r</span><span class="p">.</span><span class="nx">p</span><span class="p">))[</span><span class="nx">key</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">RCU</span><span class="p">)</span> <span class="nf">Put</span><span class="p">(</span><span class="nx">key</span> <span class="nx">K</span><span class="p">,</span> <span class="nx">val</span> <span class="nx">V</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">r</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
    <span class="k">defer</span> <span class="nx">r</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
    <span class="nx">newm</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">Map</span><span class="p">[</span><span class="nx">K</span><span class="p">]</span><span class="nx">V</span><span class="p">)</span>
    <span class="nx">atomic</span><span class="p">.</span><span class="nf">StorePointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">r</span><span class="p">.</span><span class="nx">p</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">newm</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>简单说一下，代码中<code>Map</code>、<code>K</code>、<code>V</code>都是虚拟的，可以根据需要更换（也不局限于KV）。</p>
<p>主要思想是通过原子操作，来更换指针指向的地址。</p>
<p>对于读，每次都会读出一个安全的数据地址，不会有其他线程修改这段数据，所以无需同步手段。</p>
<p>对于写，同时只能有一个写，否则存在丢失更新，所以加互斥锁防护。</p>
<p>由于写都是在拷贝上进行，所以不会影响读的性能</p>
<p>NICE！！！</p>
]]></description>
</item><item>
    <title>Ctrl&#43;C与Kill杀死进程的区别</title>
    <link>https://www.kirito41dd.cn/different-from-ctrl-c-and-kill/</link>
    <pubDate>Fri, 07 May 2021 20:11:26 &#43;0800</pubDate>
    <author>kirito</author>
    <guid>https://www.kirito41dd.cn/different-from-ctrl-c-and-kill/</guid>
    <description><![CDATA[<p>在linux系统中，通过bash中输入<code>&lt;Ctrl+C&gt;</code>或者使用命令<code>kill -9 $pid</code>都可以杀死进程，但是它们有很大的不同。</p>
<p>先放结论：<strong>kill命令只会杀死目标进程，而bash快捷键则会杀死整个前台进程组！</strong></p>
<h2 id="linux杀进程方式">linux杀进程方式</h2>
<p>不管使用那种方式，杀死进程都是通过发送信号（signal）来完成的，kill命令其实就是向目标pid进程发送信号：</p>
<ul>
<li><code>kill -9</code> - 发送<code>SIGKILL</code></li>
<li><code>kill -2</code> - 发送<code>SIGINT</code></li>
<li><code>kill -15</code> - 发送<code>SIGTERM</code></li>
</ul>
<p>完整列表如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># kill -l</span>
HUP INT QUIT ILL TRAP ABRT EMT FPE KILL BUS SEGV SYS PIPE ALRM TERM URG STOP TSTP CONT CHLD TTIN TTOU IO XCPU XFSZ VTALRM PROF WINCH INFO USR1 USR2
</code></pre></td></tr></table>
</div>
</div><p>bash快捷键发送信号方式如下：</p>
<ul>
<li>INT - <code>&lt;Ctrl+C&gt;</code></li>
<li>KILL - <code>&lt;Ctrl+\&gt;</code></li>
</ul>
<h2 id="前台进程组">前台进程组</h2>
<p>会话是一个或多个进程组的集合，每登陆一个终端就相当于一个新会话，一个会话可以有一个前台进程组和多个后台进程组。</p>
<p>默认通过bash启动的程序，都会放在前台进程组，包括这个程序的子进程。</p>
<p>如果要放在后台进行组，可以使用<code>&amp;</code>指定</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nb">echo</span> <span class="m">123</span> <span class="p">&amp;</span>            
</code></pre></td></tr></table>
</div>
</div><p>（另外，只有前台启动才会绑定标准输入输出。）</p>
<p>在bash中通过<code>&lt;Ctrl+C&gt;</code>或<code>&lt;Ctrl+\&gt;</code>杀死进程，信号会被发送至前台进程组中的每一个进程。</p>
<p>而通过kill杀死程序，信号只会发送给目标pid进程。</p>
<h2 id="验证">验证</h2>
<p>程序1:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;time&#34;</span>
    <span class="s">&#34;os/exec&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="nx">cmd</span> <span class="o">:=</span> <span class="nx">exec</span><span class="p">.</span><span class="nf">Command</span><span class="p">(</span><span class="s">&#34;sleep&#34;</span><span class="p">,</span> <span class="s">&#34;100000&#34;</span><span class="p">)</span>
    <span class="nx">cmd</span><span class="p">.</span><span class="nf">Start</span><span class="p">()</span>
    <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">99999</span><span class="p">)</span>
    <span class="k">return</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上面的程序启动子进程运行sleep命令，然后睡眠。</p>
<p>测试结果：</p>
<ul>
<li>用 kill -9、-2、-15 分别杀死主进程，sleep子进程存活。</li>
<li>用 <code>&lt;Ctrl+C&gt;</code>、<code>&lt;Ctrl+\&gt;</code>分别杀死主进程，sleep子进程被杀。</li>
</ul>
<p>程序2</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span><span class="p">(</span>
    <span class="s">&#34;time&#34;</span>
    <span class="s">&#34;os/exec&#34;</span>
    <span class="s">&#34;syscall&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="nx">cmd</span> <span class="o">:=</span> <span class="nx">exec</span><span class="p">.</span><span class="nf">Command</span><span class="p">(</span><span class="s">&#34;sleep&#34;</span><span class="p">,</span> <span class="s">&#34;100000&#34;</span><span class="p">)</span>
    <span class="c1">// 将子进程放入新的进程组
</span><span class="c1"></span>    <span class="nx">cmd</span><span class="p">.</span><span class="nx">SysProcAttr</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">syscall</span><span class="p">.</span><span class="nx">SysProcAttr</span><span class="p">{</span><span class="nx">Setpgid</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">Pgid</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
    <span class="nx">cmd</span><span class="p">.</span><span class="nf">Start</span><span class="p">()</span>
    <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">99999</span><span class="p">)</span>
    <span class="k">return</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上面的程序同程序1一样，区别是给子进程设置了单独的进程组（此时子进程就不在前台进程组中了）。</p>
<p>测试结果：</p>
<ul>
<li>用 kill -9、-2、-15 分别杀死主进程，sleep子进程存活。</li>
<li>用 <code>&lt;Ctrl+C&gt;</code>、<code>&lt;Ctrl+\&gt;</code>分别杀死主进程，sleep子进程存活！</li>
</ul>
]]></description>
</item><item>
    <title>Go中的引用变量</title>
    <link>https://www.kirito41dd.cn/reference-variable-in-go/</link>
    <pubDate>Tue, 13 Apr 2021 12:44:34 &#43;0800</pubDate>
    <author>kirito</author>
    <guid>https://www.kirito41dd.cn/reference-variable-in-go/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://blog-1256556944.file.myqcloud.com/public/rustgo2.png" referrerpolicy="no-referrer">
            </div><p>Go语言的函数参数传递，只有值传递，没有引用传递。Slice、Map 只是胖指针，在传参时同样是值传递。</p>
<p>除了函数传参，range Slice、range Map 也是按值拷贝，并不能取得容器里内容的引用。</p>
<p>Go里面有没有引用的概念呢？我的答案是有，而且只有<strong>一种</strong>情况体现了引用的概念：<strong>闭包变量按引用捕获</strong>。</p>
<p>分析下面代码：<a href="https://goplay.space/#qOIAgIWxtub" target="_blank" rel="noopener noreffer">在线运行</a> 或 <a href="https://play.golang.org/" target="_blank" rel="noopener noreffer">playground</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">gen</span><span class="p">()</span> <span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="kt">int</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">a</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">return</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
			<span class="nx">a</span><span class="o">++</span>
			<span class="k">return</span> <span class="nx">a</span>
		<span class="p">},</span>
		<span class="kd">func</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
			<span class="nx">a</span><span class="o">++</span>
			<span class="k">return</span> <span class="nx">a</span>
		<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">f1</span><span class="p">,</span> <span class="nx">f2</span> <span class="o">:=</span> <span class="nf">gen</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">f1</span><span class="p">())</span> <span class="c1">// 1
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">f2</span><span class="p">())</span> <span class="c1">// 2
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>闭包函数f1和f2都捕获了变量a，f1运行后影响了f2的结果，说明两个闭包函数都是捕获的a的引用。</p>
<p>实现上来讲，应该是函数值f1和f2都指向同一个闭包环境，因次f1对a的修改对f2也是可见的。</p>
<p>从结果上来看，两个闭包函数都有对同一个闭包环境里变量a的引用。</p>
]]></description>
</item><item>
    <title>crud boy</title>
    <link>https://www.kirito41dd.cn/crud-boy/</link>
    <pubDate>Thu, 01 Apr 2021 11:13:17 &#43;0800</pubDate>
    <author>kirito</author>
    <guid>https://www.kirito41dd.cn/crud-boy/</guid>
    <description><![CDATA[<p>记录下日常搬砖过程中的踩坑和学到的骚操作，随缘更新。</p>
<h2 id="mysql">MySQL</h2>
<ul>
<li>mysql中字符串类型索引查询时必须加引号，不然不会使用索引。原因是不支持函数索引，不加引号会使用了cast函数做隐式类型转换。(这里一般是int到string的cast</li>
<li>有时候写子查询嵌套非常多，可以使用<code>with as</code>优化可读性，装逼点这玩意叫<strong><ruby>公用表表达式<rt>common table expression,CTE</rt></ruby></strong>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">with</span> <span class="n">t1</span> <span class="k">as</span> <span class="p">(</span><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">xxx</span><span class="p">)</span>
<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t1</span><span class="p">;</span> <span class="c1">-- 必须紧跟着就使用,不用就销毁了
</span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="on-conflict">On Conflict</h3>
<p>遇到的场景是去优化有大量的数据需要upsert的场景：数据不存在就插入，数据存在就更新。接手时的实现是每次都做两次网络io，先判断是否存在，然后做更新操作。为了节省大量的io时间，我开始寻求更好的解决方案。</p>
<p>刚开始的思路是找类似redis pipline的方式：构造一个pipline，往里面赛语句，然后exec，才会发生网络io，redis服务器会按顺序执行所有语句。这和在mysql里用拼接多条语句很类似，发现只能实现批量插入，因为upsert还有一个判断逻辑。</p>
<p>最终开始求助我司内部大佬：得出的结论是使用Conflict.</p>
<blockquote>
<p><a href="https://gorm.io/docs/create.html#Upsert-On-Conflict">https://gorm.io/docs/create.html#Upsert-On-Conflict</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sql" data-lang="sql"><span class="c1">-- MERGE INTO &#34;users&#34; USING *** WHEN NOT MATCHED THEN INSERT *** WHEN MATCHED THEN UPDATE SET &#34;name&#34;=&#34;excluded&#34;.&#34;name&#34;; SQL &gt; Server
</span><span class="c1">-- INSERT INTO &#34;users&#34; *** ON CONFLICT (&#34;id&#34;) DO UPDATE SET &#34;name&#34;=&#34;excluded&#34;.&#34;name&#34;, &#34;age&#34;=&#34;excluded&#34;.&#34;age&#34;; PostgreSQL
</span><span class="c1"></span><span class="k">INSERT</span> <span class="k">INTO</span> <span class="o">`</span><span class="n">users</span><span class="o">`</span> <span class="o">***</span> <span class="k">ON</span> <span class="n">DUPLICATE</span> <span class="k">KEY</span> <span class="k">UPDATE</span> <span class="o">`</span><span class="n">name</span><span class="o">`=</span><span class="k">VALUES</span><span class="p">(</span><span class="n">name</span><span class="p">),</span><span class="o">`</span><span class="n">age</span><span class="o">=</span><span class="k">VALUES</span><span class="p">(</span><span class="n">age</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div></blockquote>
<p>原理是利用唯一键的冲突，在发生冲突时做更新操作。</p>
<ul>
<li>利用冲突做大批量upsert操作
<ul>
<li>拼sql,尝试一次插入多列，定义冲突时更新的字段</li>
<li>表中必须存在唯一键(primary key 或 unique key)才能使用</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">INSERT</span> <span class="k">INTO</span> <span class="o">`</span><span class="n">users</span><span class="o">`</span> <span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
<span class="k">VALUES</span>  <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&#34;jinzhu1&#34;</span><span class="p">),</span>
        <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&#34;jinzhu2&#34;</span><span class="p">)</span>
<span class="k">ON</span> <span class="n">DUPLICATE</span> <span class="k">KEY</span> <span class="k">UPDATE</span> <span class="o">`</span><span class="n">name</span><span class="o">`</span> <span class="o">=</span> <span class="k">VALUES</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><center>
真・金柱大佬亲传(
<p></p>
</center>
<h2 id="es">ES</h2>
<ul>
<li>es创建mapping踩坑,<code>text</code>会把索引字段分词，搜索用match而不能用term，<code>keyword</code>不会进行分词</li>
</ul>
<h3 id="totalhits--hits">TotalHits != Hits</h3>
<p>es查询结果，<code>searchResult.TotalHits()</code>与<code>len(searchResult.Hits.Hits)</code>不一致，<a href="https://stackoverflow.com/questions/54769677/why-searchresult-totalhits-is-different-than-lensearchresult-hits-hits" target="_blank" rel="noopener noreffer">原因</a></p>
<p>下面的代码panic了，以为<code>TotalHits &gt; 0</code>就肯定<code>Hits</code>里有数据，结果数组长度是0，访问越界。</p>
<p></p>
<p><code>TotalHits</code>是本次查询命中了多少记录，<code>Hits</code>里是实际返回的数据，由于分片的查询队列满了，所以没有查询到任何数据。
<code>searchResult.Shards.Failures</code>里有报错信息：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-txt" data-lang="txt">rejected execution of 
org.elasticsearch.transport.TcpTransport$RequestHandler@xxx 
on EsThreadPoolExecutor
[
    search, queue capacity = 1000, 
    org.elasticsearch.common.util.concurrent.EsThreadPoolExecutor@xxx
    [
        Running, pool size = 13, active threads = 13, 
        queued tasks = 1000, completed tasks = 919466345
    ]
]
</code></pre></td></tr></table>
</div>
</div><h2 id="hive">Hive</h2>
<ul>
<li>hive里也可以使用<code>with as</code>，注意区分和临时表的区别，临时表储存在磁盘的临时区中，只有数据库连接断开，或者drop掉才会消失</li>
</ul>
<h3 id="创建变量">创建变量</h3>
<p>在mysql创建和使用变量可以这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">set</span> <span class="o">@</span><span class="n">id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">xxx</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="o">@</span><span class="n">id</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>在hive里可以这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">set</span> <span class="nb">date</span> <span class="o">=</span> <span class="s1">&#39;xxx&#39;</span><span class="p">;</span>
<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">xxx</span> <span class="k">where</span> <span class="nb">date</span> <span class="o">=</span> <span class="err">${</span><span class="n">hiveconf</span><span class="p">:</span><span class="nb">date</span><span class="err">}</span>
</code></pre></td></tr></table>
</div>
</div>]]></description>
</item><item>
    <title>MySQL操作手册(个人笔记)</title>
    <link>https://www.kirito41dd.cn/mysql-operation-manual/</link>
    <pubDate>Tue, 19 Mar 2019 20:39:20 &#43;0800</pubDate>
    <author>kirito</author>
    <guid>https://www.kirito41dd.cn/mysql-operation-manual/</guid>
    <description><![CDATA[<p>此文为个人笔记，大学时候的总结难免有错，<del>不代表本人目前水平</del>[手动doge] (by 2021)</p>
<p>本来这总结已经被我从网络上删除了，看在可能是本文迄今为止唯一读者老田园的份上重新发布，方便老人查阅。</p>
<h1 id="mysql操作手册">MySQL操作手册</h1>
<ul>
<li>MySQL命令不区分大小写</li>
<li>空格符复制有时会出现格式错误，删掉空格再自己打一个</li>
<li>`(反引号)是转义字符，当你自定义名字和关键字冲突可以 `name` 括起来</li>
</ul>
<h2 id="1-mysql安装">1 MySQL安装</h2>
<h3 id="11-linux安装">1.1 linux安装</h3>
<ul>
<li>Ubuntu下用apt，Centos用yum</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">sudo apt‐get install mysql‐server
sudo apt‐get install mysql‐client
sudo apt‐get install libmysqlclient‐dev
</code></pre></td></tr></table>
</div>
</div><p>配置文件目录  <code>  /etc/mysql/mysql.conf.d/mysqld.cnf</code></p>
<h3 id="12-密码修改">1.2 密码修改</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">kirito@host:~$ mysqladmin ‐u用户名 ‐p旧密码 password 新密码
kirito@host:~$ mysqladmin ‐uroot ‐p111111 password <span class="m">123456</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>如果修改不了，<code>sudo mysql -uroot</code>，进入数据库</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">update</span> <span class="n">mysql</span><span class="p">.</span><span class="k">user</span> <span class="kt">set</span> <span class="n">authentication_string</span><span class="o">=</span><span class="nf">PASSWORD</span><span class="p">(</span><span class="s1">&#39;newPwd&#39;</span><span class="p">),</span> <span class="n">plugin</span><span class="o">=</span><span class="s1">&#39;mysql_native_password&#39;</span> <span class="k">where</span> <span class="k">user</span><span class="o">=</span><span class="s1">&#39;root&#39;</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">flush</span> <span class="k">privileges</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="13-mysql登陆">1.3 MySQL登陆</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">kirito@host:~$ mysql ‐h数据库服务器安装的主机 ‐P数据库端口 ‐u账户 ‐p密码
kirito@host:~$ mysql ‐h127.0.0.1 ‐P3306 ‐uroot ‐p123456
</code></pre></td></tr></table>
</div>
</div><h2 id="2-数据库基础">2 数据库基础</h2>
<h3 id="21-库操作">2.1 库操作</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="c1"># 查看数据库服务器存在哪些数据库
</span><span class="c1"></span><span class="k">SHOW</span>  <span class="k">DATABASES</span><span class="p">;</span>
<span class="c1"># 使用指定的数据库
</span><span class="c1"></span><span class="k">USE</span> <span class="n">database_name</span><span class="p">;</span>
<span class="c1"># 查看指定的数据库中有哪些数据表
</span><span class="c1"></span><span class="k">SHOW</span> <span class="kp">TABLES</span><span class="p">;</span>

<span class="c1"># 创建指定名称的数据库
</span><span class="c1"></span><span class="k">CREATE</span> <span class="k">DATABASE</span> <span class="n">database_name</span><span class="p">;</span>
<span class="c1"># 删除数据库
</span><span class="c1"></span><span class="k">DROP</span> <span class="k">DATABASE</span> <span class="n">database_name</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="22-表操作">2.2 表操作</h3>
<ul>
<li>创建一个表</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="err">表名</span><span class="p">(</span>
   <span class="err">列名</span><span class="mi">1</span>    <span class="err">列的类型</span>   <span class="p">[</span><span class="err">属性约束</span><span class="p">],</span>
   <span class="err">列名</span><span class="mi">2</span>    <span class="err">列的类型</span>   <span class="p">[</span><span class="err">属性约束</span><span class="p">],</span>
   <span class="p">....</span>
   <span class="err">列名</span><span class="n">N</span>    <span class="err">列的类型</span>   <span class="p">[</span><span class="err">属性约束</span><span class="p">]</span>   
<span class="p">);</span>
<span class="c1"># 如果名字和命令名冲突，此时使用反引号(`)括起来
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>查看表结构</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">DESC</span> <span class="n">name</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>查看表的详细定义</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">SHOW</span> <span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">name</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>删除表</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">DROP</span> <span class="k">TABLE</span> <span class="n">name</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>往表中插入一行数据</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="c1"># 为所有表单项赋值，插入
</span><span class="c1"></span><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="nf">test</span><span class="p">(</span><span class="n">id</span> <span class="kt">INT</span><span class="p">,</span><span class="n">_date</span> <span class="kt">DATE</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">test</span>  <span class="k">VALUES</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;2008‐12‐2&#39;</span><span class="p">);</span>

<span class="c1"># 选择赋值
</span><span class="c1"></span><span class="k">CREATE</span> <span class="k">TABLE</span>  <span class="nf">test4</span><span class="p">(</span><span class="n">id</span> <span class="kt">INT</span><span class="p">,</span><span class="n">_datetime</span> <span class="kt">DATETIME</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="nf">test4</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">_datetime</span><span class="p">)</span> <span class="k">VALUES</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;1990‐02‐10&#39;</span><span class="p">);</span>

<span class="cm">/*
</span><span class="cm">DATE可以通过CURDATE()来赋值当前的日期，
</span><span class="cm">TIME可以通过CURTIME()来赋值当前的时间，
</span><span class="cm">DATETIME与TIMESTAMP都可以通过函数NOW()来赋值当前的时间日期。
</span><span class="cm"> */</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>修改已有表字符集</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="err">表名</span> <span class="k">CONVERT</span> <span class="k">TO</span> <span class="k">CHARACTER</span> <span class="kt">SET</span> <span class="n">utf8</span><span class="p">;</span> <span class="c1"># or gbk
</span><span class="c1"># 若想仅修改某一列的字符集 使用列操作添加约束属性 CHARACTER SET name
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>修改表名</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="err">表名</span> <span class="k">RENAME</span> <span class="k">TO</span> <span class="err">新表名</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="23-列操作">2.3 列操作</h3>
<p><strong>列（字段）</strong></p>
<ul>
<li>给表添加列</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="err">表名</span> <span class="k">ADD</span> <span class="err">列名</span> <span class="err">列的类型</span> <span class="p">[</span><span class="err">属性约束</span><span class="p">];</span>
<span class="k">ALTER</span> <span class="k">TABLE</span> <span class="err">表名</span> <span class="k">ADD</span> <span class="err">列名</span> <span class="err">列的类型</span> <span class="p">[</span><span class="err">属性约束</span><span class="p">]</span> <span class="n">FIRST</span><span class="p">;</span> <span class="cm">/*放在第一位*/</span>
<span class="k">ALTER</span> <span class="k">TABLE</span> <span class="err">表名</span> <span class="k">ADD</span> <span class="err">列名</span> <span class="err">列的类型</span> <span class="n">AFTER</span> <span class="err">列名</span><span class="p">;</span> <span class="cm">/*放在某字段后面*/</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>修改已有列数据类型，约束</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="err">表名</span> <span class="n">MODIFY</span> <span class="err">列名</span> <span class="err">列的类型</span> <span class="p">[</span><span class="err">属性约束</span><span class="p">];</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>删除列</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="err">表名</span> <span class="k">DROP</span> <span class="err">列名</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>修改列名，和类型</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="err">表名</span> <span class="k">CHANGE</span> <span class="err">列名</span> <span class="err">新</span><span class="n">_列名</span> <span class="err">列的类型</span> <span class="p">[</span><span class="err">属性约束</span><span class="p">];</span> <span class="c1"># 列名不一定要新的，
</span></code></pre></td></tr></table>
</div>
</div><h3 id="24-列属性约束">2.4 列.属性约束</h3>
<table>
<thead>
<tr>
<th>MySOL关键字</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>NULL</td>
<td>数据列可包含NULL值 ，默认不填即为NULL。</td>
</tr>
<tr>
<td>NOT NULL</td>
<td>数据列不允许包含NULL值 ，在操作数据库时如果输入该字段的数据为NULL ，就会报错。</td>
</tr>
<tr>
<td>DEFAULT</td>
<td>默认值，DATE，TIME不能使用函数默认值。DATETIME与TIMESTAMP可以使用NOW()函数默认值。</td>
</tr>
<tr>
<td>PRIMARY KEY</td>
<td>主键 ，您可以使用多列来定义主键，列间以逗号分隔。主键不管有没NOT NULL修饰，都不能为NULL，主键值不能重复。主键可以由多个字段组成。例如：PRIMARY KEY (id, name)</td>
</tr>
<tr>
<td>AUTO_INCREMENT</td>
<td>定义列为自增的属性，数值会自动加1, 默认初始值为0。一个表只能有一个自增字段，并且该字段必须是主键或者索引。</td>
</tr>
<tr>
<td>UNSIGNED</td>
<td>无符号</td>
</tr>
<tr>
<td>CHARACTER SET name</td>
<td>指定一个字符集</td>
</tr>
</tbody>
</table>
<h4 id="241-列默认值-default">2.4.1 列默认值 DEFAULT</h4>
<p>在未指定默认值的情况下，系统提供default null这样的约束。只有列中提供了default，在插入时，才可以省略。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="c1"># 设置/删除 DEFAULT
</span><span class="c1"></span><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="err">表名</span> <span class="k">ALTER</span> <span class="err">列名</span> <span class="kt">SET</span> <span class="k">DEFAULT</span> <span class="err">默认值</span><span class="p">;</span>
<span class="k">ALTER</span> <span class="k">TABLE</span> <span class="err">表名</span> <span class="k">ALTER</span> <span class="err">列名</span> <span class="k">DROP</span>  <span class="k">DEFAULT</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="242--非空约束-not-null">2.4.2  非空约束 NOT NULL</h4>
<p>NULL存在的意义在于标志。
NULL类型特征:所有的类型的值都可以是null，包括int、float等数据类型,空字符串是不等于null，0也不等于null。
非空约束用于确保当前列的值不为空值，非空约束只能出现在表对象的列上。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="c1"># 已有，设置
</span><span class="c1"></span><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="err">表名</span> <span class="n">MODIFY</span> <span class="err">列名</span> <span class="kt">INT</span> <span class="k">NOT</span> <span class="no">NULL</span> <span class="k">DEFAULT</span> <span class="mi">0</span><span class="p">;</span>
<span class="c1"># 创建表
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">CREATE</span> <span class="k">TABLE</span> <span class="nf">stu2</span> <span class="p">(</span>
  <span class="n">id</span> <span class="kt">INT</span> <span class="k">DEFAULT</span> <span class="no">NULL</span><span class="p">,</span>
  <span class="n">sex</span> <span class="kt">CHAR</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="k">NOT</span> <span class="no">NULL</span>
<span class="p">)</span>

<span class="c1"># 效果 不能默认初始化
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">stu2</span>   <span class="k">VALUES</span><span class="p">();</span>
<span class="n">ERROR</span> <span class="mi">1364</span> <span class="p">(</span><span class="n">HY000</span><span class="p">):</span> <span class="n">Field</span> <span class="s1">&#39;sex&#39;</span> <span class="n">doesn</span><span class="s1">&#39;t have a default value
</span></code></pre></td></tr></table>
</div>
</div><h4 id="243-唯一约束-unique-key">2.4.3 唯一约束 UNIQUE KEY</h4>
<p>唯一约束是指定table的列或列组合不能重复，保证数据的唯一性。虽然唯一约束不允许出现重复的值，但是可以有多个null，同一个表可以有多个唯一约束，多个列组合的约束。
在创建唯一约束的时候，如果不给唯一约束名称，就默认和列名相同。 MySQL会给唯一约束的列上默认创建一个唯一索引.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">CREATE</span>  <span class="k">TABLE</span> <span class="nf">stu3</span><span class="p">(</span><span class="n">id</span> <span class="kt">INT</span> <span class="k">UNIQUE</span><span class="p">,</span> <span class="n">sex</span> <span class="kt">CHAR</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">CREATE</span> <span class="k">TABLE</span> <span class="nf">stu3</span><span class="p">(</span><span class="n">id</span> <span class="kt">INT</span><span class="p">,</span> <span class="n">sex</span> <span class="kt">CHAR</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="k">UNIQUE</span><span class="p">(</span><span class="n">id</span><span class="p">));</span> <span class="c1"># 第二种写法
</span><span class="c1"></span>
<span class="c1"># 效果 插入重复值报错
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">INSERT</span> <span class="k">INTO</span>  <span class="n">stu3</span> <span class="k">VALUES</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;f&#39;</span><span class="p">);</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">1</span> <span class="n">row</span> <span class="nf">affected</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">INSERT</span> <span class="k">INTO</span>  <span class="n">stu3</span> <span class="k">VALUES</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;f&#39;</span><span class="p">);</span>
<span class="n">ERROR</span> <span class="mi">1062</span> <span class="p">(</span><span class="mi">23000</span><span class="p">):</span> <span class="n">Duplicate</span> <span class="n">entry</span> <span class="s1">&#39;1&#39;</span> <span class="k">for</span> <span class="k">key</span> <span class="s1">&#39;id&#39;</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="244--主键约束-primary-key">2.4.4  主键约束 PRIMARY KEY</h4>
<p>每个表最多只允许一个主键，建立主键约束可以在列级别创建，也可以在表级别上创建。
MySQL的主键名总是PRIMARY KEY， 当创建主键约束时，系统默认会在所在的列或列组合上建立对应的唯一索引。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="c1">#已有表，修改，删除
</span><span class="c1"></span><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">table_name</span> <span class="k">ADD</span> <span class="k">primary</span> <span class="k">key</span><span class="p">(</span><span class="n">column_name</span><span class="p">);</span> <span class="cm">/*必须是不存在重复值的列*/</span>
<span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">table_name</span> <span class="k">DROP</span> <span class="k">primary</span> <span class="k">key</span><span class="p">;</span>
<span class="c1"># 创建时设置
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">CREATE</span> <span class="k">TABLE</span> <span class="nf">stu4</span><span class="p">(</span><span class="n">id</span> <span class="kt">INT</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span> <span class="n">sex</span> <span class="kt">CHAR</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">CREATE</span> <span class="k">TABLE</span> <span class="nf">stu4</span><span class="p">(</span><span class="n">id</span> <span class="kt">INT</span><span class="p">,</span> <span class="n">sex</span> <span class="kt">CHAR</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">(</span><span class="n">id</span><span class="p">));</span> <span class="c1"># 第二种写法
</span><span class="c1"></span>
<span class="c1"># 效果 只能有一个列为主键，且没有重复
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">INSERT</span> <span class="k">INTO</span> <span class="nf">stu4</span><span class="p">(</span><span class="n">id</span><span class="p">,</span><span class="n">sex</span><span class="p">)</span> <span class="k">VALUES</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;f&#39;</span><span class="p">);</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">1</span> <span class="n">row</span> <span class="nf">affected</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">INSERT</span> <span class="k">INTO</span> <span class="nf">stu4</span><span class="p">(</span><span class="n">id</span><span class="p">,</span><span class="n">sex</span><span class="p">)</span> <span class="k">VALUES</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;f&#39;</span><span class="p">);</span>
<span class="n">ERROR</span> <span class="mi">1062</span> <span class="p">(</span><span class="mi">23000</span><span class="p">):</span> <span class="n">Duplicate</span> <span class="n">entry</span> <span class="s1">&#39;1&#39;</span> <span class="k">for</span> <span class="k">key</span> <span class="s1">&#39;PRIMARY&#39;</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="245-自增约束-auto_increment">2.4.5 自增约束 AUTO_INCREMENT</h4>
<p>MySQL的中AUTO_INCREMENT类型的属性用于为一个表中记录自动生成ID功能。一个表只能有一个自增字段，并且该字段必须是主键或者索引。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="err">表名</span> <span class="k">CHANGE</span> <span class="n">id</span> <span class="n">id</span> <span class="kt">INT</span> <span class="kp">AUTO_INCREMENT</span><span class="p">;</span> <span class="c1">#必须先是索引
</span><span class="c1"></span><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="err">表名</span> <span class="kp">AUTO_INCREMENT</span><span class="o">=</span><span class="n">number</span><span class="p">;</span> <span class="c1"># 设置初始值
</span><span class="c1"># 创建时
</span><span class="c1"></span><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">CREATE</span> <span class="k">TABLE</span> <span class="nf">stu5</span><span class="p">(</span><span class="n">id</span> <span class="kt">INT</span> <span class="kp">AUTO_INCREMENT</span><span class="p">,</span><span class="n">sex</span> <span class="kt">CHAR</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span> <span class="c1"># 错误，必须是索引
</span><span class="c1"></span> <span class="n">ERROR</span> <span class="mi">1075</span> <span class="p">(</span><span class="mi">42000</span><span class="p">):</span> <span class="n">Incorrect</span> <span class="k">table</span> <span class="n">definition</span><span class="p">;</span> <span class="n">there</span> <span class="n">can</span> <span class="n">be</span> <span class="n">only</span> <span class="n">one</span> <span class="n">auto</span> <span class="k">column</span> <span class="k">and</span> <span class="n">it</span> <span class="n">must</span> <span class="n">be</span> <span class="n">defined</span> <span class="k">as</span> <span class="n">a</span> <span class="k">key</span>
 
 <span class="n">mysql</span><span class="o">&gt;</span> <span class="k">CREATE</span> <span class="k">TABLE</span> <span class="nf">stu5</span><span class="p">(</span><span class="n">id</span> <span class="kt">INT</span> <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="kp">AUTO_INCREMENT</span> <span class="p">,</span><span class="n">sex</span> <span class="kt">CHAR</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span> <span class="c1"># 正确方式
</span><span class="c1"></span> <span class="n">mysql</span><span class="o">&gt;</span> <span class="k">CREATE</span> <span class="k">TABLE</span> <span class="nf">stu6</span><span class="p">(</span><span class="n">id</span> <span class="kt">INT</span> <span class="k">UNIQUE</span> <span class="k">KEY</span> <span class="kp">AUTO_INCREMENT</span> <span class="p">,</span><span class="n">sex</span> <span class="kt">CHAR</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span> <span class="c1"># 正确方式
</span><span class="c1"></span> 
 <span class="c1"># 效果  不提供初始值，自动递增分配， 提供重复的则报错
</span></code></pre></td></tr></table>
</div>
</div><h3 id="24-行操作">2.4 行操作</h3>
<ul>
<li>行增</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">INSERT</span> <span class="k">INTO</span> <span class="err">表名</span><span class="p">(</span> <span class="err">字段</span><span class="mi">1</span><span class="p">,</span> <span class="err">字段</span><span class="mi">2</span><span class="p">,...</span> <span class="err">字段</span><span class="n">N</span> <span class="p">)</span> <span class="k">VALUES</span><span class="p">(</span> <span class="n">value1</span><span class="p">,</span> <span class="n">value2</span><span class="p">,...</span> <span class="n">valueN</span> <span class="p">);</span>
<span class="c1"># 字段（field）和值（value）都可以省略
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>行删</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">DELETE</span> <span class="k">FROM</span> <span class="o">&lt;</span><span class="err">表名</span><span class="o">&gt;</span> <span class="p">[</span><span class="k">WHERE</span> <span class="o">&lt;</span><span class="err">删除条件</span><span class="o">&gt;</span><span class="p">]</span>

<span class="c1"># 栗子
</span><span class="c1"></span><span class="k">delete</span> <span class="k">from</span> <span class="n">class</span> <span class="k">where</span> <span class="n">_id</span><span class="o">=</span><span class="mi">9</span><span class="p">;</span>
<span class="k">delete</span> <span class="k">from</span> <span class="n">class</span><span class="p">;</span>
<span class="c1"># 不跟条件表示删除整个表内容（不是整个表，框架还在），等价于
</span><span class="c1"></span><span class="n">truncate</span> <span class="k">table</span> <span class="o">&lt;</span><span class="err">表名</span><span class="o">&gt;</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>行改</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">UPDATE</span> <span class="o">&lt;</span><span class="err">表名</span><span class="o">&gt;</span> <span class="kt">SET</span> <span class="o">&lt;</span><span class="err">列名</span><span class="o">=</span><span class="err">更新值</span><span class="o">&gt;</span> <span class="p">[</span><span class="k">WHERE</span> <span class="o">&lt;</span><span class="err">更新条件</span><span class="o">&gt;</span><span class="p">]</span>

<span class="c1"># 栗子
</span><span class="c1"></span><span class="k">update</span> <span class="n">class</span> <span class="kt">SET</span> <span class="n">score</span><span class="o">=</span><span class="mi">100</span> <span class="k">WHERE</span> <span class="n">name</span><span class="o">=</span><span class="s2">&#34;郑同学&#34;</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="3-行查询">3 行查询</h2>
<h3 id="31-全列查询投影查询">3.1 全列查询/投影查询</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">SELECT</span> <span class="n">column_name0</span><span class="p">,</span><span class="n">column_name1</span><span class="p">...</span>
<span class="k">FROM</span> <span class="n">table_name0</span><span class="p">,</span><span class="n">table_name1</span><span class="p">...</span>
<span class="p">[</span><span class="k">WHERE</span> <span class="n">clause</span><span class="p">]</span>
<span class="p">[</span><span class="k">LIMIT</span> <span class="n">N</span><span class="p">]</span> <span class="p">[</span><span class="n">OFFSET</span> <span class="n">M</span> <span class="p">]</span>

<span class="c1"># 查询表phonelist所有字段信息
</span><span class="c1"></span><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">phonelist</span><span class="p">;</span>
<span class="c1"># 只查询名字（name）为小张的所有字段信息
</span><span class="c1"></span><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">phonelist</span> <span class="k">WHERE</span> <span class="n">name</span><span class="o">=</span><span class="s2">&#34;小张&#34;</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="32-消除重复">3.2 消除重复</h3>
<p>distinct 可用于一列，也可用于多列，使用后如果目标字段有重复的内容，只打印一个</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">SELECT</span> <span class="k">DISTINCT</span> <span class="n">column_name0</span><span class="p">,</span><span class="n">column_name1</span><span class="p">...</span>
<span class="k">FROM</span> <span class="n">table_name0</span><span class="p">,</span><span class="n">table_name1</span><span class="p">...</span>
<span class="p">[</span><span class="k">WHERE</span> <span class="n">clause</span><span class="p">]</span>
<span class="p">[</span><span class="k">LIMIT</span> <span class="n">N</span><span class="p">]</span> <span class="p">[</span><span class="n">OFFSET</span> <span class="n">M</span> <span class="p">]</span>

<span class="c1"># 不出现重复打印班级里的同学名字
</span><span class="c1"></span><span class="k">SELECT</span> <span class="k">DISTINCT</span> <span class="n">name</span> <span class="k">FROM</span> <span class="n">class</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="33-算术操作符">3.3 算术操作符</h3>
<ul>
<li>对NUMBER型数据可以使用算数操作符创建表达式（+ - * /）</li>
<li>对DATE型数据可以使用算数操作符创建表达式（+ -）</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="c1"># 吧所有同学学号乘以10再打印
</span><span class="c1"></span><span class="k">SELECT</span> <span class="n">id</span><span class="o">*</span><span class="mi">10</span> <span class="k">FROM</span> <span class="n">class</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="34-空值判断-is-nullis-not-null">3.4 空值判断 IS NULL/IS NOT NULL</h3>
<ol>
<li>空值是指不可用、未分配的值,也就是没有值。</li>
<li>空值不等于零或空格</li>
<li>任意类型都可以支持空值，也就是说任何类型的字段都可以允许空值作为值的存在</li>
<li>空字符串和字符串为null的区别</li>
<li>包括空值的任何算术表达式都等于空，使用IFNULL(expr1,expr2)来处理, expr1为NULL就用expr2替代。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="c1"># 查询班级所有name字段不为空的所有信息
</span><span class="c1"></span><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">class</span> <span class="k">WHERE</span> <span class="n">name</span> <span class="k">IS</span> <span class="k">NOT</span> <span class="no">NULL</span><span class="p">;</span>
<span class="c1"># 计算 学分 = 成绩/10，成绩为NULL的按0分算
</span><span class="c1"></span><span class="k">SELECT</span> <span class="nf">IFNULL</span><span class="p">(</span><span class="n">score</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="mi">10</span> <span class="k">FROM</span> <span class="n">class</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="35-比较运算符">3.5 比较运算符</h3>
<table>
<thead>
<tr>
<th>比较运算符</th>
<th>表达式</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>等于，不等于，大于，小于</td>
<td>=,!=,&lt;&gt;,&lt;,&lt;=,&gt;,&gt;=</td>
<td>WHERE num&gt;=0 AND num&lt;=10</td>
</tr>
<tr>
<td>在两值之间（闭区间）</td>
<td>BETWEEN &hellip; AND &hellip;</td>
<td>WHRER num BETWEEN 0 AND 10</td>
</tr>
<tr>
<td>不在两值之间</td>
<td>NOT BETEWEEN &hellip;</td>
<td>同上，BETWEEN 前加 NOT</td>
</tr>
<tr>
<td>匹配在集合中的值</td>
<td>IN（list）</td>
<td>WHERE name IN(&lsquo;abc&rsquo;,&lsquo;efg&rsquo;,&lsquo;h&rsquo;)</td>
</tr>
<tr>
<td>匹配不在集合中的值</td>
<td>NOT IN（list）</td>
<td>同上</td>
</tr>
<tr>
<td>模糊匹配</td>
<td>LIKE</td>
<td>WHRER name LIKE &lsquo;%abc&rsquo;  OR name LIKE &lsquo;abc_&rsquo;</td>
</tr>
</tbody>
</table>
<ul>
<li>LIKE运算符必须使用通配符才有意义： 匹配单个字符<code>_</code>匹配任意多个字符<code>%</code></li>
</ul>
<h3 id="36-逻辑运算符">3.6 逻辑运算符</h3>
<table>
<thead>
<tr>
<th>逻辑运算符</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>AND</td>
<td>如果组合的条件都是true,返回true.</td>
</tr>
<tr>
<td>OR</td>
<td>如果组合的条件 之一是true,返回true.</td>
</tr>
<tr>
<td>NOT</td>
<td>如果下面的条件是false,返回true.</td>
</tr>
</tbody>
</table>
<h3 id="37-结果排序">3.7 结果排序</h3>
<p>使用ORDER BY 子句将记录排序，ORDER BY 子句出现在SELECT语句的最后，ORDER BY 可以使用别名。ASC: 升序。DESC: 降序。缺省:升序。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="c1"># 查询所有信息，按id降序排序
</span><span class="c1"></span><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">phonelist</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">id</span> <span class="k">DESC</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="4-进阶">4 进阶</h2>
<h3 id="41-索引">4.1 索引</h3>
<h4 id="411-索引介绍">4.1.1 索引介绍</h4>
<ul>
<li>
<p>索引分单列索引和组合索引。</p>
</li>
<li>
<p>单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。</p>
</li>
<li>
<p>组合索引，即一个索引包含多个列。</p>
</li>
<li>
<p>创建索引时，你需要确保该索引是应用在SQL查询语句的条件(一般作为 WHERE 子句的条件)。</p>
</li>
<li>
<p>索引提高查询速度，降低更新表的速度。空间换时间</p>
</li>
</ul>
<h4 id="412-索引操作">4.1.2 索引操作</h4>
<ul>
<li>查看索引</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">SHOW</span> <span class="k">INDEX</span> <span class="k">FROM</span> <span class="err">表名</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>创建索引
<ul>
<li>自动创建的索引，当在表上定义一个<code>PRIMARY KEY</code>时，自动创建一个对应的唯一索引。当在表上定义一个外键时，自动创建一个普通索引；</li>
<li>手动创建的索引，用户可以创建索引以加速查询，在一列或者多列上创建索引。如果多列在一起，就叫做复合索引；在很多情况下，复合索引比单个索引更好。</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">CREATE</span> <span class="k">INDEX</span> <span class="n">index_name</span> <span class="k">ON</span> <span class="err">表名</span><span class="p">(</span><span class="err">列名</span><span class="p">);</span> 			<span class="c1"># index_name 自定义
</span><span class="c1"></span><span class="k">CREATE</span> <span class="k">UNIQUE</span> <span class="k">INDEX</span> <span class="n">index_name</span> <span class="k">ON</span> <span class="err">表名</span><span class="p">(</span><span class="err">列名</span><span class="p">);</span>   <span class="c1"># unique 表示唯一索引
</span><span class="c1"></span><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="err">表名</span> <span class="k">ADD</span> <span class="k">INDEX</span> <span class="nf">index_name</span><span class="p">(</span><span class="err">列名</span><span class="p">);</span>    <span class="c1"># 列名有多个就是组合索引
</span><span class="c1"></span><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="o">`</span><span class="n">news</span><span class="o">`</span><span class="p">(</span>                   	   
    <span class="o">`</span><span class="n">id</span><span class="o">`</span> <span class="kt">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">NOT</span> <span class="no">NULL</span> <span class="kp">AUTO_INCREMENT</span><span class="p">,</span>
    <span class="o">`</span><span class="n">title</span><span class="o">`</span> <span class="kt">varchar</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span> <span class="k">NOT</span> <span class="no">NULL</span><span class="p">,</span>
    <span class="o">`</span><span class="n">content</span><span class="o">`</span> <span class="kt">varchar</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span> <span class="no">NULL</span><span class="p">,</span>
    <span class="o">`</span><span class="kt">time</span><span class="o">`</span> <span class="kt">varchar</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="no">NULL</span> <span class="k">DEFAULT</span> <span class="no">NULL</span><span class="p">,</span>
    <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="p">),</span> 
    <span class="k">INDEX</span> <span class="nf">index_name</span> <span class="p">(</span><span class="nf">title</span><span class="p">(</span><span class="mi">255</span><span class="p">))</span>
<span class="p">)</span><span class="c1"># 创建表同时建立索引，PRIMARY KEY 其实也是索引
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>删除索引</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="err">表名</span> <span class="k">DROP</span> <span class="k">INDEX</span> <span class="n">index_name</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>检查语句是否使用索引
<ul>
<li>并不是所有情况下都会使用索引，只有当MySQL认为索引足够能够提升查询性能时才会使用；</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">EXPLAIN</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">table_name</span> <span class="k">where</span> <span class="n">clause</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="42-分页查询">4.2 分页查询</h3>
<ul>
<li>分页查询：一般情况下，客户端通过传递 pageNo（页码）、pageSize（每页条数）两个参数去分页查询数据库中的数据，在数据量较小（元组百/千级）时使用 MySQL自带的 <code>limit</code> 来解决这个问题：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="c1"># 从第n行开始，打印m条数据，行数从0开始，可以不加offset，默认从0开始
</span><span class="c1"></span><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="err">表名</span> <span class="k">LIMIT</span> <span class="n">m</span> <span class="n">OFFSET</span> <span class="n">n</span><span class="p">;</span>

<span class="c1"># 另一种写法，从第n行开始打印m条
</span><span class="c1"></span><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="err">表名</span> <span class="k">limit</span> <span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="43-函数">4.3 函数</h3>
<p><code>select func();</code>可以查看函数效果；</p>
<h4 id="431-字符函数">4.3.1 字符函数</h4>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>LOWER/UPPER</td>
<td>大小写转换</td>
</tr>
<tr>
<td>CONCAT</td>
<td>字符连接</td>
</tr>
<tr>
<td>CHAR_LENGTH/LENGTH</td>
<td>求字符串长度</td>
</tr>
<tr>
<td>LPAD/RPAD</td>
<td>左/右 填充</td>
</tr>
<tr>
<td>LTRIM/RTRIM/TRIM</td>
<td>去除 全部/左边/右边 空格</td>
</tr>
<tr>
<td>REPLACE</td>
<td>替换</td>
</tr>
<tr>
<td>SUBSTRING</td>
<td>获取子串</td>
</tr>
</tbody>
</table>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">SELECT</span> <span class="nf">LOWER</span><span class="p">(</span><span class="s2">&#34;ABC&#34;</span><span class="p">);</span> <span class="c1"># abc
</span><span class="c1"></span><span class="k">SELECT</span> <span class="nf">UPPER</span><span class="p">(</span><span class="s2">&#34;abc&#34;</span><span class="p">);</span> <span class="c1"># ABC
</span><span class="c1"></span><span class="k">SELECT</span> <span class="nf">CONCAT</span><span class="p">(</span><span class="s2">&#34;china&#34;</span><span class="p">,</span><span class="s2">&#34;is&#34;</span><span class="p">,</span><span class="nf">UPPER</span><span class="p">(</span><span class="s2">&#34;greate&#34;</span><span class="p">));</span><span class="c1"># china is GREATE
</span><span class="c1"></span>
<span class="k">SELECT</span> <span class="nf">CHAR_LENGTH</span><span class="p">(</span><span class="s2">&#34;abc&#34;</span><span class="p">);</span> <span class="c1"># 3
</span><span class="c1"></span><span class="k">SELECT</span> <span class="nf">LENGTH</span><span class="p">(</span><span class="s2">&#34;china&#34;</span><span class="p">);</span> <span class="c1"># 5
</span><span class="c1"></span><span class="k">SELECT</span> <span class="nf">RPAD</span><span class="p">(</span><span class="s2">&#34;abc&#34;</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="s2">&#34;xyz&#34;</span><span class="p">);</span> <span class="c1"># abcxyz 
</span><span class="c1"></span><span class="k">SELECT</span> <span class="nf">LPAD</span><span class="p">(</span><span class="s2">&#34;abc&#34;</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="s2">&#34;X&#34;</span><span class="p">);</span> <span class="c1"># XXXabc
</span><span class="c1"></span>
<span class="k">SELECT</span>  <span class="nf">TRIM</span><span class="p">(</span><span class="s2">&#34;  abc   &#34;</span><span class="p">);</span>

<span class="k">SELECT</span> <span class="k">REPLACE</span><span class="p">(</span><span class="s2">&#34;abc&#34;</span><span class="p">,</span><span class="s2">&#34;b&#34;</span><span class="p">,</span><span class="s2">&#34;BB&#34;</span><span class="p">);</span> <span class="c1"># aBBc
</span><span class="c1"></span>
<span class="k">SELECT</span> <span class="nf">SUBSTRING</span><span class="p">(</span><span class="s2">&#34;abcchina&#34;</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span> <span class="c1"># cchina
</span><span class="c1"></span><span class="k">SELECT</span> <span class="nf">SUBSTRING</span><span class="p">(</span><span class="s2">&#34;abcchina&#34;</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span> <span class="c1"># cchi
</span><span class="c1"></span><span class="k">SELECT</span> <span class="nf">SUBSTRING</span><span class="p">(</span><span class="s2">&#34;abcchina&#34;</span><span class="p">,</span><span class="err">‐</span><span class="mi">3</span><span class="p">);</span> <span class="c1"># ina
</span></code></pre></td></tr></table>
</div>
</div><h4 id="432-数学函数">4.3.2 数学函数</h4>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>ABS</td>
<td>求绝对值</td>
</tr>
<tr>
<td>MOD</td>
<td>求模</td>
</tr>
<tr>
<td>FLOOR/CEIL</td>
<td>向下/向上取整</td>
</tr>
<tr>
<td>ROUND</td>
<td>四舍五入</td>
</tr>
<tr>
<td>TRUNCATE</td>
<td>按位数截断</td>
</tr>
</tbody>
</table>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">SELECT</span> <span class="nf">ABS</span><span class="p">(</span><span class="err">‐</span><span class="mi">100</span><span class="p">);</span> <span class="c1"># 100
</span><span class="c1"></span><span class="k">SELECT</span> <span class="k">MOD</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span> <span class="c1"># 1
</span><span class="c1"></span>
<span class="c1">#一下都是对浮点型数字进行操作
</span><span class="c1"></span><span class="k">SELECT</span> <span class="nf">FLOOR</span><span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">23</span><span class="p">);</span> <span class="c1"># 1
</span><span class="c1"></span><span class="k">SELECT</span> <span class="nf">CEIL</span><span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">23</span><span class="p">);</span> <span class="c1"># 2
</span><span class="c1"></span>
<span class="k">SELECT</span> <span class="nf">ROUND</span><span class="p">(</span><span class="mi">3</span><span class="p">.</span><span class="mi">145</span><span class="p">);</span> <span class="c1"># 3
</span><span class="c1"></span><span class="k">SELECT</span> <span class="nf">ROUND</span><span class="p">(</span><span class="mi">3</span><span class="p">.</span><span class="mi">145</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>  <span class="c1"># 3.15 保留俩位小数
</span><span class="c1"></span><span class="k">SELECT</span> <span class="nf">TRUNCATE</span><span class="p">(</span><span class="mi">3</span><span class="p">.</span><span class="mi">14</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span> <span class="c1"># 3.1 截取小数点后1位
</span></code></pre></td></tr></table>
</div>
</div><h4 id="433-日期函数">4.3.3 日期函数</h4>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>NOW</td>
<td>当前时间 2017-08-06 22:33:39</td>
</tr>
<tr>
<td>YEAR</td>
<td>年</td>
</tr>
<tr>
<td>MONTH</td>
<td>月</td>
</tr>
<tr>
<td>DAY</td>
<td>日</td>
</tr>
<tr>
<td>HOUR</td>
<td>时</td>
</tr>
<tr>
<td>MINUTE</td>
<td>分</td>
</tr>
<tr>
<td>SECOND</td>
<td>秒</td>
</tr>
<tr>
<td>CURRENT_DATE</td>
<td>年-月-日</td>
</tr>
<tr>
<td>CURRENT_TIME</td>
<td>时：分：秒</td>
</tr>
<tr>
<td>LAST_DAY</td>
<td>所在月份的最后一天</td>
</tr>
<tr>
<td>DATE_ADD/DATE_SUB</td>
<td>增减</td>
</tr>
<tr>
<td>DATEDIFF</td>
<td>日期差</td>
</tr>
</tbody>
</table>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">SELECT</span> <span class="nf">NOW</span><span class="p">();</span> <span class="c1"># 2019-02-13 12:51:39
</span><span class="c1"></span><span class="k">SELECT</span> <span class="kt">YEAR</span><span class="p">(</span><span class="nf">NOW</span><span class="p">());</span> <span class="c1"># 2019
</span><span class="c1"></span><span class="k">SELECT</span> <span class="nf">MONTH</span><span class="p">(</span><span class="nf">NOW</span><span class="p">());</span> <span class="c1"># 2
</span><span class="c1"></span><span class="k">SELECT</span> <span class="nf">DAY</span><span class="p">(</span><span class="nf">NOW</span><span class="p">());</span> <span class="c1"># 13
</span><span class="c1"># HOUT MINUTE SECOND 用法同上
</span><span class="c1"></span>
<span class="k">SELECT</span> <span class="k">CURRENT_DATE</span><span class="p">();</span> <span class="c1"># 2019-02-13  简写CURDATE()
</span><span class="c1"></span><span class="k">SELECT</span> <span class="k">CURRENT_TIME</span><span class="p">();</span> <span class="c1"># 12:56:20  简写CURTIME()
</span><span class="c1"></span>
<span class="k">SELECT</span> <span class="nf">LAST_DAY</span><span class="p">(</span><span class="nf">NOW</span><span class="p">());</span> <span class="c1"># 2019-02-28
</span><span class="c1"></span><span class="k">SELECT</span> <span class="nf">LAST_DAY</span><span class="p">(</span><span class="nf">str_to_date</span><span class="p">(</span><span class="s1">&#39;2019-12-01 00:00:00&#39;</span><span class="p">,</span><span class="s1">&#39;%Y-%m-%d %H:%i:%s&#39;</span><span class="p">));</span> <span class="c1"># 2019-12-31
</span><span class="c1"></span>
<span class="k">SELECT</span> <span class="nf">DATE_ADD</span><span class="p">(</span><span class="nf">NOW</span><span class="p">(),</span><span class="k">INTERVAL</span> <span class="mi">2</span> <span class="n">DAY</span><span class="p">);</span> <span class="c1"># 2019-02-15 13:02:01 
</span><span class="c1"></span><span class="k">SELECT</span> <span class="nf">DATE_SUB</span><span class="p">(</span><span class="nf">NOW</span><span class="p">(),</span><span class="k">INTERVAL</span> <span class="mi">3</span> <span class="n">HOUR</span><span class="p">);</span>

<span class="k">SELECT</span> <span class="nf">DATEDIFF</span><span class="p">(</span><span class="nf">LAST_DAY</span><span class="p">(</span><span class="nf">NOW</span><span class="p">()),</span><span class="nf">NOW</span><span class="p">());</span> <span class="c1"># 15 
</span></code></pre></td></tr></table>
</div>
</div><h4 id="434-转换函数">4.3.4 转换函数</h4>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>FORMAT</td>
<td>数字到字符串的转化</td>
</tr>
<tr>
<td>DATE_FORMAT</td>
<td>时间到字符串</td>
</tr>
<tr>
<td>STR_TO_DATE</td>
<td>字符串到时间</td>
</tr>
</tbody>
</table>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">SELECT</span> <span class="nf">FORMAT</span><span class="p">(</span><span class="mi">235235</span><span class="p">.</span><span class="mi">346326</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span> <span class="c1"># 小数点保留2位 235,235.35
</span><span class="c1"></span>
<span class="k">SELECT</span> <span class="nf">DATE_FORMAT</span><span class="p">(</span><span class="nf">NOW</span><span class="p">(),</span><span class="s1">&#39;%b %d %Y %h:%i %p&#39;</span><span class="p">);</span> <span class="c1"># Feb 13 2019 01:16 PM
</span><span class="c1"></span><span class="k">SELECT</span> <span class="nf">DATE_FORMAT</span><span class="p">(</span><span class="nf">NOW</span><span class="p">(),</span><span class="s1">&#39;%m-%d-%Y&#39;</span><span class="p">);</span> <span class="c1"># 02-13-2019  
</span><span class="c1"></span>
<span class="k">SELECT</span> <span class="nf">STR_TO_DATE</span><span class="p">(</span><span class="s1">&#39;2019-12-01 00:00:00&#39;</span><span class="p">,</span><span class="s1">&#39;%Y-%m-%d %H:%i:%s&#39;</span><span class="p">);</span> <span class="c1"># 2019-12-01 00:00:00
</span></code></pre></td></tr></table>
</div>
</div><h4 id="435-聚合函数">4.3.5 聚合函数</h4>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>COUNT()</td>
<td>返回指定列中（满足条件的）非NULL值的个数</td>
</tr>
<tr>
<td>AVG()</td>
<td>返回指定列（满足条件的）的平均值</td>
</tr>
<tr>
<td>SUM()</td>
<td>返回指定列（满足条件的）的所有值之和</td>
</tr>
<tr>
<td>MAX()</td>
<td>返回指定列（满足条件的）的最大值</td>
</tr>
<tr>
<td>MIN()</td>
<td>返回指定列（满足条件的）的最小值</td>
</tr>
</tbody>
</table>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="c1"># 计算班级 50分以上同学的分数最大差
</span><span class="c1"></span><span class="k">SELECT</span> <span class="nf">MAX</span><span class="p">(</span><span class="n">score</span><span class="p">)</span><span class="err">‐</span><span class="nf">MIN</span><span class="p">(</span><span class="n">score</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">class</span> <span class="k">WHERE</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="44-分组查询">4.4 分组查询</h3>
<h4 id="441-group-by">4.4.1 GROUP BY</h4>
<p>在对数据表中数据进行统计时，可能需要按照一定的类别分别进行统计，</p>
<p>如score字段中，值相同的行被视作一类（分组）</p>
<p>单独使用GROUP BY关键字，查询的是每个分组中的一条记录，意义不大。</p>
<p>一般情况下，GROUP BY都和聚合函数一起使用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="c1"># 统计60分以上，各个分数的人数
</span><span class="c1"></span><span class="k">SELECT</span> <span class="nf">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">),</span><span class="n">score</span> <span class="k">FROM</span> <span class="n">class</span> <span class="k">WHERE</span> <span class="n">score</span><span class="o">&gt;</span><span class="mi">60</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">score</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="442-having">4.4.2 HAVING</h4>
<p>HAVING关键字和 <code>WHERE</code> 关键字的作用相同，都是用于设置条件表达式，对查询结果进行过滤。</p>
<p>两者的区别，HAVING关键字后，可以跟聚合函数，而WHERE关键字不能，通常情况下，HAVING关键字，都是和GROUP BY一起使用，用于对分组后的结果进行过滤</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="c1">## 统计60分以上，各个分数的人数, 并且只筛选相同分数的人数小于10人的分组
</span><span class="c1"></span><span class="k">SELECT</span> <span class="nf">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">),</span><span class="n">score</span> <span class="k">FROM</span> <span class="n">class</span> <span class="k">WHERE</span> <span class="n">score</span><span class="o">&gt;</span><span class="mi">60</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">score</span> <span class="k">HAVING</span> <span class="nf">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="45-多表查询">4.5 多表查询</h3>
<ul>
<li>补充 可以给表起别名</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="c1"># 这里给表 phonelist 起了别名 p，多表操作别名很方便
</span><span class="c1"></span><span class="k">SELECT</span> <span class="n">p</span><span class="p">.</span><span class="n">name</span>  <span class="k">FROM</span> <span class="n">phonelist</span> <span class="n">p</span> <span class="k">where</span> <span class="n">p</span><span class="p">.</span><span class="n">id</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>多表查询,如果没有连接条件,则会产生笛卡尔积，实际运行环境下，应避免使用全笛卡尔集。</p>
</li>
<li>
<p>笛卡儿积，即如果有两个表，拿第一个表的一条数据跟第二个表每条数据都关联，这样的数据没有意义</p>
</li>
<li>
<p>在WHERE加入有效的连接条件（等值连接）。注意连接 n张表，至少需要 n-1个连接条件。</p>
</li>
</ul>
<p><a href="https://blog.csdn.net/wei_cheng18/article/details/80718222" target="_blank" rel="noopener noreffer">这个博客讲的很清楚</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">SELECT</span> <span class="n">a</span><span class="p">.</span><span class="n">t1</span> <span class="n">b</span><span class="p">.</span><span class="n">msg</span> <span class="k">FROM</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="k">WHERE</span> <span class="n">a</span><span class="p">.</span><span class="n">id</span><span class="o">=</span><span class="n">b</span><span class="p">.</span><span class="n">id</span><span class="p">;</span> <span class="c1">#这里id就是连接条件，id相同才会被关联
</span></code></pre></td></tr></table>
</div>
</div><h3 id="46-主键和外键">4.6 主键和外键</h3>
<ul>
<li>
<p>主键约束(PRIMARY KEY): 约束在当前表中,指定列的值非空且唯一。</p>
</li>
<li>
<p>外键约束(FOREIGN KEY): A表中的外键列的值必须引用于于B表中的某主键列。</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="o">`</span><span class="n">A</span><span class="o">`</span> <span class="k">ADD</span> <span class="k">FOREIGN</span> <span class="k">KEY</span><span class="p">(</span><span class="o">`</span><span class="n">myid</span><span class="o">`</span><span class="p">)</span> <span class="k">REFERENCES</span> <span class="o">`</span><span class="n">B</span><span class="o">`</span><span class="p">(</span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>如果建立外键后，要删除B中数据的时候，需要先删除A中相关的数据。</li>
<li>可以看作表A是B的附属，没有B，A就没有意义了；</li>
</ul>
<h3 id="47-子查询">4.7 子查询</h3>
<ul>
<li>
<p>子查询指的就是在一个查询之中嵌套了其他的若干查询。</p>
</li>
<li>
<p>在使用select语句查询数据时,有时候会遇到这样的情况，在where查询条件中的限制条件不是一个确定的值，而是一个来自于另一个查询的结果。</p>
</li>
<li>
<p>子查询一般出现在FROM和WHERE子句中。</p>
</li>
</ul>
<h4 id="471-子查询返回单行单列">4.7.1 子查询返回单行单列</h4>
<ul>
<li>单行单列子查询：只包含一个字段的查询，返回的查询结果也只包含一行数据, 看做是一个值. 使用在WHERE之后。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="c1"># 查询分数高于班级平均分的同学的姓名
</span><span class="c1"></span><span class="k">SELECT</span> <span class="n">name</span> <span class="k">FROM</span> <span class="n">class</span> <span class="k">WHERE</span> <span class="n">score</span><span class="o">&gt;</span><span class="p">(</span><span class="k">SELECT</span> <span class="nf">AVG</span><span class="p">(</span><span class="n">score</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">class</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="472-子查询返回多行单列">4.7.2 子查询返回多行单列</h4>
<ul>
<li>多行单列子查询：只包含了一个字段，但返回的查询结果可能多行或者零行，看做是多个值，使用在WHERE之后。</li>
</ul>
<table>
<thead>
<tr>
<th>关键字</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>IN</td>
<td>与列表中的任意一个值相等</td>
</tr>
<tr>
<td>ANY</td>
<td>与子查询返回的任意一个值比较</td>
</tr>
<tr>
<td>ALL</td>
<td>与子查询返回的每一个值比较</td>
</tr>
</tbody>
</table>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="c1"># 查询工资等于部门经理的员工信息.
</span><span class="c1"></span><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">emp</span> <span class="k">WHERE</span> <span class="n">sal</span> <span class="k">IN</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">sal</span> <span class="k">FROM</span> <span class="n">emp</span> <span class="k">WHERE</span> <span class="n">JOB</span><span class="o">=</span><span class="s1">&#39;manager&#39;</span><span class="p">);</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">emp</span> <span class="k">WHERE</span> <span class="n">sal</span> <span class="o">&gt;</span> <span class="nf">ANY</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">sal</span> <span class="k">FROM</span> <span class="n">emp</span> <span class="k">WHERE</span> <span class="n">JOB</span><span class="o">=</span><span class="s1">&#39;manager&#39;</span><span class="p">);</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">emp</span> <span class="k">WHERE</span> <span class="n">sal</span> <span class="o">&gt;</span> <span class="k">ALL</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">sal</span> <span class="k">FROM</span> <span class="n">emp</span> <span class="k">WHERE</span> <span class="n">JOB</span><span class="o">=</span><span class="s1">&#39;manager&#39;</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="473-子查询返回多行多列">4.7.3 子查询返回多行多列</h4>
<ul>
<li>多行多列子查询：包含多个字段的返回，查询结构可能是单行或者多行，看做是临时表，使用在FROM之后，临时表需要有别名。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="c1"># tmp是临时表别名
</span><span class="c1"></span><span class="k">SELECT</span> <span class="n">tmp</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">deptno</span><span class="p">,</span><span class="nf">AVG</span><span class="p">(</span><span class="n">sal</span><span class="p">)</span> <span class="n">avg_sal</span> <span class="k">FROM</span> <span class="n">emp</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">deptno</span><span class="p">)</span> <span class="n">tmp</span> <span class="k">WHERE</span> <span class="n">tmp</span><span class="p">.</span><span class="n">avg_sal</span> <span class="o">&gt;</span> <span class="mi">2000</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="48-备份与回复">4.8 备份与回复</h3>
<ul>
<li>备份</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">kirito@host:~$ mysqldump ‐u账户 ‐p密码 数据库名称&gt;文件存储地址
<span class="c1"># 栗子</span>
kirito@host:~$ mysqldump ‐uroot ‐p123456 testDB&gt; /home/kirito/testDB_bak.sql
</code></pre></td></tr></table>
</div>
</div><ul>
<li>恢复</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">kirito@host:~$ mysql ‐u账户 ‐p密码 数据库名称&lt; 文件存储地址 （数据库要已存在）
<span class="c1"># 栗子</span>
kirito@host:~$ mysql ‐uroot ‐p123456 testDB&lt; /home/kirito/_bak.sql
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="c1"># 也可以进入数据库导入
</span><span class="c1"></span><span class="k">CREATE</span> <span class="k">DATABASE</span> <span class="n">testdb</span><span class="p">;</span>
<span class="k">USE</span> <span class="n">testdb</span><span class="p">;</span>
<span class="n">SOURCE</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">kirito</span><span class="o">/</span><span class="n">_bak</span><span class="p">.</span><span class="k">sql</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="49-sql语句执行顺序">4.9 SQL语句执行顺序</h3>
<ul>
<li>书写顺序</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">SELECT</span> <span class="p">[</span><span class="k">DISTINCT</span><span class="p">]</span> <span class="p">[</span><span class="err">聚合函数</span><span class="p">]</span>
<span class="k">FROM</span>
<span class="k">WHERE</span>
<span class="k">GROUP</span> <span class="k">BY</span>
<span class="k">HAVING</span>
<span class="k">ORDER</span> <span class="k">BY</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>执行顺序</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">FROM</span>
<span class="k">WHERE</span>
<span class="k">GROUP</span> <span class="k">BY</span>   <span class="c1">#从这里开始可以使用别名
</span><span class="c1"></span><span class="err">聚合函数</span>
<span class="k">HAVING</span>
<span class="k">SELECT</span>
<span class="k">DISTINCT</span>
<span class="k">ORDER</span> <span class="k">BY</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="5-事务处理transaction">5 事务处理(transaction)</h2>
<p>在数据库中，所谓事务是指一组逻辑操作单元，使数据从一种状态变换到另一种状态。为确保数据库中数据的一致性，数据的操纵应当是离散的成组的逻辑单元:当它全部完成时，数据的一致性可以保持，而当这个单元中的一部分操作失败，整个事务应全部视为错误，所有从起始点以后的操作应全部回退到开始状态。</p>
<p>事务的操作:先定义开始一个事务，然后对数据作修改操作，这时如果提交(COMMIT)，这些修改就永久地保存下来，如果回退(ROLLBACK)，数据库管理系统将放弃您所作的所有修改而回到开始事务时的状态。</p>
<h3 id="51-事务的acid属性">5.1 事务的ACID属性</h3>
<ol>
<li>原子性（Atomicity）原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</li>
<li>一致性（Consistency）事务必须使数据库从一个一致性状态变换到另外一个一致性状态。(数据不被破坏).</li>
<li>隔离性（Isolation）事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰,每一个事务都存在一个事务空间,彼此不干扰。</li>
<li>持久性（Durability）持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响.</li>
</ol>
<h3 id="52-事务语句">5.2 事务语句</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="n">BEGIN</span> 	 <span class="c1"># 开启一个事务
</span><span class="c1"></span><span class="n">COMMIT</span> 	 <span class="c1"># 提交事务
</span><span class="c1"></span><span class="n">ROLLBACK</span> <span class="c1"># 回滚事务
</span><span class="c1"></span>
<span class="c1"># 栗子
</span><span class="c1"></span><span class="n">BEGIN</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">class</span> <span class="k">WHERE</span> <span class="n">id</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
<span class="k">UPDATE</span> <span class="n">class</span> <span class="kt">SET</span> <span class="n">score</span><span class="o">=</span><span class="mi">100</span> <span class="k">WHERE</span> <span class="n">id</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
<span class="n">COMMIT</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="53-事务并发问题">5.3 事务并发问题</h3>
<ul>
<li>数据库的事务并发问题: 存在五种问题:脏读，不可重复读，幻读，第一类丢失更新，第二类丢失更新。</li>
<li>详细见附录</li>
</ul>
<h3 id="54-锁机制">5.4 锁机制</h3>
<ul>
<li>mysql中使用repeatable read模式，只存在第二类丢失更新，通过加锁的方式可以避免。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">for</span> <span class="k">update</span> <span class="c1"># 加锁  锁释放发生在回滚和提交。
</span><span class="c1"># lock in share mode # 共享锁
</span><span class="c1"></span><span class="cm">/*
</span><span class="cm">for update仅适用于InnoDB，且必须在事务块(BEGIN/COMMIT)中才能生效。在进行事务操作时，通过“for
</span><span class="cm">update”语句，MySQL会对查询结果集中每行数据都添加排他锁，其他线程对该记录的更新与删除操作都会阻塞。排他锁包含行锁、表锁。
</span><span class="cm">*/</span>

<span class="c1"># 栗子
</span><span class="c1"></span><span class="n">BEGIN</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">class</span> <span class="k">WHERE</span> <span class="n">id</span><span class="o">=</span><span class="mi">1</span> <span class="k">FOR</span> <span class="k">UPDATE</span><span class="p">;</span> <span class="c1"># 加锁
</span><span class="c1"></span><span class="k">UPDATE</span> <span class="n">class</span> <span class="kt">SET</span> <span class="n">score</span><span class="o">=</span><span class="mi">100</span> <span class="k">WHERE</span> <span class="n">id</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
<span class="n">COMMIT</span><span class="p">;</span> <span class="c1"># 释放
</span></code></pre></td></tr></table>
</div>
</div><h2 id="附录">附录</h2>
<h3 id="a-数据类型">A 数据类型</h3>
<h4 id="a1-数值类型">A.1 数值类型</h4>
<p>MySQL支持所有标准SQL数值数据类型。</p>
<p>这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。</p>
<p>关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。</p>
<p>BIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。</p>
<p>作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。下面的表显示了需要的每个整数类型的存储和范围。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
<th>范围（有符号）</th>
<th>范围（无符号）</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>TINYINT</td>
<td>1 字节</td>
<td>(-128，127)</td>
<td>(0，255)</td>
<td>小整数值</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>2 字节</td>
<td>(-32 768，32 767)</td>
<td>(0，65 535)</td>
<td>大整数值</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td>3 字节</td>
<td>(-8 388 608，8 388 607)</td>
<td>(0，16 777 215)</td>
<td>大整数值</td>
</tr>
<tr>
<td>INT或INTEGER</td>
<td>4 字节</td>
<td>(-2 147 483 648，2 147 483 647)</td>
<td>(0，4 294 967 295)</td>
<td>大整数值</td>
</tr>
<tr>
<td>BIGINT</td>
<td>8 字节</td>
<td>(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td>
<td>(0，18 446 744 073 709 551 615)</td>
<td>极大整数值</td>
</tr>
<tr>
<td>FLOAT</td>
<td>4 字节</td>
<td>(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td>
<td>0，(1.175 494 351 E-38，3.402 823 466 E+38)</td>
<td>单精度 浮点数值</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>8 字节</td>
<td>(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>
<td>0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>
<td>双精度 浮点数值</td>
</tr>
<tr>
<td>DECIMAL</td>
<td>对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td>
<td>依赖于M和D的值</td>
<td>依赖于M和D的值</td>
<td>小数值</td>
</tr>
</tbody>
</table>
<h4 id="a2-日期和时间类型">A.2 日期和时间类型</h4>
<p>表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。</p>
<p>每个时间类型有一个有效值范围和一个&quot;零&quot;值，当指定不合法的MySQL不能表示的值时使用&quot;零&quot;值。</p>
<p>TIMESTAMP类型有专有的自动更新特性，将在后面描述。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>大小 (字节)</th>
<th>范围</th>
<th>格式</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>DATE</td>
<td>3</td>
<td>1000-01-01/9999-12-31</td>
<td>YYYY-MM-DD</td>
<td>日期值</td>
</tr>
<tr>
<td>TIME</td>
<td>3</td>
<td>&lsquo;-838:59:59&rsquo;/&lsquo;838:59:59&rsquo;</td>
<td>HH:MM:SS</td>
<td>时间值或持续时间</td>
</tr>
<tr>
<td>YEAR</td>
<td>1</td>
<td>1901/2155</td>
<td>YYYY</td>
<td>年份值</td>
</tr>
<tr>
<td>DATETIME</td>
<td>8</td>
<td>1000-01-01 00:00:00/9999-12-31 23:59:59</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>混合日期和时间值</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>4</td>
<td>1970-01-01 00:00:00/2038   结束时间是第 <strong>2147483647</strong> 秒，北京时间 <strong>2038-1-19 11:14:07</strong>，格林尼治时间 2038年1月19日 凌晨 03:14:07</td>
<td>YYYYMMDD HHMMSS</td>
<td>混合日期和时间值，时间戳</td>
</tr>
</tbody>
</table>
<h4 id="a3-字符串类型">A.3 字符串类型</h4>
<p>字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>CHAR</td>
<td>0-255字节</td>
<td>定长字符串</td>
</tr>
<tr>
<td>VARCHAR</td>
<td>0-65535 字节</td>
<td>变长字符串</td>
</tr>
<tr>
<td>TINYBLOB</td>
<td>0-255字节</td>
<td>不超过 255 个字符的二进制字符串</td>
</tr>
<tr>
<td>TINYTEXT</td>
<td>0-255字节</td>
<td>短文本字符串</td>
</tr>
<tr>
<td>BLOB</td>
<td>0-65 535字节</td>
<td>二进制形式的长文本数据</td>
</tr>
<tr>
<td>TEXT</td>
<td>0-65 535字节</td>
<td>长文本数据</td>
</tr>
<tr>
<td>MEDIUMBLOB</td>
<td>0-16 777 215字节</td>
<td>二进制形式的中等长度文本数据</td>
</tr>
<tr>
<td>MEDIUMTEXT</td>
<td>0-16 777 215字节</td>
<td>中等长度文本数据</td>
</tr>
<tr>
<td>LONGBLOB</td>
<td>0-4 294 967 295字节</td>
<td>二进制形式的极大文本数据</td>
</tr>
<tr>
<td>LONGTEXT</td>
<td>0-4 294 967 295字节</td>
<td>极大文本数据</td>
</tr>
</tbody>
</table>
<p>CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。</p>
<p>BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。</p>
<p>BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。</p>
<p>有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。</p>
<p>ALTER TABLE table_name DRO P INDEX index_name;</p>
<h3 id="b-并发问题">B 并发问题</h3>
<h4 id="b1-脏读dirty-read">B.1 脏读（dirty read</h4>
<p>A事物读取B事物尚未提交更改的数据，并在这个数据的基础上操作。如果B事物恰巧回滚，那么A事物读取到的事物是根本不被承认的。如下列：</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>事物A</th>
<th>事物B</th>
</tr>
</thead>
<tbody>
<tr>
<td>T1</td>
<td></td>
<td>开始事物</td>
</tr>
<tr>
<td>T2</td>
<td>开始事物</td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td>查询余额1000元</td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td>取出500元，余额改为500元</td>
</tr>
<tr>
<td>T5</td>
<td>查询余额500元（脏读）</td>
<td></td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td>撤销事物余额1000元</td>
</tr>
<tr>
<td>T7</td>
<td>汇入100元，余额改为600元</td>
<td></td>
</tr>
<tr>
<td>T8</td>
<td>提交事物</td>
<td></td>
</tr>
</tbody>
</table>
<p>在这个场景中B希望取出500元，而后又撤销了动作，而A往相同账户转入100元，就因为A读取到了B未提交更改数据，造成账户白白丢失500元。（注：在oracal数据库中，不会发生脏读的情况）</p>
<h4 id="b2-不可重复读unrepeatable-read">B.2 不可重复读（unrepeatable read）</h4>
<p>不可重复读是指：A事物读取到B事物已提交的更改数据。假设A在取款事物过程中，B往账户转入100元，A两次读取到的余额不一致。</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>事物A</th>
<th>事物B</th>
</tr>
</thead>
<tbody>
<tr>
<td>T1</td>
<td></td>
<td>开始事物</td>
</tr>
<tr>
<td>T2</td>
<td>开始事物</td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td>查询账户余额为1000元</td>
</tr>
<tr>
<td>T4</td>
<td>查询账户余额位1000元</td>
<td></td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td>取出100元，修改余额为900元</td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td>提交事物</td>
</tr>
<tr>
<td>T7</td>
<td>查询账户余额900元（和T4查询不一致）</td>
<td></td>
</tr>
</tbody>
</table>
<p>同一事务中两次查询账户余额不一致</p>
<h4 id="b3-幻读phantom-read">B.3 幻读（phantom read）</h4>
<p>A事物读取B事物提交的新增数据，这时A事物将出现幻读</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>事物A</th>
<th>事物B</th>
</tr>
</thead>
<tbody>
<tr>
<td>T1</td>
<td></td>
<td>开始事物</td>
</tr>
<tr>
<td>T2</td>
<td>开始事物</td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td>统计账户总存款为10000元</td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td>新增一个存款账户，并转入100元</td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td>提交事物</td>
</tr>
<tr>
<td>T6</td>
<td>再次统计存款为10100元（幻读）</td>
<td></td>
</tr>
</tbody>
</table>
<p>如果新增数据刚好满足查询条件，这个数据就会进入事物的视野，因而产生两次统计结果不一致的情况</p>
<p>注：幻读和不可重复读的区别在于前者读取到的是已提交的新增数据，后者读取到的是已提交的更新数据（或者删除的数据）。为了避免这两种情况，采取的策略是不同的，防止读到更改操作，只需要对操作数据添加行级锁，阻止操作中的数据发生变化；而防止读到新增数据，则往往添加表级锁&ndash;将整张表锁定，防止新增数据（Oracal通过多版本数据的方式实现）</p>
<h4 id="b4-第一类丢失更新">B.4 第一类丢失更新</h4>
<p>A事物撤销时，覆盖掉 B事物已提交的更新数据。</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>事物A</th>
<th>事物B</th>
</tr>
</thead>
<tbody>
<tr>
<td>T1</td>
<td></td>
<td>开始事物</td>
</tr>
<tr>
<td>T2</td>
<td>开始事物</td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td>查询账户为1000元</td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td>查询账户为1000元</td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td>转入100元，修改余额为1100元</td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td>提交事物</td>
</tr>
<tr>
<td>T7</td>
<td>取出100元，修改余额为900元</td>
<td></td>
</tr>
<tr>
<td>T8</td>
<td>撤销事物（或提交事物）</td>
<td></td>
</tr>
<tr>
<td>T9</td>
<td>余额回复为1000元（丢失更新）</td>
<td></td>
</tr>
</tbody>
</table>
<p>A事物在撤销时，将B事物转入的100元抹去了</p>
<h4 id="b5-第二类丢失更新">B.5 第二类丢失更新</h4>
<p>A事物覆盖B事物已提交的数据，造成B事物所有的操作丢失</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>事物A</th>
<th>事物B</th>
</tr>
</thead>
<tbody>
<tr>
<td>T1</td>
<td></td>
<td>开始事物</td>
</tr>
<tr>
<td>T2</td>
<td>开始事物</td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td>查询账户为1000元</td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td>查询账户为1000元</td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td>取出100元，修改余额为900元</td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td>提交事物</td>
</tr>
<tr>
<td>T7</td>
<td>转入100元</td>
<td></td>
</tr>
<tr>
<td>T8</td>
<td>提交事物</td>
<td></td>
</tr>
<tr>
<td>T9</td>
<td>修改余额为1100元（丢失更新）</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="b6-隔离级别">B.6 隔离级别</h4>
<p>为了解决上述的问题，提出了隔离级别的概念，不同的隔离级别可以处理的并发问题是不一样的。使用不同的隔离级别就可以阻止自己所期望的并发问题。</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复度</th>
<th>幻读</th>
<th>第一类丢失更新</th>
<th>第二类丢失更新</th>
</tr>
</thead>
<tbody>
<tr>
<td>READ UNCOMMITED</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>READ COMMITTED</td>
<td>×</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>REPREATABLE READ</td>
<td>×</td>
<td>×</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>√ 表示可能出现的情况， × 号表示不会出现</p>
</li>
<li>
<p>SQL92推荐使用REPREATABLE READ，用户可自定义</p>
</li>
</ul>
<h3 id="c-使用libmysqlclient库">C 使用libmysqlclient库</h3>
<p><code>g++ a.cpp -lmysqlclient -o a.out </code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//a.cpp 简单示例
</span><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;mysql/mysql.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="n">MYSQL</span> <span class="n">mysql</span><span class="p">,</span><span class="o">*</span><span class="n">sock</span><span class="p">;</span>  <span class="c1">//连接要用到
</span><span class="c1"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">host</span> <span class="o">=</span> <span class="s">&#34;127.0.0.1&#34;</span><span class="p">;</span> 	<span class="c1">//主机名
</span><span class="c1"></span>	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">user</span> <span class="o">=</span> <span class="s">&#34;root&#34;</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">passwd</span> <span class="o">=</span> <span class="s">&#34;123456&#34;</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">db</span> <span class="o">=</span> <span class="s">&#34;zsh&#34;</span><span class="p">;</span>     		<span class="c1">//数据库名字
</span><span class="c1"></span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">port</span> <span class="o">=</span> <span class="mi">3306</span><span class="p">;</span> 			<span class="c1">//不改动默认就是这个
</span><span class="c1"></span>	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">unix_socket</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">client_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 		<span class="c1">//一般0
</span><span class="c1"></span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">i_query</span> <span class="o">=</span> <span class="s">&#34;select * from phonelist&#34;</span><span class="p">;</span> <span class="c1">//查询语句
</span><span class="c1"></span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">MYSQL_RES</span> <span class="o">*</span> <span class="n">result</span><span class="p">;</span>
	<span class="n">MYSQL_ROW</span> <span class="n">row</span><span class="p">;</span>

	<span class="n">mysql_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mysql</span><span class="p">);</span> 	<span class="c1">//必须
</span><span class="c1"></span>
	<span class="k">if</span><span class="p">((</span><span class="n">sock</span> <span class="o">=</span> <span class="n">mysql_real_connect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mysql</span><span class="p">,</span><span class="n">host</span><span class="p">,</span><span class="n">user</span><span class="p">,</span><span class="n">passwd</span><span class="p">,</span><span class="n">db</span><span class="p">,</span><span class="n">port</span><span class="p">,</span><span class="n">unix_socket</span><span class="p">,</span><span class="n">client_flag</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">){</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">mysql_errno</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mysql</span><span class="p">);</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&#34;connect error,errno %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">ret</span><span class="p">);</span>
		<span class="c1">//fprintf(stderr,&#34;%s\n&#34;,mysql_error(&amp;mysql));
</span><span class="c1"></span>		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span><span class="k">else</span><span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="s">&#34;connect success</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mysql_query</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mysql</span><span class="p">,</span><span class="s">&#34;set names utf8&#34;</span><span class="p">);</span><span class="c1">//在连接后使用，中文显示正常
</span><span class="c1"></span>    <span class="cm">/*
</span><span class="cm">      这一句等于
</span><span class="cm">      SET character_set_client = utf8;
</span><span class="cm">      SET character_set_results = utf8;
</span><span class="cm">      SET character_set_connection = utf8; 
</span><span class="cm">     */</span>

	<span class="k">if</span><span class="p">(</span><span class="n">mysql_query</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mysql</span><span class="p">,</span><span class="n">i_query</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">){</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="s">&#34;query error</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span><span class="k">else</span><span class="p">{</span>
		<span class="k">if</span><span class="p">((</span><span class="n">result</span> <span class="o">=</span> <span class="n">mysql_store_result</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mysql</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">){</span>
			<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="s">&#34;save result error</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
			<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span><span class="k">else</span><span class="p">{</span>

			<span class="kt">int</span> <span class="n">field_num</span> <span class="o">=</span> <span class="n">mysql_field_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mysql</span><span class="p">);</span> <span class="c1">//获得列数
</span><span class="c1"></span>			<span class="n">MYSQL_FIELD</span> <span class="o">*</span> <span class="n">fields</span> <span class="o">=</span> <span class="n">mysql_fetch_fields</span><span class="p">(</span><span class="n">result</span><span class="p">);</span> <span class="c1">//列名
</span><span class="c1"></span>
			<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">field_num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
				<span class="n">printf</span><span class="p">(</span><span class="s">&#34;%s </span><span class="se">\t</span><span class="s">&#34;</span><span class="p">,</span><span class="n">fields</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">);</span>
			<span class="p">}</span><span class="n">putchar</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">);</span>

			<span class="k">while</span><span class="p">((</span><span class="n">row</span> <span class="o">=</span> <span class="n">mysql_fetch_row</span><span class="p">(</span><span class="n">result</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">){</span>
				<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">field_num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
					<span class="n">printf</span><span class="p">(</span><span class="s">&#34;%s </span><span class="se">\t</span><span class="s">&#34;</span><span class="p">,</span><span class="n">row</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
				<span class="p">}</span><span class="n">putchar</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">);</span>
			<span class="p">}</span>

		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">mysql_free_result</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
	<span class="n">mysql_close</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
	<span class="n">exit</span><span class="p">(</span><span class="n">EXIT_SUCCESS</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div>]]></description>
</item><item>
    <title>CPP知识点笔记</title>
    <link>https://www.kirito41dd.cn/cpp-note/</link>
    <pubDate>Sat, 23 Dec 2017 19:33:15 &#43;0800</pubDate>
    <author>kirito</author>
    <guid>https://www.kirito41dd.cn/cpp-note/</guid>
    <description><![CDATA[<p>记录cpp中大部分的知识点，个人理解有限，不一定都正确。</p>
<h2 id="22-cout控制输出长度格式">2.2 cout控制输出长度/格式：</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">setw</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>   <span class="c1">//setw()在头文件&lt;iomanip&gt;中，只能右对齐，等价%8d
</span><span class="c1"></span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">setiosflags</span><span class="p">(</span><span class="n">ios</span><span class="o">::</span><span class="n">left</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">setw</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span><span class="c1">//这样为左对齐
</span><span class="c1"></span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">setw</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">setprecision</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">setiosflags</span><span class="p">(</span><span class="n">ios</span><span class="o">::</span><span class="n">fixed</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">b</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span><span class="c1">//b是一个浮点数，等价于%8.2f
</span><span class="c1"></span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">setfill</span><span class="p">(</span><span class="sc">&#39;x&#39;</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">set</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span><span class="c1">//将空白用x填充
</span><span class="c1"></span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">hex</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span><span class="c1">//等价于printf(&#34;%x\n&#34;,a);十六进制
</span><span class="c1"></span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">oct</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span><span class="c1">//等价于printf(&#34;%o\n&#34;,a);八进制
</span><span class="c1"></span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span><span class="c1">//等价于printf(&#34;%d\n&#34;,a);十进制
</span></code></pre></td></tr></table>
</div>
</div><h2 id="23-函数重载静多态">2.3 函数重载（静多态）</h2>
<p>匹配原则</p>
<ol>
<li>严格匹配</li>
<li>隐式转换（小到大可以，大到小不可以）寻求匹配，找到则匹配</li>
<li>返回值不构成重载</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">extern</span> <span class="s">&#34;C&#34;</span><span class="p">{}</span> <span class="c1">//将括号内按c的方式编译，不与其他同名函数重载。c库每一个头文件都有
</span><span class="c1">//---------------------------------------------------------
</span><span class="c1"></span><span class="cp">#ifdef __cplusplus</span><span class="c1">//如果是c++编译器
</span><span class="c1"></span><span class="k">extern</span> <span class="s">&#34;c&#34;</span><span class="p">{</span>
<span class="cp">#endif </span><span class="c1">// __cplusplus
</span><span class="c1"></span>
<span class="c1">// 内容
</span><span class="c1"></span>
<span class="cp">#ifdef __cplusplus
</span><span class="cp"></span><span class="p">}</span>
<span class="cp">#endif          </span><span class="c1">//表示不使用c++的重载特性
</span><span class="c1">//----------------------------------------------------------
</span></code></pre></td></tr></table>
</div>
</div><h2 id="24-运算符重载operator-overload">2.4 <strong><ruby>运算符重载<rt>Operator Overload</rt></ruby></strong></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp">    <span class="c1">//运算符其实就是函数
</span><span class="c1"></span>    <span class="k">struct</span> <span class="nc">zuobiao</span>  <span class="c1">//坐标
</span><span class="c1"></span>    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">x</span><span class="p">;</span><span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="n">zuobiao</span> <span class="k">operator</span> <span class="o">+</span> <span class="p">(</span><span class="n">zuobiao</span> <span class="n">a</span><span class="p">,</span><span class="n">zuobiao</span> <span class="n">b</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">zuobiao</span> <span class="n">c</span><span class="p">;</span>
        <span class="n">c</span><span class="p">.</span><span class="n">x</span><span class="o">=</span><span class="n">a</span><span class="p">.</span><span class="n">x</span><span class="o">+</span><span class="n">b</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>  <span class="n">c</span><span class="p">.</span><span class="n">y</span><span class="o">=</span><span class="n">a</span><span class="p">.</span><span class="n">y</span><span class="o">+</span><span class="n">b</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="25-默认参数default-parameters">2.5 <strong><ruby>默认参数<rt>Default Parameters</rt></ruby></strong></h2>
<p>参数只能从右往左默认，中间不能跳跃</p>
<h2 id="26-引用raference">2.6 <strong><ruby>引用<rt>Raference</rt></ruby></strong></h2>
<p><code>&amp;</code>前为类型名时为引用，其他均为取地址</p>
<p>变量名，本身是一段内存的引用，即别名（alias）。此处引入的引用是为已有变量起一个别名，声明如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">&amp;</span><span class="n">ra</span><span class="o">=</span><span class="n">a</span><span class="p">;</span>
<span class="c1">//1. 引用是一种声明关系，必须初始化，引用不开辟空间
</span><span class="c1">//2. 此种声明关系一经声明 不可变更
</span><span class="c1"></span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">rr</span><span class="o">=</span><span class="n">ra</span><span class="p">;</span>
<span class="c1">//3. 可以对引用，再次引用。多次引用的结果，多个引用指向同一个变量
</span><span class="c1">//引用的本质是对指针的包装，指针可以有引用，但不应该有引用的指针
</span><span class="c1"></span>
<span class="c1">//const int&amp;ra=a; 能用const就用；use const whatever possible
</span><span class="c1">//思考：引用的本质是什么？  int &amp; ra = a；   int * const p = &amp;a;  引用的本质是不可以修改指向的指针；
</span></code></pre></td></tr></table>
</div>
</div><h2 id="27-newdelete申请动态内存">2.7 new/delete(申请动态内存)</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>   <span class="c1">//开一个int类型单变量并初始化为200
</span><span class="c1"></span><span class="kt">int</span> <span class="o">*</span><span class="n">ps</span> <span class="o">=</span> <span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="s">&#34;hellwo world&#34;</span><span class="p">);</span><span class="c1">//开一个string类型单变量并初始化为 hellow world
</span><span class="c1"></span><span class="kt">int</span> <span class="o">*</span><span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">5</span><span class="p">]{</span><span class="mi">0</span><span class="p">};</span><span class="c1">//开一个int数组 每一项初始化为0；
</span><span class="c1"></span><span class="kt">int</span> <span class="o">**</span><span class="n">pp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">*</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span><span class="c1">//指针数组，存放的指针
</span><span class="c1"></span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="p">{{</span><span class="mi">0</span><span class="p">}};</span><span class="c1">//p是一个指针 它指向包含4个int元素的一维数组 p为首地址 记不住怎么写编译器可以给你提示
</span><span class="c1">//也可以new一个结构体  但初始化应用 {} 因为可能有有多个值
</span><span class="c1"></span><span class="cm">/*应用程序在内存中分为
</span><span class="cm">    代码区、
</span><span class="cm">    全局(静态)数据存储区、
</span><span class="cm">    栈区、
</span><span class="cm">    堆区。
</span><span class="cm">    通过new出来的内存在堆区。
</span><span class="cm">    局部变量，函数参数等存在栈区
</span><span class="cm">*/</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span> <span class="p">;</span>
<span class="k">delete</span> <span class="n">p</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="k">delete</span> <span class="p">[]</span><span class="n">p</span><span class="p">;</span>
<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)[</span><span class="mi">4</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">4</span><span class="p">][</span><span class="mi">3</span><span class="p">];</span>
<span class="k">delete</span> <span class="p">[]</span><span class="n">p</span><span class="p">;</span>
<span class="c1">//异常处理  new很少出错 一般别用
</span><span class="c1"></span><span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">new</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">nothrow</span><span class="p">)</span> <span class="kt">int</span> <span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">){</span><span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">}</span><span class="c1">//NULL 好像变成nullptr了c++11
</span></code></pre></td></tr></table>
</div>
</div><h2 id="28-内联函数">2.8 内联函数</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sqr</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="p">;</span>
<span class="p">}</span><span class="c1">//inline 是给编译器的一种建议，编译器来决定是否inline，但你不说编译器一定不inline    66666
</span><span class="c1">//适用环境 函数体很小 且 频繁使用
</span></code></pre></td></tr></table>
</div>
</div><h2 id="29-cast强制类型转换">2.9 cast强制类型转换</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="mi">5</span><span class="p">;</span>    <span class="kt">float</span> <span class="n">b</span><span class="o">=</span><span class="mf">6.5</span><span class="p">;</span>
<span class="k">static_cast</span> <span class="c1">//对于隐式类型可以转化的，可用这个
</span><span class="c1"></span><span class="n">b</span><span class="o">=</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>  <span class="c1">//作者不想让你强转，所以搞这么麻烦 哈啊哈
</span><span class="c1"></span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span><span class="kt">int</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
<span class="n">p</span><span class="o">=</span><span class="n">q</span><span class="p">;</span><span class="c1">//可以
</span><span class="c1"></span><span class="n">q</span><span class="o">=</span><span class="n">p</span><span class="p">;</span><span class="c1">//不可以 q=static_cast&lt;int*&gt;(p);OK
</span><span class="c1"></span><span class="k">dynamic_cast</span>
<span class="k">reinterpret_cast</span> <span class="c1">//对于无隐式类型的转化，static_cast无效，例如将int赋值给int*指针  reinterpert重新解释
</span><span class="c1"></span><span class="k">const_cast</span> <span class="c1">//脱常   只能用于指针和引用
</span><span class="c1"></span><span class="kt">void</span> <span class="n">fun1</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">v</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">fun1</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>        <span class="c1">//这是传不进去的
</span><span class="c1"></span>    <span class="n">fun1</span><span class="p">(</span><span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">int</span> <span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">));</span><span class="c1">//这样就传进去了  不要妄图用这个方法修改const  其行为是未定义的且没有意义
</span><span class="c1"></span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="210-const">2.10 const</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#define N 200       </span><span class="c1">//宏，在预处理阶段发生了替换
</span><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>  <span class="c1">//在编译阶段发生了替换
</span><span class="c1">//所以const永远不会发生改变
</span></code></pre></td></tr></table>
</div>
</div><h2 id="211-命名空间namespace">2.11 <strong><ruby>命名空间<rt>Namespace</rt></ruby></strong></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">v</span><span class="o">=</span><span class="mi">55</span><span class="p">;</span>
<span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">v</span><span class="o">=</span><span class="mi">5</span><span class="p">;</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">v</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span><span class="c1">//打印局部变量
</span><span class="c1"></span>    <span class="n">cout</span><span class="o">&lt;&lt;::</span><span class="n">v</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span><span class="c1">//打印全局变量
</span><span class="c1"></span><span class="p">}</span><span class="c1">//全局命名空间其实是一个没有名字的命名空间，也可以用::作用域运算符访问。
</span><span class="c1"></span>
<span class="k">namespace</span> <span class="c1">//是对全局命名空间的再次划分
</span><span class="c1"></span><span class="k">namespace</span> <span class="n">name</span><span class="c1">//协同开发 可以在不同文件中定义同名空间，将自动合并
</span><span class="c1"></span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">void</span> <span class="nf">func</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;haha&#34;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">struct</span> <span class="nc">xy</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">x</span><span class="p">;</span><span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="c1">//可以写很多，包括再写一个命名空间
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="212-字符串类型string">2.12 字符串类型string</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//位于命名空间std；它是一个类不是关键字
</span><span class="c1">//用cin输入时有空格会结束，但输出时字符串里可以有空格
</span><span class="c1"></span><span class="n">string</span> <span class="n">str</span><span class="o">=</span><span class="s">&#34;china&#34;</span><span class="err">，</span><span class="n">s2</span><span class="o">=</span><span class="s">&#34;0&#34;</span><span class="p">;</span>
<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">str</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">enld</span><span class="p">;</span> <span class="c1">//获得长度
</span><span class="c1"></span>
<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
<span class="n">strcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="n">str</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span><span class="c1">//strcpy位于string.h   str.c_str()对象函数返回一个c语言类型的字符串，以兼容c
</span><span class="c1"></span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">buf</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>

<span class="n">str</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">s2</span><span class="p">);</span><span class="c1">//用对象方法交换
</span><span class="c1"></span>
<span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="n">str</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span><span class="c1">//查找a，返回下标，第二个参数为从0开始，找不到返回-1
</span><span class="c1"></span><span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="n">str</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">&#34;in&#34;</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span><span class="c1">//查找字串,有返回首下标，没有返回-(
</span><span class="c1"></span>
<span class="c1">//删空格
</span><span class="c1"></span><span class="n">string</span> <span class="n">ss</span><span class="o">=</span><span class="s">&#34;   sdfsdfs     &#34;</span><span class="p">;</span>
<span class="n">ss</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">ss</span><span class="p">.</span><span class="n">find_first_not_of</span><span class="p">(</span><span class="sc">&#39; &#39;</span><span class="p">));</span><span class="c1">//从0删到第一个不是空格，参数一从什么地方删，参数二删几个
</span><span class="c1"></span><span class="n">ss</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">ss</span><span class="p">.</span><span class="n">find_last_not_of</span><span class="p">(</span><span class="sc">&#39; &#39;</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span><span class="c1">//从最后一个不是空格删到最后
</span></code></pre></td></tr></table>
</div>
</div><h2 id="31-封装encapsulation">3.1 <strong><ruby>封装<rt>Encapsulation</rt></ruby></strong></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//c语言的封装风格，数据放在一起打包为struck，然后吧数据以引用或指针的方式传递给行为。
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">date</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">year</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">month</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">day</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="nf">init</span><span class="p">(</span><span class="n">date</span> <span class="o">&amp;</span> <span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">d</span><span class="p">.</span><span class="n">year</span><span class="p">;</span>
    <span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">d</span><span class="p">.</span><span class="n">month</span><span class="p">;</span>
    <span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">d</span><span class="p">.</span><span class="n">day</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//c++认为c封装不彻底，1数据和行为分离，2没有权限控制。
</span><span class="c1">//权限控制 private protected public
</span><span class="c1"></span><span class="k">class</span> <span class="nc">date2</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">year</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">month</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">day</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">viod</span> <span class="n">print</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">year</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="c1">//类名也是一种特别的名称空间
</span></code></pre></td></tr></table>
</div>
</div><h2 id="32-类的构造器constructor">3.2 <strong><ruby>类的构造器<rt>constructor</rt></ruby></strong></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//constructor 构造器
</span><span class="c1">//1.与类名相同，无返回值，生成对象时自动调用，用于初始化
</span><span class="c1">//2.可以有参数，可以重载，默认参数
</span><span class="c1"></span><span class="k">class</span> <span class="nc">sss</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">sss</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;我是构造器&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">sss</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="n">sss</span> <span class="nf">s</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span><span class="c1">//使用构造器的重载， 创建对象时加参数
</span></code></pre></td></tr></table>
</div>
</div><h2 id="322-类的析构器destructor">3.2.2 <strong><ruby>类的析构器<rt>destructor</rt></ruby></strong></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//1.~类名（）无参无反，对象销毁时的内存处理工作
</span><span class="c1"></span><span class="k">class</span> <span class="nc">sss</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="o">~</span><span class="n">ksss</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;我是析构器&#34;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="41-自实现string">4.1 自实现string</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//代码in坚果云
</span><span class="c1"></span><span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">A</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="c1">//参数列表，效率高，在函数声明之后，实现体之前，：开头
</span><span class="c1"></span>    <span class="o">:</span><span class="n">x</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="n">y</span><span class="p">(</span><span class="n">j</span><span class="p">),</span><span class="n">z</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="c1">//初始化顺序，跟变量的声明顺序有关，初始化列表中的顺序无关，即xyz顺序可变
</span><span class="c1"></span>    <span class="p">{</span>

    <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">;</span>

<span class="p">};</span>
<span class="c1">//拷贝构造器
</span><span class="c1"></span>    <span class="c1">//由已存在的对象，创建新对象，也就是所新对象不是由构造器来构造，而是由
</span><span class="c1"></span>    <span class="c1">//拷贝构造器来完成，拷贝构造器的格式是固定的
</span><span class="c1"></span><span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
    <span class="n">A</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span> <span class="o">&amp;</span> <span class="n">another</span><span class="p">)</span><span class="c1">//&amp;是引用
</span><span class="c1"></span><span class="p">};</span>
    <span class="c1">//若不提供，系统提供默认，自定义是系统不再提供默认
</span><span class="c1"></span>    <span class="c1">//系统提供的默认是一种等位拷贝，浅浅的拷贝，会导致内存重析构。doble free
</span><span class="c1"></span>    <span class="c1">//含有堆空间时要自实现拷贝
</span><span class="c1"></span>
<span class="c1">//友元 同类对象无私处，异类对象有友元
</span><span class="c1"></span>
<span class="c1">//运算符重载
</span><span class="c1"></span>    <span class="c1">//赋值运算符重载
</span><span class="c1"></span>    <span class="n">string</span> <span class="n">s4</span><span class="o">=</span><span class="n">s3</span><span class="p">;</span><span class="c1">//本质不是赋值，而是拷贝构造，在声明时候=号表示初始化
</span><span class="c1">//this指针
</span><span class="c1"></span>    <span class="c1">//系统创建对象时，默认生成当前对象的this指针。
</span><span class="c1">//对对象来说，传引用效率很高，不然调用拷贝构造效率低。
</span><span class="c1">//栈上的对象可以返回，但不能返回栈上的引用（除非实例不会销毁，比如对象方法返回自己，结束后对象还在，引用有效）
</span><span class="c1"></span>    <span class="n">A</span> <span class="o">&amp;</span> <span class="n">func</span><span class="p">(){</span><span class="c1">//这是错的，func执行完b会销毁，但这个回传的引用仍指向这个地址
</span><span class="c1"></span>        <span class="n">A</span> <span class="n">b</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="51-const-static-修饰类">5.1 const static 修饰类</h2>
<p>static</p>
<ol>
<li>在c中，修饰全部变量表示吧作用于限制在本文件内</li>
<li>修饰局部变量表示吧变量生命周期提升为全局</li>
<li>c++中在类内部，用来实现族类对象间的数据共享。</li>
<li>c++中，修饰类成员时，表示这个成员变量属于整个类，而不是某个对象（既属于类，也属于对象，但终归于类）
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">static</span> <span class="kt">int</span> <span class="n">a</span><span class="p">;</span><span class="c1">//声明写在类内
</span><span class="c1"></span><span class="kt">int</span> <span class="n">A</span><span class="o">::</span><span class="n">a</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="c1">//初始化写在内外
</span></code></pre></td></tr></table>
</div>
</div></li>
<li>修饰成员函数时，也属于整个类；因为他属于类，没有this指针（this只有对象实例有）
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//不能访问数据成员及成员，没有this
</span><span class="c1"></span><span class="k">static</span> <span class="n">string</span> <span class="nf">getstr</span><span class="p">();</span>
<span class="k">const</span> <span class="k">static</span> <span class="kt">int</span> <span class="n">h</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="c1">//static const 修饰数据成员，必须在类内初始化；就地初始化
</span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
<p>const</p>
<ol>
<li>修饰数据成员，初始化位置只能在 参数列表里；（新版本虽然可以直接等于号初始化，但别被惯傻了）</li>
<li>修饰成员函数（注意不是修饰返回类型），位置放在声明之后，实现体之前，大概也没有别的地方可以放了（haha）</li>
<li>const函数承诺不会修改数据成员，也只能调用其他const函数。</li>
<li>还可以构成重载（wtf？）
<ul>
<li>修饰类对象，从对象层面不修改成员，只能调用const成员函数，构成重载就是配饰有无const的对象的情况</li>
<li>即const对象只能调用const成员函数，非const对象优先调用非const成员函数（若无则调用const成员函数）</li>
</ul>
</li>
</ol>
<h2 id="52-指向类成员的指针">5.2 指向类成员的指针</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//都指向非静态成员
</span><span class="c1"></span><span class="s">&#34;成员类型 类名::* 指针名 = &amp;类名::成员名&#34;</span>
<span class="k">class</span> <span class="nc">stuu</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="nf">print</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="p">};</span>
    <span class="c1">//指向数据成员
</span><span class="c1"></span>        <span class="c1">//在定义时必须和类关联，使用时必须和对象关联
</span><span class="c1"></span>            <span class="kt">int</span> <span class="n">stuu</span><span class="o">::*</span> <span class="n">pa</span><span class="o">=&amp;</span><span class="n">stuu</span><span class="o">::</span><span class="n">a</span><span class="p">;</span>
            <span class="n">stuu</span> <span class="n">dx</span><span class="p">;</span>
            <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">dx</span><span class="p">.</span><span class="o">*</span><span class="n">pa</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
            <span class="c1">//(内部实现，实际上时记录了偏移量)
</span><span class="c1"></span>    <span class="c1">//指向函数成员
</span><span class="c1"></span>        <span class="c1">//
</span><span class="c1"></span>        <span class="kt">void</span> <span class="p">(</span><span class="n">stuu</span><span class="o">::*</span><span class="n">pf</span><span class="p">)()</span><span class="o">=&amp;</span><span class="n">stuu</span><span class="o">::</span><span class="n">print</span><span class="p">;</span>
        <span class="p">(</span><span class="n">dx</span><span class="p">.</span><span class="o">*</span><span class="n">pf</span><span class="p">)();</span>

    <span class="nl">tip</span><span class="p">:</span><span class="c1">//在类中想用常量时
</span><span class="c1"></span>        <span class="k">enum</span><span class="p">{</span><span class="n">cnt</span><span class="o">=</span><span class="mi">4</span><span class="p">};</span><span class="c1">//因为用const必须参数列表初始化，static const 太浪费
</span></code></pre></td></tr></table>
</div>
</div><h2 id="53-友元">5.3 友元</h2>
<ol>
<li>友元可以是友元函数，友元类，异类才有友元（同类无私处）</li>
<li>友元是单方面的，你拿我当朋友不等于我也拿你当朋友(涩会涩会)</li>
<li>访问时必须通过
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
    <span class="k">friend</span> <span class="kt">void</span> <span class="nf">dis</span><span class="p">(</span><span class="n">A</span> <span class="o">&amp;</span> <span class="n">t</span><span class="p">);</span>
    <span class="k">friend</span> <span class="k">class</span> <span class="nc">B</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// 该函数可以访问A的私有成员
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">dis</span><span class="p">(</span><span class="n">A</span> <span class="o">&amp;</span> <span class="n">t</span><span class="p">);</span><span class="c1">//访问时必须通过对象访问，因为他不是成员函数
</span><span class="c1">// 该类可以访问A的私有成员
</span><span class="c1"></span><span class="k">class</span> <span class="nc">B</span><span class="p">{</span><span class="kt">void</span> <span class="nf">dis</span><span class="p">(</span><span class="n">A</span> <span class="o">&amp;</span> <span class="n">t</span><span class="p">);};</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ol>
<h2 id="54-单双目运算符重载">5.4 单双目运算符重载</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//不能重载的运算符
</span><span class="c1"></span>    <span class="p">.</span>  <span class="p">.</span><span class="o">*</span>  <span class="o">::</span>  <span class="o">?:</span>  <span class="k">sizeof</span> <span class="c1">//sizeof是运算符，不是函数
</span><span class="c1">//除了=号外，基类中被重载的操作符都将被派生类继承
</span><span class="c1"></span>    <span class="c1">//“赋值运算符重载函数”不是不能被派生类继承，而是被派生类的默认“赋值运算符重载函数”给shadow了
</span><span class="c1">//通常情况下，双目运算符重载为成员需要一个参数，重载为友元要两个参数，做成员时this也是参数
</span><span class="c1">//重载-（负号）时用const修饰成员函数，-c=t就不会过编译了，这才是对的，注意-(-c)所以只能用const修饰成员函数而不是返回值。
</span><span class="c1">//
</span><span class="c1"></span>    <span class="n">Clock</span> <span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="n">Clock</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="c1">//前置单目运算符 ++c
</span><span class="c1"></span>    <span class="n">Clock</span> <span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="n">Clock</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span><span class="kt">int</span><span class="p">)</span> <span class="c1">//后置单目运算符 c++
</span><span class="c1">//day 6.2
</span><span class="c1">//流输入输出运算符重载
</span><span class="c1"></span>    <span class="n">istream</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">istream</span><span class="o">&amp;</span><span class="p">,</span><span class="err">自定义类</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="n">ostream</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">istream</span><span class="o">&amp;</span><span class="p">,</span><span class="k">const</span> <span class="err">自定义类</span><span class="o">&amp;</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="55-类型转化">5.5 类型转化</h2>
<ol>
<li>使用 类型转化构造器
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//实现 其他类型 到 本类型 的转化
</span><span class="c1"></span><span class="k">class</span> <span class="err">本类型</span>
<span class="p">{</span>
    <span class="err">本类型</span><span class="p">(</span><span class="k">const</span> <span class="err">其他类型</span> <span class="o">&amp;</span> <span class="n">Ta</span><span class="p">)</span> <span class="c1">//这是一个构造器
</span><span class="c1"></span>    <span class="p">[</span>
        <span class="c1">//实现转化
</span><span class="c1"></span>        <span class="c1">//this-&gt;data = Ta.data ;
</span><span class="c1"></span>    <span class="p">]</span>
<span class="p">};</span>
<span class="err">本类型</span> <span class="o">=</span> <span class="err">其他类型</span><span class="p">;</span> <span class="c1">//隐式转化可用  先调用类型转化，在调用赋值运算符重载
</span><span class="c1">//我们把只有一个参数的构造器成为类型转化构造器
</span><span class="c1"></span><span class="k">explicit</span> <span class="c1">//加在转化构造器前表示只能使用 显式转化
</span><span class="c1"></span><span class="err">本类型</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="err">本类型</span><span class="o">&gt;</span><span class="p">(</span><span class="err">其他类型</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>使用 类型转换操作符函数
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="err">源类</span>
<span class="p">{</span>
    <span class="c1">//无参无返回
</span><span class="c1"></span>    <span class="k">operator</span> <span class="err">目标类型</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">//根据需要进行转化
</span><span class="c1"></span>        <span class="c1">//目类标型.data = this-&gt;data;
</span><span class="c1"></span>        <span class="k">return</span> <span class="err">目标类型</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">data2</span><span class="p">,</span><span class="k">this</span><span class="p">.</span><span class="n">data2</span><span class="p">);</span><span class="c1">//特殊，里面有返回,
</span><span class="c1"></span>        <span class="c1">//实际也可以这么写
</span><span class="c1"></span>        <span class="err">目标类型</span> <span class="n">swa</span><span class="p">;</span>
        <span class="n">swa</span><span class="p">.</span><span class="n">data1</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">data1</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">swa</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ol>
<h2 id="56-运算符重载提高篇">5.6 运算符重载提高篇</h2>
<ol>
<li>函数操作符()重载 &ndash; 仿函数
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//把类对象当作函数名使用，主要应与于STL和模板
</span><span class="c1"></span><span class="k">class</span> <span class="err">类名</span>
<span class="p">{</span>
    <span class="err">返回值类型</span> <span class="nf">operator</span><span class="p">()</span> <span class="p">(</span><span class="err">参数类型</span><span class="p">)</span>
    <span class="p">{</span>

    <span class="p">}</span>
<span class="p">};</span>
<span class="c1">//lambda 本质就是仿函数
</span><span class="c1"></span>
<span class="k">operator</span> <span class="nf">bool</span><span class="p">();</span><span class="c1">//对象可以对void * 重载,if(A)情况，会调用bool();
</span><span class="c1"></span><span class="k">operator</span> <span class="kt">void</span> <span class="o">*</span><span class="p">();</span><span class="c1">//对象可以对void * 重载，if(A)情况，没有bool()会调用void*(),然后void*被强转成bool;
</span></code></pre></td></tr></table>
</div>
</div></li>
<li>重载 <code>new delete new[] delete[]</code>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//定制化时使用，给特定类定制
</span><span class="c1"></span><span class="kt">void</span> <span class="o">*</span> <span class="k">operator</span> <span class="nf">new</span><span class="p">(</span><span class="n">size_t</span><span class="p">)</span>
<span class="kt">void</span> <span class="k">operator</span> <span class="k">delete</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span>
<span class="kt">void</span> <span class="o">*</span> <span class="k">operator</span> <span class="k">new</span><span class="p">[](</span><span class="n">size_t</span><span class="p">)</span>
<span class="kt">void</span> <span class="k">operator</span> <span class="k">delete</span><span class="p">[](</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span>
<span class="c1">//注：operator new 中 size_t 参数是编译器自动计算传递的 其实是 unsigned int
</span><span class="c1"></span>
<span class="c1">//了解一下就行↓
</span><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">class</span> <span class="nc">A</span><span class="p">{</span><span class="kt">int</span> <span class="n">a</span><span class="p">;};</span>
<span class="n">auto_ptr</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">ptr</span><span class="p">(</span><span class="k">new</span> <span class="n">A</span><span class="p">);</span> <span class="c1">//auto_ptr 类模板 auto_ptr&lt;A&gt;模板类
</span><span class="c1"></span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
<span class="c1">//一个对象的行为想指针，重载了 -&gt; () *
</span><span class="c1">//new被ptr托管后，不需要再关心delete的问题
</span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
<h2 id="61-继承与派生inheritderive">6.1 <strong><ruby>继承与派生<rt>Inherit&amp;Derive</rt></ruby></strong></h2>
<ol>
<li>c++ 通过继承关系实现了代码的可重用性。
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="err">派生类名:继承方式 基类名</span>
<span class="p">{</span>

<span class="p">};</span>
<span class="c1">//一个派生类可以有多个基类
</span><span class="c1">//继承方式 public protected private
</span><span class="c1"></span><span class="cm">/*
</span><span class="cm">            父类        公有继承    保护继承        私有继承
</span><span class="cm">    成员属性↘ public      public       protected      private
</span><span class="cm">            protected   protected    protected      private
</span><span class="cm">            private     不可访问     不可访问       不可访问（inaccessable）
</span><span class="cm">*/</span>

<span class="k">protected</span> <span class="err">对于外界访问属性来说等同于</span> <span class="k">private</span><span class="err">，但在派生类中可见</span>

<span class="err">几点说明</span><span class="o">:</span>
<span class="o">*</span> <span class="err">可见不可见都全盘接收，除了构造器与析构器，基类可能会造成派生类的成员冗余，是需要设计的</span>
<span class="o">*</span> <span class="err">派生类有了自己的个性，才有意义</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>派生类的构造器
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="err">类名</span><span class="p">(</span><span class="err">参数总列表</span><span class="p">)</span>
    <span class="o">:</span><span class="err">父类名</span><span class="p">(</span><span class="err">父类构造器列表</span><span class="p">),</span><span class="err">自己的成员</span>
<span class="p">{</span>
    <span class="c1">//在参数列表里调用父类构造器，然后再初始化自己的成员
</span><span class="c1"></span>    <span class="c1">//在父类中如果有标配，重载或默认，把无参的情况包含进来，子类可以不显式的调用父类构造器，隐式调用
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">//初始化顺序，父类，其他类对象成员，本类的初始化
</span></code></pre></td></tr></table>
</div>
</div></li>
<li>派生类的拷贝构造器
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//子类未实现拷贝时，会调用父类构造器
</span><span class="c1">//子类一旦实现拷贝构造，则必须显式的调用父类拷贝构造器
</span><span class="c1"></span><span class="n">son</span><span class="p">(</span><span class="k">const</span> <span class="n">son</span> <span class="o">&amp;</span> <span class="n">another</span><span class="p">)</span>
    <span class="o">:</span><span class="n">father</span><span class="p">(</span><span class="n">another</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// ↑↑↑赋值兼容（子类对象(引用或指针)可以赋给父类对象）
</span><span class="c1"></span>    <span class="k">this</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">=</span><span class="n">another</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>派生类赋值重载
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//子类中未实现赋值重载时，会调用父类的赋值重载
</span><span class="c1">//子类一旦实现赋值重载，不会自动调用父类赋值重载
</span><span class="c1"></span><span class="n">son</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">son</span><span class="o">&amp;</span> <span class="n">another</span><span class="p">)</span>
<span class="p">{</span>
                        <span class="c1">//赋值兼容
</span><span class="c1"></span>    <span class="n">father</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">another</span><span class="p">);</span><span class="c1">//重载是会被子类继承的，所以可以调用。与构造器不同
</span><span class="c1"></span>    <span class="k">this</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">=</span><span class="n">another</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>重名问题
<ol>
<li>子类中会把父类中重名的成员shadow掉，只需要名字相同即可</li>
<li>尽量不要重名，否则，调用时加上命名空间</li>
<li>overload 重载 发生在同一作用域，函数名相同，参数列表不同（个数，类型，顺序）</li>
<li>shadow 发生在父子类当中，只要函数名相同即可</li>
</ol>
</li>
<li>派生类的友元函数
<ol>
<li>父类的友元函数，子类也可以调用</li>
<li>传参时子类赋值给了父类，赋值兼容</li>
</ol>
</li>
<li>派生类的析构器
<ol>
<li>析构顺序：子类，成员，基类</li>
<li>与构造相反</li>
</ol>
</li>
<li>多继承
<ol>
<li>你有n个爹（逃）</li>
<li>三角问题，多个父类中相同的成员，用到要加父类作用域
<ul>
<li>给调用者带来很大的不便</li>
<li>办法，提取相同成员到一个公共类M中，然后让被提取的类，分别继承这个公共类M（三角变成了四角）
<ul>
<li>但是子类还是无法访问这个成员，因为两个基类都继承了M，这个成员还是有两份</li>
<li>最终办法 虚继承</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li>虚继承 virtual(加在继承方式前面)
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//上面的 M 就叫做 虚基类
</span><span class="c1">//虚继承的意义：在多继承中，保存各个父类的多份同名成员，虽然有时是必要的，可以在不同数据成员中存放不同数据，但在大多数情况下
</span><span class="c1">//是我们不希望出现的，因为保留多份数据成员的拷贝，不仅占用较多的存储空间，还增加了访问困难
</span><span class="c1">//虚基类和虚继承，实现了在多继承中只保留一份共同（同名）成员。
</span><span class="c1">//虚基类，需要抽象和设计，虚继承，是一种继承的扩展
</span><span class="c1">//初始化问题，多继承的类中一定要调用虚基类的构造器，父类可以用默认
</span><span class="c1"></span><span class="k">class</span> <span class="nc">A</span><span class="p">{</span>
    <span class="n">A</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">){}</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">B</span><span class="o">:</span><span class="k">virtual</span> <span class="k">public</span> <span class="n">A</span><span class="p">{</span>
    <span class="n">B</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span><span class="o">:</span><span class="n">A</span><span class="p">(</span><span class="n">n</span><span class="p">){}</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">C</span><span class="o">:</span><span class="k">virtual</span> <span class="k">public</span> <span class="n">A</span><span class="p">{</span>
    <span class="n">C</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span><span class="o">:</span><span class="n">A</span><span class="p">(</span><span class="n">n</span><span class="p">){}</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">D</span><span class="o">:</span><span class="k">public</span> <span class="n">B</span><span class="p">,</span><span class="k">public</span> <span class="n">C</span><span class="p">{</span>
    <span class="n">D</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span><span class="o">:</span><span class="n">A</span><span class="p">(</span><span class="n">n</span><span class="p">),</span><span class="n">B</span><span class="p">(</span><span class="n">n</span><span class="p">),</span><span class="n">C</span><span class="p">(</span><span class="n">n</span><span class="p">){}</span><span class="c1">//结果有A()控制，其他配角
</span><span class="c1"></span><span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ol>
<h2 id="71-多态polymorphism">7.1 <strong><ruby>多态<rt>PolyMorphism</rt></ruby></strong></h2>
<p>男人不止一面（逃），几个相似但不完全相同的对象，收到同一个消息后，执行不同的操作</p>
<p>c++中所谓的多态是指，由继承而产生的相关的不同的类，其对象对同一消息会做出不同的响应</p>
<p>增加程序的灵活性，可以减轻系统升级，维护，调试的工作量和复杂度</p>
<ol>
<li>赋值兼容（多态实现的前提）
<ul>
<li>赋值兼容规则 是指在需要基类对象的任何地方都可以使用 公有派生类(其他不行) 的对象来替代，赋值兼容是一种默认行为，不需要任何的显式步骤</li>
<li>派生类的对象可以赋值给基类对象</li>
<li>派生类的对象可以初始化基类的引用</li>
<li>派生类的对象的地址可以赋给指向基类的指针</li>
<li>只能使用基类原有的成员</li>
</ul>
</li>
<li>多态形成的条件
<ol>
<li>静多态: 函数重载，也是一种多态现象，通过命名倾轧在编译阶段决定，故称静多态</li>
<li>动多态: 在运行阶段决定 条件是
<ol>
<li>父类中有虚函数</li>
<li>子类override(覆写)父类中的虚函数</li>
<li>用已被子类对象赋值的父类指针或引用（对象不行），调用共用接口（发生虚函数调用）</li>
</ol>
</li>
</ol>
</li>
<li>虚函数
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">func</span><span class="p">();</span><span class="c1">//只需在声明时加；
</span><span class="c1"></span><span class="p">};</span>
<span class="c1">//父类时有虚函数时，子类覆写override虚函数时（同名同参同返回），可以不加virtual，但建议加上
</span><span class="c1">//将子类对象赋值给父类引用或指针时，用这个父类指针或引用访问的虚函数为子类的虚函数（如果有的话）
</span><span class="c1">//子类中虚函数的访问权限可以不和父类一致
</span><span class="c1">//覆写范围是很大的，如果不覆写默认从父类继承
</span></code></pre></td></tr></table>
</div>
</div></li>
<li>纯虚函数
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">func</span><span class="p">()</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="c1">//格式，没有实现体
</span><span class="c1"></span><span class="p">};</span>
<span class="c1">//含有纯虚函数的类，称为抽象基类（java中叫interface），不可以实例化（A a; 不可以）
</span><span class="c1">//作用就是给族类提供接口用的,抽象基类不能实例化，但可以用指针和引用指向一个子类，实现多态
</span><span class="c1">//抽象基类存在的意义就是被继承
</span><span class="c1">//如果派生类中没有对该函数override，则这个函数在派生类中仍为纯虚函数，派生类仍为纯虚基类
</span></code></pre></td></tr></table>
</div>
</div></li>
<li>含有虚函数的析构: 虚析构，就是为了delete基类指针时将子类对象析构完全
<ul>
<li>含有虚函数的类，析构函数也应该声明为虚函数</li>
<li>在delete父类指针的时候，会调用子类的析构函数，实现完整析构</li>
<li>当一个类中有虚函数的时候，请将析构器声明为vritual</li>
</ul>
</li>
<li>若干限制
<ol>
<li>静态成员函数不能是虚函数，静态成员函数不受对象的捆绑，只有类的信息</li>
<li>内联函数，普通函数，不能是虚函数</li>
<li>构造函数不能是虚函数</li>
<li>析构函数通常声明为虚函数</li>
</ol>
</li>
<li>设计模式 &ndash; 依赖倒置原则
//定义，高层模块不应该依赖底层模块，二者都应该依赖抽象
//抽象不应该依赖细节，细节应该依赖抽象
//核心：面向接口编程</li>
</ol>
<h2 id="81-多态的实现原理">8.1 多态的实现原理</h2>
<ol>
<li>虚函数表 virtual table
<ul>
<li>类实例化时，内存最前面先放一个指向v-table的指针，然后是数据成员</li>
<li>v-table中，先放父类虚函数，再放子类虚函数</li>
<li>如果子类override了父类虚函数，则替换虚函数表相应位置的函数指针</li>
<li>多态实现的前题，一定是生成完了v-table之后，所以在父类构造器调用虚函数实现不了多态</li>
</ul>
</li>
</ol>
<h2 id="82-运行时类型信息rtti">8.2 <strong><ruby>运行时类型信息<rt>RTTI</rt></ruby></strong></h2>
<p>run time type identificaition。运行时信息，来自于多态，所以一下运算符只用于基于多态的继承体系中</p>
<ol>
<li>typeid运算符
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//使用这个运算符 要包含头文件&lt;typeinfo&gt;
</span><span class="c1">//返回包含数据信息的type_info对象引用
</span><span class="c1">//type_info重载了==,!=来比较是否相等，函数name()返回类型名称
</span><span class="c1">//type_info的拷贝赋值为私有，不可操作，只用来做调试
</span><span class="c1"></span><span class="n">B</span> <span class="n">b</span><span class="p">;</span>
<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="k">typeid</span><span class="p">(</span><span class="n">b</span><span class="p">).</span><span class="n">name</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span><span class="c1">//输出b信息
</span><span class="c1"></span><span class="n">A</span> <span class="o">*</span> <span class="n">a</span><span class="o">=&amp;</span><span class="n">b</span><span class="p">;</span>
<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="k">typeid</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">).</span><span class="n">name</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span><span class="c1">//输出b信息
</span><span class="c1">//可以帮你辨别一个指针到底指向谁，在多态中
</span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
<h2 id="83-typecast">8.3 typecast</h2>
<ol>
<li><code>static_cast&lt;&gt;()</code>
<ul>
<li>在一个方向上可以做隐式转换，在另一个方向方向可以做静态转换</li>
<li>发生在编译阶段，不保证后续使用的正确性</li>
<li>用于父子类不安全</li>
</ul>
</li>
<li><code>reinterpret_cast&lt;&gt;()</code>
<ul>
<li>既不在编译期也不再运行期进行检查，安全性完全由程序员决定</li>
</ul>
</li>
<li><code>dynamic_cast&lt;&gt;()</code>
<ul>
<li>运行时的类型转换方法，检查指针所指类型，然后判断是否与要转换的类型有一种“is a”的关系</li>
<li>如果是，返回对象地址，不是返回null</li>
<li>只用于含有虚函数的父子类中</li>
</ul>
</li>
</ol>
<h2 id="9-c模板-template">9 c++模板 template</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//泛型（Generic Programming）：多种数据类型上皆可操作的含义
</span><span class="c1">//语法格式
</span><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="o">/</span><span class="k">class</span> <span class="err">类型参数表</span><span class="o">&gt;</span>
<span class="err">返回类型</span> <span class="err">函数模板名</span><span class="p">(</span><span class="err">函数参数表</span><span class="p">)</span>
<span class="p">{</span>
    <span class="err">函数模板实现体</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span><span class="k">typename</span> <span class="n">T2</span><span class="p">....</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">swapp</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span><span class="n">T</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">a</span><span class="o">^=</span><span class="n">b</span><span class="p">;</span><span class="n">b</span><span class="o">^=</span><span class="n">a</span><span class="p">;</span><span class="n">a</span><span class="o">^=</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">stackk</span><span class="p">{</span>
    <span class="n">stackk</span><span class="p">();</span>
<span class="p">};</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">stackk</span><span class="o">::</span><span class="n">stackk</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()</span>
<span class="p">{}</span>
<span class="c1">//定义实现分开时，都要顶着帽子，（写类时，函数在外部实现也要戴帽子，并且函数名后加&lt;T&gt;）
</span><span class="c1">//模板适用于参数个数相同，函数体相同的情况
</span><span class="c1">//参数个数如果不同，不要使用模板
</span></code></pre></td></tr></table>
</div>
</div><h2 id="10-c-流类综述">10 C++ 流类综述</h2>
<p>流类对象都重载了 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code></p>
<ol>
<li>输入输出IO流
<ul>
<li>IO对象的构造器和赋值重载是private，不能拷贝或赋值，使用时只能传引用或指针</li>
<li>IO对象是由缓冲区的，缓冲区写满或遇到endl才写入,(cin背后是键盘，cout背后是屏幕)</li>
<li>endl,flush,unitbuf 都可以刷缓冲</li>
</ul>
</li>
<li>标准输出 cout cerr clog
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//cout.unsetf(ios::dec);
</span><span class="c1">//cout.setf(ios::hex);
</span><span class="c1">//&lt;iomanip&gt; 流算子头文件,上面并不好用
</span><span class="c1">//cout&lt;&lt;hed&lt;&lt;a&lt;&lt;endl;
</span></code></pre></td></tr></table>
</div>
</div></li>
<li>标准输入 cin
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//istream 成员函数
</span><span class="c1"></span><span class="n">cin</span><span class="p">.</span><span class="n">get</span><span class="p">();</span><span class="c1">//读一个字符返回，包括空格回车tab空字符
</span><span class="c1"></span><span class="n">cin</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="mi">1024</span><span class="p">,</span><span class="sc">&#39;\n&#39;</span><span class="p">);</span>
<span class="n">cin</span><span class="p">.</span><span class="n">getline</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="mi">1024</span><span class="p">,</span><span class="err">&#39;默认回车&#39;</span><span class="p">);</span>
<span class="n">istream</span><span class="o">&amp;</span> <span class="n">ignore</span><span class="p">(</span><span class="n">streamsize</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="kt">int</span> <span class="n">delim</span><span class="o">=</span><span class="n">EOF</span><span class="p">);</span><span class="c1">//跳过n个或遇到delim为止，delim也被跳过
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">peek</span><span class="p">();</span><span class="c1">//窥视 当前指针不改动，返回内容（int 型），自己转char
</span><span class="c1"></span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">putback</span><span class="p">(</span><span class="kt">char</span> <span class="n">c</span><span class="p">);</span><span class="c1">//回推指针，并在此位置替换为c
</span></code></pre></td></tr></table>
</div>
</div></li>
<li>文件IO流
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">ifstream</span> <span class="nf">ifile</span><span class="p">(</span><span class="s">&#34;1.txt&#34;</span><span class="p">);</span><span class="c1">//只能从文件读入 默认模式 ios::in
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">ifile</span><span class="p">)</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;打开失败&#34;</span><span class="p">;</span>
<span class="n">ofstream</span> <span class="nf">ofile</span><span class="p">(</span><span class="s">&#34;2.txt&#34;</span><span class="p">);</span><span class="c1">//只能写到文件 默认模式 ios::out|ios::trunc
</span><span class="c1"></span>    <span class="c1">//没有这个文件自动创建
</span><span class="c1"></span><span class="n">fstream</span>  <span class="nf">iofile</span><span class="p">(</span><span class="s">&#34;3.txt&#34;</span><span class="p">);</span><span class="c1">//默认模式 ios::in|ios::out|ios::app
</span><span class="c1"></span>    <span class="n">iofile</span><span class="p">.</span><span class="n">close</span><span class="p">();</span><span class="c1">//刷缓冲区
</span><span class="c1"></span><span class="n">ios</span><span class="o">::</span><span class="n">in</span> <span class="n">ios</span><span class="o">::</span><span class="n">out</span> <span class="c1">//不会自动创建文件
</span><span class="c1"></span><span class="n">ios</span><span class="o">::</span><span class="n">trunc</span> <span class="c1">//覆盖原来 会自动创建文件
</span><span class="c1"></span><span class="n">ios</span><span class="o">::</span><span class="n">app</span> <span class="c1">//追加 会自动创建文件
</span><span class="c1"></span><span class="n">ios</span><span class="o">::</span><span class="n">binary</span> <span class="c1">//二进制方式
</span><span class="c1"></span>
<span class="n">ios</span><span class="o">::</span><span class="n">cur</span> <span class="c1">//文件当前位置
</span><span class="c1"></span><span class="n">ios</span><span class="o">::</span><span class="n">end</span> <span class="c1">//文件末尾
</span><span class="c1"></span><span class="n">f</span><span class="p">.</span><span class="n">seekg</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span><span class="n">ios</span><span class="o">::</span><span class="n">cur</span><span class="p">);</span><span class="c1">//seekget 从当前位置向后50
</span><span class="c1"></span><span class="n">f</span><span class="p">.</span><span class="n">seekp</span><span class="p">(</span><span class="o">-</span><span class="mi">50</span><span class="p">,</span><span class="n">ios</span><span class="o">::</span><span class="n">end</span><span class="p">);</span><span class="c1">//seekput 从文件尾向前50
</span><span class="c1"></span>
<span class="c1">//标识
</span><span class="c1"></span><span class="n">f</span><span class="p">.</span><span class="n">eof</span><span class="p">();</span><span class="c1">//达到文件尾，返回true
</span><span class="c1"></span><span class="n">f</span><span class="p">.</span><span class="n">bad</span><span class="p">();</span><span class="c1">//读写过程出错，返回true
</span><span class="c1"></span><span class="n">f</span><span class="p">.</span><span class="n">fail</span><span class="p">();</span><span class="c1">//除了和bad()一样，格式错误（例如想要读整数，得到字母），遇到eof都返回true
</span><span class="c1"></span><span class="n">f</span><span class="p">.</span><span class="n">good</span><span class="p">();</span><span class="c1">//上面任何返回true，则返回false
</span><span class="c1"></span><span class="n">f</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span><span class="c1">//将所有标记位置位正常，不是清空流
</span><span class="c1"></span><span class="n">cin</span><span class="p">.</span><span class="n">sync</span><span class="p">();</span><span class="c1">//清空流
</span><span class="c1">//遍历读，一个个读
</span><span class="c1"></span><span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
<span class="k">while</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">c</span><span class="p">),</span><span class="o">!</span><span class="n">f</span><span class="p">.</span><span class="n">eof</span><span class="p">()){</span>
    <span class="n">f2</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">c</span><span class="p">);</span><span class="c1">//写入另一个文件
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">//一行一行读
</span><span class="c1"></span><span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
<span class="k">while</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">getline</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="mi">1024</span><span class="p">,</span><span class="sc">&#39;\n&#39;</span><span class="p">),</span><span class="o">!</span><span class="n">f</span><span class="p">.</span><span class="n">eof</span><span class="p">()){</span>
    <span class="n">f2</span><span class="o">&lt;&lt;</span><span class="n">buf</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span><span class="c1">//用get不会跳过\n,用getline \n被跳过，还要补；
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">//byte流读
</span><span class="c1"></span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="n">write</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">buffer</span><span class="p">,</span><span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="n">istream</span> <span class="o">&amp;</span> <span class="n">read</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">buffer</span><span class="p">,</span><span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="k">struct</span> <span class="nc">stu</span><span class="p">{</span>
    <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
    <span class="kt">char</span> <span class="n">sex</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">stu</span> <span class="n">s</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">=</span>
<span class="p">{</span>
    <span class="p">{</span><span class="s">&#34;as&#34;</span><span class="p">,</span><span class="sc">&#39;y&#39;</span><span class="p">,</span><span class="mi">12</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&#34;gg&#34;</span><span class="p">,</span><span class="sc">&#39;x&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&#34;rr&#34;</span><span class="p">,</span><span class="sc">&#39;y&#39;</span><span class="p">,</span><span class="mi">3</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&#34;ww&#34;</span><span class="p">,</span><span class="sc">&#39;x&#39;</span><span class="p">,</span><span class="mi">100</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&#34;qq&#34;</span><span class="p">,</span><span class="sc">&#39;x&#39;</span><span class="p">,</span><span class="mi">107</span><span class="p">}</span>
<span class="p">};</span>
<span class="n">fstream</span> <span class="nf">f</span><span class="p">(</span><span class="s">&#34;asd.binary&#34;</span><span class="p">,</span><span class="n">ios</span><span class="o">::</span><span class="n">in</span><span class="o">|</span><span class="n">ios</span><span class="o">::</span><span class="n">out</span><span class="o">|</span><span class="n">ios</span><span class="o">::</span><span class="n">trunc</span><span class="o">|</span><span class="n">ios</span><span class="o">::</span><span class="n">binary</span><span class="p">);</span>
<span class="c1">//f.write(s,sizeof(s));
</span><span class="c1"></span><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">5</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">f</span><span class="p">.</span><span class="n">write</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="k">sizeof</span><span class="p">(</span><span class="n">stu</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">f</span><span class="p">.</span><span class="n">seekg</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">ios</span><span class="o">::</span><span class="n">beg</span><span class="p">);</span>
<span class="n">stu</span> <span class="n">tmp</span><span class="p">;</span>
<span class="k">while</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">read</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">stu</span><span class="p">)),</span><span class="o">!</span><span class="n">f</span><span class="p">.</span><span class="n">eof</span><span class="p">()){</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">tmp</span><span class="p">.</span><span class="n">name</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ol>
<h2 id="11-异常exception">11 异常（EXCEPTION）</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//在可能出错的地方使用try-catch结构
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">x</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">throw</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="c1">//在try下面调用的函数中可以抛出异常，终止程序往下执行
</span><span class="c1"></span>            <span class="c1">//程序立即转到上面捕获异常的地方
</span><span class="c1"></span>            <span class="c1">//异常传递是一个拷贝，如果自定义类型，注意拷贝构造，
</span><span class="c1"></span><span class="p">}</span>
<span class="k">try</span><span class="p">{</span>
    <span class="n">func</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="p">}</span><span class="k">catch</span><span class="p">(</span><span class="kt">int</span> <span class="n">e</span><span class="p">)</span><span class="c1">//如果下方扔出的异常不是int型，将接不到，程序调用另一个函数，终止整个程序
</span><span class="c1"></span><span class="p">{</span><span class="c1">//可以自己写异常信息类型，这样能得到更多信息
</span><span class="c1"></span>    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;catch a exception &#34;</span><span class="o">&lt;&lt;</span><span class="n">e</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span><span class="c1">//catch执行完毕，继续执行后面的语句，如果没有匹配，系统调用terminate终止程序
</span><span class="c1">//可以有多个catch
</span><span class="c1"></span><span class="k">catch</span><span class="p">(...){</span>
    <span class="c1">//如果上面都没有接到，这个来接，有这个的时候，系统就不会调用terminate
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">//如果有多层try-catch结构，底层抛出一个异常，上层没有人接的话，继续传给上上层
</span><span class="c1">//如果直到尽头都没有人接，系统才调用terminate
</span><span class="c1"></span>    <span class="c1">//为了加强程序的可读性，可以在函数声明中列出可能抛出的所有异常类型
</span><span class="c1"></span>    <span class="c1">//例如：
</span><span class="c1"></span>        <span class="kt">void</span> <span class="nf">func</span><span class="p">()</span> <span class="k">throw</span><span class="p">(</span><span class="kt">int</span> <span class="p">,</span><span class="n">A</span> <span class="p">,</span><span class="n">B</span> <span class="p">,</span><span class="kt">double</span><span class="p">);</span><span class="c1">//括号没内容表示不抛出异常
</span><span class="c1">//栈自旋 throw抛出异常时，会在离开栈空间时销毁栈，不执行后面的代码，但看作函数执行完毕，退出销毁
</span><span class="c1"></span>    <span class="c1">//这也是为什么throw不传引用的原因
</span></code></pre></td></tr></table>
</div>
</div><p>===========================华丽的分割线===================================</p>
<p>全剧终。。。</p>
<p>至此你看完了大部分c++  没错，是看！！！</p>
]]></description>
</item><item>
    <title>C数值数据类型</title>
    <link>https://www.kirito41dd.cn/c-data-type/</link>
    <pubDate>Sun, 19 Jun 2016 12:00:34 &#43;0800</pubDate>
    <author>kirito</author>
    <guid>https://www.kirito41dd.cn/c-data-type/</guid>
    <description><![CDATA[<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p>*注：图片来自贺利坚老师C语言及程序设计初步教程的课件中</p>
<p>教程地址：<a href="http://edu.csdn.net/course/detail/271" target="_blank" rel="noopener noreffer">http://edu.csdn.net/course/detail/271</a></p>
]]></description>
</item></channel>
</rss>
